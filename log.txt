rock main.ooc -g -vv -driver=sequence -o=levelEditor -sourcepath=source/ -editor=geany -slave
Unknown driver: driver=sequence
- Parsing source//main.ooc (for module main)
- Parsing source//CApplication.ooc (for module CApplication)
- Parsing source//CVideoUpdate.ooc (for module CVideoUpdate)
Got use sdl for module CVideoUpdate
value = ., file = /usr/lib/ooc/ooc-sdl/sdl.use
Adding /usr/lib/ooc/ooc-sdl to sourcepath ...
Got use glew for module CVideoUpdate
value = ./out, file = /usr/lib/ooc/ooc-glew/glew.use
Adding /usr/lib/ooc/ooc-glew/out to sourcepath ...
- Parsing /usr/lib/ooc/ooc-glew/out/glew.ooc (for module glew)
- Parsing /home/eagle2com/dev/rock/custom-sdk//lang/system.ooc (for module lang/system)
- Parsing /home/eagle2com/dev/rock/custom-sdk//lang/stdio.ooc (for module lang/stdio)
- Parsing /home/eagle2com/dev/rock/custom-sdk//lang/vararg.ooc (for module lang/vararg)
- Parsing /home/eagle2com/dev/rock/custom-sdk//lang/memory.ooc (for module lang/memory)
- Parsing /home/eagle2com/dev/rock/custom-sdk//lang/types.ooc (for module lang/types)
- Parsing /home/eagle2com/dev/rock/custom-sdk//lang/math.ooc (for module lang/math)
- Parsing /usr/lib/ooc/ooc-sdl/sdl/Sdl.ooc (for module sdl/Sdl)
Got use sdl for module sdl/Sdl
- Parsing /usr/lib/ooc/ooc-sdl/sdl/Video.ooc (for module sdl/Video)
Got use sdl for module sdl/Video
- Parsing /usr/lib/ooc/ooc-sdl/sdl/Event.ooc (for module sdl/Event)
Got use sdl for module sdl/Event
- Parsing source//ITask.ooc (for module ITask)
- Parsing source//Listener.ooc (for module Listener)
Got use sdl for module Listener
- Parsing source//CLog.ooc (for module CLog)
- Parsing /home/eagle2com/dev/rock/custom-sdk//io/FileWriter.ooc (for module io/FileWriter)
- Parsing /home/eagle2com/dev/rock/custom-sdk//io/Writer.ooc (for module io/Writer)
- Parsing /home/eagle2com/dev/rock/custom-sdk//io/File.ooc (for module io/File)
- Parsing /home/eagle2com/dev/rock/custom-sdk//structs/ArrayList.ooc (for module structs/ArrayList)
- Parsing /home/eagle2com/dev/rock/custom-sdk//structs/List.ooc (for module structs/List)
- Parsing /home/eagle2com/dev/rock/custom-sdk//text/Buffer.ooc (for module text/Buffer)
- Parsing /home/eagle2com/dev/rock/custom-sdk//io/Reader.ooc (for module io/Reader)
- Parsing /home/eagle2com/dev/rock/custom-sdk//io/FileReader.ooc (for module io/FileReader)
- Parsing /home/eagle2com/dev/rock/custom-sdk//io/native/FileWin32.ooc (for module io/native/FileWin32)
- Parsing /home/eagle2com/dev/rock/custom-sdk//native/win32/types.ooc (for module native/win32/types)
- Parsing /home/eagle2com/dev/rock/custom-sdk//io/native/FileUnix.ooc (for module io/native/FileUnix)
- Parsing /home/eagle2com/dev/rock/custom-sdk//os/Time.ooc (for module os/Time)
- Parsing /home/eagle2com/dev/rock/custom-sdk//io/native/dirent.ooc (for module io/native/dirent)
- Parsing source//CInputTask.ooc (for module CInputTask)
Got use sdl for module CInputTask
- Parsing /home/eagle2com/dev/rock/custom-sdk//structs/LinkedList.ooc (for module structs/LinkedList)
- Parsing /home/eagle2com/dev/rock/custom-sdk//os/Terminal.ooc (for module os/Terminal)
- Parsing source//CGlobalTimer.ooc (for module CGlobalTimer)
Got use sdl for module CGlobalTimer
- Parsing source//CKernel.ooc (for module CKernel)
Got use sdl for module CKernel
- Parsing source//LevelEditor.ooc (for module LevelEditor)
Got use sdl for module LevelEditor
Got use glew for module LevelEditor
Got use glu for module LevelEditor
value = ., file = /usr/lib/ooc/ooc-glu/glu.use
Adding /usr/lib/ooc/ooc-glu to sourcepath ...
- Parsing /usr/lib/ooc/ooc-glu/glu/Glu.ooc (for module glu/Glu)
Got use glu for module glu/Glu
- Parsing source//CFactory.ooc (for module CFactory)
- Parsing source//CProduct.ooc (for module CProduct)
Got use glew for module CProduct
- Parsing source//utils/types.ooc (for module utils/types)
- Parsing /home/eagle2com/dev/rock/custom-sdk//structs/HashMap.ooc (for module structs/HashMap)
- Parsing source//FFCamera.ooc (for module FFCamera)
Got use sdl for module FFCamera
Got use glew for module FFCamera
Got use glu for module FFCamera
- Parsing source//Camera.ooc (for module Camera)
Got use sdl for module Camera
Got use glew for module Camera
Got use glu for module Camera
- Parsing source//Movable.ooc (for module Movable)
Got use sdl for module Movable
- Parsing source//World.ooc (for module World)
Got use glew for module World
Got use glu for module World
- Parsing source//GameObject.ooc (for module GameObject)
Got use glew for module GameObject
- Parsing source//utils/text.ooc (for module utils/text)
- Parsing source//utils/convert.ooc (for module utils/convert)
Got use math for module utils/convert
- Parsing /home/eagle2com/dev/rock/custom-sdk//text/StringTokenizer.ooc (for module text/StringTokenizer)

=======================================

Tinkerer, round 1, 48 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module main
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CApplication get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CApplication get() run() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CApplication get() run() (of type FunctionCall) wants to wholeAgain() because 'CApplication get() run() looping because not resolved!'
main: func  -> Int (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CApplication
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CApplication
Resolving variable decl videoTask : CVideoUpdate
Resolving variable decl globalTimer : CGlobalTimer
Resolving variable decl inputTask : CInputTask
====== Resolving type decl ClassDecl CApplicationClass
Resolving variable decl instance : This = NullLiteral
this new() (of type FunctionCall) wants to wholeAgain() because 'because of return type CApplication'
Resolving variable decl this : <unknown type> = CApplication alloc() as CApplication
CApplication alloc() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this : CApplication = CApplication alloc() as CApplication (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
CGlobalTimer get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
globalTimer = CGlobalTimer get() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
     - access to globalTimer->priority still not resolved, looping (ref = (nil))
CGlobalTimer.priority (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve CGlobalTimer.priority'
CGlobalTimer.priority = 10 (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
inputTask = CInputTask get() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
     - access to inputTask->priority still not resolved, looping (ref = (nil))
CInputTask.priority (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve CInputTask.priority'
CInputTask.priority = 20 (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
Resolving variable decl test : <unknown type> = LevelEditor new()
LevelEditor new() (of type FunctionCall) wants to wholeAgain() because 'because of return type LevelEditor'
     - access to test->priority still not resolved, looping (ref = (nil))
LevelEditor.priority (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve LevelEditor.priority'
LevelEditor.priority = 100 (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
CVideoUpdate get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
videoTask = CVideoUpdate get() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
     - access to videoTask->priority still not resolved, looping (ref = (nil))
CVideoUpdate.priority (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve CVideoUpdate.priority'
CVideoUpdate.priority = 10000 (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
Resolving variable decl kernel : <unknown type> = CKernel get()
CKernel get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
kernel : <unknown type> = CKernel get() (of type VariableDecl) wants to wholeAgain() because 'must determine type of kernel : <unknown type> = CKernel get()
'
kernel addTask(globalTimer) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel addTask(globalTimer) (of type FunctionCall) wants to wholeAgain() because 'kernel addTask(globalTimer) looping because not resolved!'
kernel addTask(inputTask) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel addTask(inputTask) (of type FunctionCall) wants to wholeAgain() because 'kernel addTask(inputTask) looping because not resolved!'
kernel addTask(videoTask) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel addTask(videoTask) (of type FunctionCall) wants to wholeAgain() because 'kernel addTask(videoTask) looping because not resolved!'
kernel addTask(test) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel addTask(test) (of type FunctionCall) wants to wholeAgain() because 'kernel addTask(test) looping because not resolved!'
kernel execute() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel execute() (of type FunctionCall) wants to wholeAgain() because 'kernel execute() looping because not resolved!'
====== Resolving type decl ClassDecl CApplicationClass
Resolving variable decl instance : CApplication = NullLiteral
Resolving variable decl this : CApplication = CApplication alloc() as CApplication
CApplication alloc() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this : CApplication = CApplication alloc() as CApplication (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
CGlobalTimer get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CApplication.globalTimer = CGlobalTimer get() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
     - access to CApplication.globalTimer->priority still not resolved, looping (ref = (nil))
CGlobalTimer.priority (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve CGlobalTimer.priority'
CGlobalTimer.priority = 10 (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CApplication.inputTask = CInputTask get() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
     - access to CApplication.inputTask->priority still not resolved, looping (ref = (nil))
CInputTask.priority (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve CInputTask.priority'
CInputTask.priority = 20 (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
Resolving variable decl test : LevelEditor = LevelEditor new()
     - access to test->priority still not resolved, looping (ref = (nil))
LevelEditor.priority (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve LevelEditor.priority'
LevelEditor.priority = 100 (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
CVideoUpdate get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CApplication.videoTask = CVideoUpdate get() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
     - access to CApplication.videoTask->priority still not resolved, looping (ref = (nil))
CVideoUpdate.priority (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve CVideoUpdate.priority'
CVideoUpdate.priority = 10000 (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
Resolving variable decl kernel : <unknown type> = CKernel get()
CKernel get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
kernel : <unknown type> = CKernel get() (of type VariableDecl) wants to wholeAgain() because 'must determine type of kernel : <unknown type> = CKernel get()
'
kernel addTask(CApplication.globalTimer) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel addTask(CApplication.globalTimer) (of type FunctionCall) wants to wholeAgain() because 'kernel addTask(CApplication.globalTimer) looping because not resolved!'
kernel addTask(CApplication.inputTask) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel addTask(CApplication.inputTask) (of type FunctionCall) wants to wholeAgain() because 'kernel addTask(CApplication.inputTask) looping because not resolved!'
kernel addTask(CApplication.videoTask) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel addTask(CApplication.videoTask) (of type FunctionCall) wants to wholeAgain() because 'kernel addTask(CApplication.videoTask) looping because not resolved!'
kernel addTask(test) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel addTask(test) (of type FunctionCall) wants to wholeAgain() because 'kernel addTask(test) looping because not resolved!'
kernel execute() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
kernel execute() (of type FunctionCall) wants to wholeAgain() because 'kernel execute() looping because not resolved!'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CVideoUpdate
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CVideoUpdate
Resolving variable decl scrWidth : Int
Resolving variable decl scrHeight : Int
Resolving variable decl scrBPP : Int
Resolving variable decl surface : Surface*
====== Resolving type decl ClassDecl CVideoUpdateClass
Resolving variable decl instance : This = NullLiteral
Resolving variable decl this : <unknown type> = CVideoUpdate alloc() as CVideoUpdate
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'CVideoUpdate alloc() looping because not resolved!'
this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init(scrWidth, scrHeight, scrBPP) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=scrWidth (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=scrHeight (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=scrBPP (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl this : <unknown type> = CVideoUpdate alloc() as CVideoUpdate
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'CVideoUpdate alloc() looping because not resolved!'
this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
This new(1280, 800, 32) (of type FunctionCall) wants to wholeAgain() because 'because of return type CVideoUpdate'
SDL init(SDL_INIT_EVERYTHING) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
SDL init(SDL_INIT_EVERYTHING) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL init(SDL_INIT_EVERYTHING) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
-1 == SDL init(SDL_INIT_EVERYTHING) (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
SDL getError() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = "Video: " (who is null? false, false, true, false)'
CLog get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) looping because not resolved!'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask get() regEvent(this) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CInputTask get() regEvent(this) (of type FunctionCall) wants to wholeAgain() because 'CInputTask get() regEvent(this) looping because not resolved!'
Resolving variable decl flags : <unknown type> = SDL_OPENGL | SDL_ANYFORMAT
SDL_OPENGL | SDL_ANYFORMAT (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = SDL_OPENGL (who is null? false, true, false, true)'
SDLVideo setMode(scrWidth, scrHeight, scrBPP, flags) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
SDLVideo setMode(scrWidth, scrHeight, scrBPP, flags) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDLVideo setMode(scrWidth, scrHeight, scrBPP, flags) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
surface = SDLVideo setMode(scrWidth, scrHeight, scrBPP, flags) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
SDL getError() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = "Video: " (who is null? false, false, true, false)'
CLog get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) looping because not resolved!'
SDL GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_RED_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL GL_SetAttribute(SDL_GL_RED_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_RED_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_GREEN_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL GL_SetAttribute(SDL_GL_GREEN_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_GREEN_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_BLUE_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL GL_SetAttribute(SDL_GL_BLUE_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_BLUE_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glShadeModel(GL_SMOOTH) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
glShadeModel(GL_SMOOTH) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
glShadeModel(GL_SMOOTH) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glEnable(GL_DEPTH_TEST) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
glEnable(GL_DEPTH_TEST) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
glEnable(GL_DEPTH_TEST) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL showCursor(SDL_DISABLE) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL showCursor(SDL_DISABLE) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL showCursor(SDL_DISABLE) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask get() unRegEvent(this) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CInputTask get() unRegEvent(this) (of type FunctionCall) wants to wholeAgain() because 'CInputTask get() unRegEvent(this) looping because not resolved!'
SDL quitSubSystem(SDL_INIT_VIDEO) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL quitSubSystem(SDL_INIT_VIDEO) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL quitSubSystem(SDL_INIT_VIDEO) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDLVideo glSwapBuffers() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
====== Resolving type decl ClassDecl CVideoUpdateClass
Resolving variable decl instance : CVideoUpdate = NullLiteral
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'CVideoUpdate alloc() looping because not resolved!'
this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'CVideoUpdate alloc() looping because not resolved!'
this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
SDL init(SDL_INIT_EVERYTHING) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
SDL init(SDL_INIT_EVERYTHING) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL init(SDL_INIT_EVERYTHING) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
-1 == SDL init(SDL_INIT_EVERYTHING) (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
SDL getError() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = "Video: " (who is null? false, false, true, false)'
CLog get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) looping because not resolved!'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask get() regEvent(this) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CInputTask get() regEvent(this) (of type FunctionCall) wants to wholeAgain() because 'CInputTask get() regEvent(this) looping because not resolved!'
Resolving variable decl flags : Int = SDL_OPENGL | SDL_ANYFORMAT
SDL_OPENGL | SDL_ANYFORMAT (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = SDL_OPENGL (who is null? false, false, false, true)'
SDLVideo setMode(CVideoUpdate.scrWidth, CVideoUpdate.scrHeight, CVideoUpdate.scrBPP, flags) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
SDLVideo setMode(CVideoUpdate.scrWidth, CVideoUpdate.scrHeight, CVideoUpdate.scrBPP, flags) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDLVideo setMode(CVideoUpdate.scrWidth, CVideoUpdate.scrHeight, CVideoUpdate.scrBPP, flags) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
CVideoUpdate.surface = SDLVideo setMode(CVideoUpdate.scrWidth, CVideoUpdate.scrHeight, CVideoUpdate.scrBPP, flags) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
SDL getError() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = "Video: " (who is null? false, false, true, false)'
CLog get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'CLog get() write(LOG_CLIENT, "Video: " + SDL getError()) looping because not resolved!'
SDL GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_RED_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_RED_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_GREEN_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_GREEN_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_BLUE_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_BLUE_SIZE, 8) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glShadeModel(GL_SMOOTH) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
glShadeModel(GL_SMOOTH) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
glShadeModel(GL_SMOOTH) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glEnable(GL_DEPTH_TEST) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
glEnable(GL_DEPTH_TEST) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
glEnable(GL_DEPTH_TEST) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL showCursor(SDL_DISABLE) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL showCursor(SDL_DISABLE) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask get() unRegEvent(this) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CInputTask get() unRegEvent(this) (of type FunctionCall) wants to wholeAgain() because 'CInputTask get() unRegEvent(this) looping because not resolved!'
SDL quitSubSystem(SDL_INIT_VIDEO) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
SDL quitSubSystem(SDL_INIT_VIDEO) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module glew
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl GLEW_APPLE_client_storage : GLboolean
Resolving variable decl GLEW_APPLE_element_array : GLboolean
Resolving variable decl GLEW_APPLE_fence : GLboolean
Resolving variable decl GLEW_APPLE_float_pixels : GLboolean
Resolving variable decl GLEW_APPLE_flush_buffer_range : GLboolean
Resolving variable decl GLEW_APPLE_pixel_buffer : GLboolean
Resolving variable decl GLEW_APPLE_specular_vector : GLboolean
Resolving variable decl GLEW_APPLE_texture_range : GLboolean
Resolving variable decl GLEW_APPLE_transform_hint : GLboolean
Resolving variable decl GLEW_APPLE_vertex_array_object : GLboolean
Resolving variable decl GLEW_APPLE_vertex_array_range : GLboolean
Resolving variable decl GLEW_APPLE_ycbcr_422 : GLboolean
Resolving variable decl GLEW_ARB_color_buffer_float : GLboolean
Resolving variable decl GLEW_ARB_depth_buffer_float : GLboolean
Resolving variable decl GLEW_ARB_depth_texture : GLboolean
Resolving variable decl GLEW_ARB_draw_buffers : GLboolean
Resolving variable decl GLEW_ARB_draw_instanced : GLboolean
Resolving variable decl GLEW_ARB_fragment_program : GLboolean
Resolving variable decl GLEW_ARB_fragment_program_shadow : GLboolean
Resolving variable decl GLEW_ARB_fragment_shader : GLboolean
Resolving variable decl GLEW_ARB_framebuffer_object : GLboolean
Resolving variable decl GLEW_ARB_framebuffer_sRGB : GLboolean
Resolving variable decl GLEW_ARB_geometry_shader4 : GLboolean
Resolving variable decl GLEW_ARB_half_float_pixel : GLboolean
Resolving variable decl GLEW_ARB_half_float_vertex : GLboolean
Resolving variable decl GLEW_ARB_imaging : GLboolean
Resolving variable decl GLEW_ARB_instanced_arrays : GLboolean
Resolving variable decl GLEW_ARB_map_buffer_range : GLboolean
Resolving variable decl GLEW_ARB_matrix_palette : GLboolean
Resolving variable decl GLEW_ARB_multisample : GLboolean
Resolving variable decl GLEW_ARB_multitexture : GLboolean
Resolving variable decl GLEW_ARB_occlusion_query : GLboolean
Resolving variable decl GLEW_ARB_pixel_buffer_object : GLboolean
Resolving variable decl GLEW_ARB_point_parameters : GLboolean
Resolving variable decl GLEW_ARB_point_sprite : GLboolean
Resolving variable decl GLEW_ARB_shader_objects : GLboolean
Resolving variable decl GLEW_ARB_shading_language_100 : GLboolean
Resolving variable decl GLEW_ARB_shadow : GLboolean
Resolving variable decl GLEW_ARB_shadow_ambient : GLboolean
Resolving variable decl GLEW_ARB_texture_border_clamp : GLboolean
Resolving variable decl GLEW_ARB_texture_buffer_object : GLboolean
Resolving variable decl GLEW_ARB_texture_compression : GLboolean
Resolving variable decl GLEW_ARB_texture_compression_rgtc : GLboolean
Resolving variable decl GLEW_ARB_texture_cube_map : GLboolean
Resolving variable decl GLEW_ARB_texture_env_add : GLboolean
Resolving variable decl GLEW_ARB_texture_env_combine : GLboolean
Resolving variable decl GLEW_ARB_texture_env_crossbar : GLboolean
Resolving variable decl GLEW_ARB_texture_env_dot3 : GLboolean
Resolving variable decl GLEW_ARB_texture_float : GLboolean
Resolving variable decl GLEW_ARB_texture_mirrored_repeat : GLboolean
Resolving variable decl GLEW_ARB_texture_non_power_of_two : GLboolean
Resolving variable decl GLEW_ARB_texture_rectangle : GLboolean
Resolving variable decl GLEW_ARB_texture_rg : GLboolean
Resolving variable decl GLEW_ARB_transpose_matrix : GLboolean
Resolving variable decl GLEW_ARB_vertex_array_object : GLboolean
Resolving variable decl GLEW_ARB_vertex_blend : GLboolean
Resolving variable decl GLEW_ARB_vertex_buffer_object : GLboolean
Resolving variable decl GLEW_ARB_vertex_program : GLboolean
Resolving variable decl GLEW_ARB_vertex_shader : GLboolean
Resolving variable decl GLEW_ARB_window_pos : GLboolean
Resolving variable decl GLEW_ATIX_point_sprites : GLboolean
Resolving variable decl GLEW_ATIX_texture_env_combine3 : GLboolean
Resolving variable decl GLEW_ATIX_texture_env_route : GLboolean
Resolving variable decl GLEW_ATIX_vertex_shader_output_point_size : GLboolean
Resolving variable decl GLEW_ATI_draw_buffers : GLboolean
Resolving variable decl GLEW_ATI_element_array : GLboolean
Resolving variable decl GLEW_ATI_envmap_bumpmap : GLboolean
Resolving variable decl GLEW_ATI_fragment_shader : GLboolean
Resolving variable decl GLEW_ATI_map_object_buffer : GLboolean
Resolving variable decl GLEW_ATI_pn_triangles : GLboolean
Resolving variable decl GLEW_ATI_separate_stencil : GLboolean
Resolving variable decl GLEW_ATI_shader_texture_lod : GLboolean
Resolving variable decl GLEW_ATI_text_fragment_shader : GLboolean
Resolving variable decl GLEW_ATI_texture_compression_3dc : GLboolean
Resolving variable decl GLEW_ATI_texture_env_combine3 : GLboolean
Resolving variable decl GLEW_ATI_texture_float : GLboolean
Resolving variable decl GLEW_ATI_texture_mirror_once : GLboolean
Resolving variable decl GLEW_ATI_vertex_array_object : GLboolean
Resolving variable decl GLEW_ATI_vertex_attrib_array_object : GLboolean
Resolving variable decl GLEW_ATI_vertex_streams : GLboolean
Resolving variable decl GLEW_EXT_422_pixels : GLboolean
Resolving variable decl GLEW_EXT_Cg_shader : GLboolean
Resolving variable decl GLEW_EXT_abgr : GLboolean
Resolving variable decl GLEW_EXT_bgra : GLboolean
Resolving variable decl GLEW_EXT_bindable_uniform : GLboolean
Resolving variable decl GLEW_EXT_blend_color : GLboolean
Resolving variable decl GLEW_EXT_blend_equation_separate : GLboolean
Resolving variable decl GLEW_EXT_blend_func_separate : GLboolean
Resolving variable decl GLEW_EXT_blend_logic_op : GLboolean
Resolving variable decl GLEW_EXT_blend_minmax : GLboolean
Resolving variable decl GLEW_EXT_blend_subtract : GLboolean
Resolving variable decl GLEW_EXT_clip_volume_hint : GLboolean
Resolving variable decl GLEW_EXT_cmyka : GLboolean
Resolving variable decl GLEW_EXT_color_subtable : GLboolean
Resolving variable decl GLEW_EXT_compiled_vertex_array : GLboolean
Resolving variable decl GLEW_EXT_convolution : GLboolean
Resolving variable decl GLEW_EXT_coordinate_frame : GLboolean
Resolving variable decl GLEW_EXT_copy_texture : GLboolean
Resolving variable decl GLEW_EXT_cull_vertex : GLboolean
Resolving variable decl GLEW_EXT_depth_bounds_test : GLboolean
Resolving variable decl GLEW_EXT_direct_state_access : GLboolean
Resolving variable decl GLEW_EXT_draw_buffers2 : GLboolean
Resolving variable decl GLEW_EXT_draw_instanced : GLboolean
Resolving variable decl GLEW_EXT_draw_range_elements : GLboolean
Resolving variable decl GLEW_EXT_fog_coord : GLboolean
Resolving variable decl GLEW_EXT_fragment_lighting : GLboolean
Resolving variable decl GLEW_EXT_framebuffer_blit : GLboolean
Resolving variable decl GLEW_EXT_framebuffer_multisample : GLboolean
Resolving variable decl GLEW_EXT_framebuffer_object : GLboolean
Resolving variable decl GLEW_EXT_framebuffer_sRGB : GLboolean
Resolving variable decl GLEW_EXT_geometry_shader4 : GLboolean
Resolving variable decl GLEW_EXT_gpu_program_parameters : GLboolean
Resolving variable decl GLEW_EXT_gpu_shader4 : GLboolean
Resolving variable decl GLEW_EXT_histogram : GLboolean
Resolving variable decl GLEW_EXT_index_array_formats : GLboolean
Resolving variable decl GLEW_EXT_index_func : GLboolean
Resolving variable decl GLEW_EXT_index_material : GLboolean
Resolving variable decl GLEW_EXT_index_texture : GLboolean
Resolving variable decl GLEW_EXT_light_texture : GLboolean
Resolving variable decl GLEW_EXT_misc_attribute : GLboolean
Resolving variable decl GLEW_EXT_multi_draw_arrays : GLboolean
Resolving variable decl GLEW_EXT_multisample : GLboolean
Resolving variable decl GLEW_EXT_packed_depth_stencil : GLboolean
Resolving variable decl GLEW_EXT_packed_float : GLboolean
Resolving variable decl GLEW_EXT_packed_pixels : GLboolean
Resolving variable decl GLEW_EXT_paletted_texture : GLboolean
Resolving variable decl GLEW_EXT_pixel_buffer_object : GLboolean
Resolving variable decl GLEW_EXT_pixel_transform : GLboolean
Resolving variable decl GLEW_EXT_pixel_transform_color_table : GLboolean
Resolving variable decl GLEW_EXT_point_parameters : GLboolean
Resolving variable decl GLEW_EXT_polygon_offset : GLboolean
Resolving variable decl GLEW_EXT_rescale_normal : GLboolean
Resolving variable decl GLEW_EXT_scene_marker : GLboolean
Resolving variable decl GLEW_EXT_secondary_color : GLboolean
Resolving variable decl GLEW_EXT_separate_specular_color : GLboolean
Resolving variable decl GLEW_EXT_shadow_funcs : GLboolean
Resolving variable decl GLEW_EXT_shared_texture_palette : GLboolean
Resolving variable decl GLEW_EXT_stencil_clear_tag : GLboolean
Resolving variable decl GLEW_EXT_stencil_two_side : GLboolean
Resolving variable decl GLEW_EXT_stencil_wrap : GLboolean
Resolving variable decl GLEW_EXT_subtexture : GLboolean
Resolving variable decl GLEW_EXT_texture : GLboolean
Resolving variable decl GLEW_EXT_texture3D : GLboolean
Resolving variable decl GLEW_EXT_texture_array : GLboolean
Resolving variable decl GLEW_EXT_texture_buffer_object : GLboolean
Resolving variable decl GLEW_EXT_texture_compression_dxt1 : GLboolean
Resolving variable decl GLEW_EXT_texture_compression_latc : GLboolean
Resolving variable decl GLEW_EXT_texture_compression_rgtc : GLboolean
Resolving variable decl GLEW_EXT_texture_compression_s3tc : GLboolean
Resolving variable decl GLEW_EXT_texture_cube_map : GLboolean
Resolving variable decl GLEW_EXT_texture_edge_clamp : GLboolean
Resolving variable decl GLEW_EXT_texture_env : GLboolean
Resolving variable decl GLEW_EXT_texture_env_add : GLboolean
Resolving variable decl GLEW_EXT_texture_env_combine : GLboolean
Resolving variable decl GLEW_EXT_texture_env_dot3 : GLboolean
Resolving variable decl GLEW_EXT_texture_filter_anisotropic : GLboolean
Resolving variable decl GLEW_EXT_texture_integer : GLboolean
Resolving variable decl GLEW_EXT_texture_lod_bias : GLboolean
Resolving variable decl GLEW_EXT_texture_mirror_clamp : GLboolean
Resolving variable decl GLEW_EXT_texture_object : GLboolean
Resolving variable decl GLEW_EXT_texture_perturb_normal : GLboolean
Resolving variable decl GLEW_EXT_texture_rectangle : GLboolean
Resolving variable decl GLEW_EXT_texture_sRGB : GLboolean
Resolving variable decl GLEW_EXT_texture_shared_exponent : GLboolean
Resolving variable decl GLEW_EXT_texture_swizzle : GLboolean
Resolving variable decl GLEW_EXT_timer_query : GLboolean
Resolving variable decl GLEW_EXT_transform_feedback : GLboolean
Resolving variable decl GLEW_EXT_vertex_array : GLboolean
Resolving variable decl GLEW_EXT_vertex_array_bgra : GLboolean
Resolving variable decl GLEW_EXT_vertex_shader : GLboolean
Resolving variable decl GLEW_EXT_vertex_weighting : GLboolean
Resolving variable decl GLEW_GREMEDY_frame_terminator : GLboolean
Resolving variable decl GLEW_GREMEDY_string_marker : GLboolean
Resolving variable decl GLEW_HP_convolution_border_modes : GLboolean
Resolving variable decl GLEW_HP_image_transform : GLboolean
Resolving variable decl GLEW_HP_occlusion_test : GLboolean
Resolving variable decl GLEW_HP_texture_lighting : GLboolean
Resolving variable decl GLEW_IBM_cull_vertex : GLboolean
Resolving variable decl GLEW_IBM_multimode_draw_arrays : GLboolean
Resolving variable decl GLEW_IBM_rasterpos_clip : GLboolean
Resolving variable decl GLEW_IBM_static_data : GLboolean
Resolving variable decl GLEW_IBM_texture_mirrored_repeat : GLboolean
Resolving variable decl GLEW_IBM_vertex_array_lists : GLboolean
Resolving variable decl GLEW_INGR_color_clamp : GLboolean
Resolving variable decl GLEW_INGR_interlace_read : GLboolean
Resolving variable decl GLEW_INTEL_parallel_arrays : GLboolean
Resolving variable decl GLEW_INTEL_texture_scissor : GLboolean
Resolving variable decl GLEW_KTX_buffer_region : GLboolean
Resolving variable decl GLEW_MESAX_texture_stack : GLboolean
Resolving variable decl GLEW_MESA_pack_invert : GLboolean
Resolving variable decl GLEW_MESA_resize_buffers : GLboolean
Resolving variable decl GLEW_MESA_window_pos : GLboolean
Resolving variable decl GLEW_MESA_ycbcr_texture : GLboolean
Resolving variable decl GLEW_NV_blend_square : GLboolean
Resolving variable decl GLEW_NV_conditional_render : GLboolean
Resolving variable decl GLEW_NV_copy_depth_to_color : GLboolean
Resolving variable decl GLEW_NV_depth_buffer_float : GLboolean
Resolving variable decl GLEW_NV_depth_clamp : GLboolean
Resolving variable decl GLEW_NV_depth_range_unclamped : GLboolean
Resolving variable decl GLEW_NV_evaluators : GLboolean
Resolving variable decl GLEW_NV_explicit_multisample : GLboolean
Resolving variable decl GLEW_NV_fence : GLboolean
Resolving variable decl GLEW_NV_float_buffer : GLboolean
Resolving variable decl GLEW_NV_fog_distance : GLboolean
Resolving variable decl GLEW_NV_fragment_program : GLboolean
Resolving variable decl GLEW_NV_fragment_program2 : GLboolean
Resolving variable decl GLEW_NV_fragment_program4 : GLboolean
Resolving variable decl GLEW_NV_fragment_program_option : GLboolean
Resolving variable decl GLEW_NV_framebuffer_multisample_coverage : GLboolean
Resolving variable decl GLEW_NV_geometry_program4 : GLboolean
Resolving variable decl GLEW_NV_geometry_shader4 : GLboolean
Resolving variable decl GLEW_NV_gpu_program4 : GLboolean
Resolving variable decl GLEW_NV_half_float : GLboolean
Resolving variable decl GLEW_NV_light_max_exponent : GLboolean
Resolving variable decl GLEW_NV_multisample_filter_hint : GLboolean
Resolving variable decl GLEW_NV_occlusion_query : GLboolean
Resolving variable decl GLEW_NV_packed_depth_stencil : GLboolean
Resolving variable decl GLEW_NV_parameter_buffer_object : GLboolean
Resolving variable decl GLEW_NV_pixel_data_range : GLboolean
Resolving variable decl GLEW_NV_point_sprite : GLboolean
Resolving variable decl GLEW_NV_present_video : GLboolean
Resolving variable decl GLEW_NV_primitive_restart : GLboolean
Resolving variable decl GLEW_NV_register_combiners : GLboolean
Resolving variable decl GLEW_NV_register_combiners2 : GLboolean
Resolving variable decl GLEW_NV_texgen_emboss : GLboolean
Resolving variable decl GLEW_NV_texgen_reflection : GLboolean
Resolving variable decl GLEW_NV_texture_compression_vtc : GLboolean
Resolving variable decl GLEW_NV_texture_env_combine4 : GLboolean
Resolving variable decl GLEW_NV_texture_expand_normal : GLboolean
Resolving variable decl GLEW_NV_texture_rectangle : GLboolean
Resolving variable decl GLEW_NV_texture_shader : GLboolean
Resolving variable decl GLEW_NV_texture_shader2 : GLboolean
Resolving variable decl GLEW_NV_texture_shader3 : GLboolean
Resolving variable decl GLEW_NV_transform_feedback : GLboolean
Resolving variable decl GLEW_NV_vertex_array_range : GLboolean
Resolving variable decl GLEW_NV_vertex_array_range2 : GLboolean
Resolving variable decl GLEW_NV_vertex_program : GLboolean
Resolving variable decl GLEW_NV_vertex_program1_1 : GLboolean
Resolving variable decl GLEW_NV_vertex_program2 : GLboolean
Resolving variable decl GLEW_NV_vertex_program2_option : GLboolean
Resolving variable decl GLEW_NV_vertex_program3 : GLboolean
Resolving variable decl GLEW_NV_vertex_program4 : GLboolean
Resolving variable decl GLEW_OES_byte_coordinates : GLboolean
Resolving variable decl GLEW_OES_compressed_paletted_texture : GLboolean
Resolving variable decl GLEW_OES_read_format : GLboolean
Resolving variable decl GLEW_OES_single_precision : GLboolean
Resolving variable decl GLEW_OML_interlace : GLboolean
Resolving variable decl GLEW_OML_resample : GLboolean
Resolving variable decl GLEW_OML_subsample : GLboolean
Resolving variable decl GLEW_PGI_misc_hints : GLboolean
Resolving variable decl GLEW_PGI_vertex_hints : GLboolean
Resolving variable decl GLEW_REND_screen_coordinates : GLboolean
Resolving variable decl GLEW_S3_s3tc : GLboolean
Resolving variable decl GLEW_SGIS_color_range : GLboolean
Resolving variable decl GLEW_SGIS_detail_texture : GLboolean
Resolving variable decl GLEW_SGIS_fog_function : GLboolean
Resolving variable decl GLEW_SGIS_generate_mipmap : GLboolean
Resolving variable decl GLEW_SGIS_multisample : GLboolean
Resolving variable decl GLEW_SGIS_pixel_texture : GLboolean
Resolving variable decl GLEW_SGIS_point_line_texgen : GLboolean
Resolving variable decl GLEW_SGIS_sharpen_texture : GLboolean
Resolving variable decl GLEW_SGIS_texture4D : GLboolean
Resolving variable decl GLEW_SGIS_texture_border_clamp : GLboolean
Resolving variable decl GLEW_SGIS_texture_edge_clamp : GLboolean
Resolving variable decl GLEW_SGIS_texture_filter4 : GLboolean
Resolving variable decl GLEW_SGIS_texture_lod : GLboolean
Resolving variable decl GLEW_SGIS_texture_select : GLboolean
Resolving variable decl GLEW_SGIX_async : GLboolean
Resolving variable decl GLEW_SGIX_async_histogram : GLboolean
Resolving variable decl GLEW_SGIX_async_pixel : GLboolean
Resolving variable decl GLEW_SGIX_blend_alpha_minmax : GLboolean
Resolving variable decl GLEW_SGIX_clipmap : GLboolean
Resolving variable decl GLEW_SGIX_convolution_accuracy : GLboolean
Resolving variable decl GLEW_SGIX_depth_texture : GLboolean
Resolving variable decl GLEW_SGIX_flush_raster : GLboolean
Resolving variable decl GLEW_SGIX_fog_offset : GLboolean
Resolving variable decl GLEW_SGIX_fog_texture : GLboolean
Resolving variable decl GLEW_SGIX_fragment_specular_lighting : GLboolean
Resolving variable decl GLEW_SGIX_framezoom : GLboolean
Resolving variable decl GLEW_SGIX_interlace : GLboolean
Resolving variable decl GLEW_SGIX_ir_instrument1 : GLboolean
Resolving variable decl GLEW_SGIX_list_priority : GLboolean
Resolving variable decl GLEW_SGIX_pixel_texture : GLboolean
Resolving variable decl GLEW_SGIX_pixel_texture_bits : GLboolean
Resolving variable decl GLEW_SGIX_reference_plane : GLboolean
Resolving variable decl GLEW_SGIX_resample : GLboolean
Resolving variable decl GLEW_SGIX_shadow : GLboolean
Resolving variable decl GLEW_SGIX_shadow_ambient : GLboolean
Resolving variable decl GLEW_SGIX_sprite : GLboolean
Resolving variable decl GLEW_SGIX_tag_sample_buffer : GLboolean
Resolving variable decl GLEW_SGIX_texture_add_env : GLboolean
Resolving variable decl GLEW_SGIX_texture_coordinate_clamp : GLboolean
Resolving variable decl GLEW_SGIX_texture_lod_bias : GLboolean
Resolving variable decl GLEW_SGIX_texture_multi_buffer : GLboolean
Resolving variable decl GLEW_SGIX_texture_range : GLboolean
Resolving variable decl GLEW_SGIX_texture_scale_bias : GLboolean
Resolving variable decl GLEW_SGIX_vertex_preclip : GLboolean
Resolving variable decl GLEW_SGIX_vertex_preclip_hint : GLboolean
Resolving variable decl GLEW_SGIX_ycrcb : GLboolean
Resolving variable decl GLEW_SGI_color_matrix : GLboolean
Resolving variable decl GLEW_SGI_color_table : GLboolean
Resolving variable decl GLEW_SGI_texture_color_table : GLboolean
Resolving variable decl GLEW_SUNX_constant_data : GLboolean
Resolving variable decl GLEW_SUN_convolution_border_modes : GLboolean
Resolving variable decl GLEW_SUN_global_alpha : GLboolean
Resolving variable decl GLEW_SUN_mesh_array : GLboolean
Resolving variable decl GLEW_SUN_read_video_pixels : GLboolean
Resolving variable decl GLEW_SUN_slice_accum : GLboolean
Resolving variable decl GLEW_SUN_triangle_list : GLboolean
Resolving variable decl GLEW_SUN_vertex : GLboolean
Resolving variable decl GLEW_VERSION_1_1 : GLboolean
Resolving variable decl GLEW_VERSION_1_2 : GLboolean
Resolving variable decl GLEW_VERSION_1_3 : GLboolean
Resolving variable decl GLEW_VERSION_1_4 : GLboolean
Resolving variable decl GLEW_VERSION_1_5 : GLboolean
Resolving variable decl GLEW_VERSION_2_0 : GLboolean
Resolving variable decl GLEW_VERSION_2_1 : GLboolean
Resolving variable decl GLEW_VERSION_3_0 : GLboolean
Resolving variable decl GLEW_WIN_phong_shading : GLboolean
Resolving variable decl GLEW_WIN_specular_fog : GLboolean
Resolving variable decl GLEW_WIN_swap_hint : GLboolean
Resolving variable decl GL_1PASS_EXT : GLenum
Resolving variable decl GL_1PASS_SGIS : GLenum
Resolving variable decl GL_2D : GLenum
Resolving variable decl GL_2PASS_0_EXT : GLenum
Resolving variable decl GL_2PASS_0_SGIS : GLenum
Resolving variable decl GL_2PASS_1_EXT : GLenum
Resolving variable decl GL_2PASS_1_SGIS : GLenum
Resolving variable decl GL_2X_BIT_ATI : GLenum
Resolving variable decl GL_2_BYTES : GLenum
Resolving variable decl GL_3D : GLenum
Resolving variable decl GL_3D_COLOR : GLenum
Resolving variable decl GL_3D_COLOR_TEXTURE : GLenum
Resolving variable decl GL_3_BYTES : GLenum
Resolving variable decl GL_422_AVERAGE_EXT : GLenum
Resolving variable decl GL_422_EXT : GLenum
Resolving variable decl GL_422_REV_AVERAGE_EXT : GLenum
Resolving variable decl GL_422_REV_EXT : GLenum
Resolving variable decl GL_4D_COLOR_TEXTURE : GLenum
Resolving variable decl GL_4PASS_0_EXT : GLenum
Resolving variable decl GL_4PASS_0_SGIS : GLenum
Resolving variable decl GL_4PASS_1_EXT : GLenum
Resolving variable decl GL_4PASS_1_SGIS : GLenum
Resolving variable decl GL_4PASS_2_EXT : GLenum
Resolving variable decl GL_4PASS_2_SGIS : GLenum
Resolving variable decl GL_4PASS_3_EXT : GLenum
Resolving variable decl GL_4PASS_3_SGIS : GLenum
Resolving variable decl GL_4X_BIT_ATI : GLenum
Resolving variable decl GL_4_BYTES : GLenum
Resolving variable decl GL_8X_BIT_ATI : GLenum
Resolving variable decl GL_ABGR_EXT : GLenum
Resolving variable decl GL_ACCUM : GLenum
Resolving variable decl GL_ACCUM_ALPHA_BITS : GLenum
Resolving variable decl GL_ACCUM_BLUE_BITS : GLenum
Resolving variable decl GL_ACCUM_BUFFER_BIT : GLenum
Resolving variable decl GL_ACCUM_CLEAR_VALUE : GLenum
Resolving variable decl GL_ACCUM_GREEN_BITS : GLenum
Resolving variable decl GL_ACCUM_RED_BITS : GLenum
Resolving variable decl GL_ACTIVE_ATTRIBUTES : GLenum
Resolving variable decl GL_ACTIVE_ATTRIBUTE_MAX_LENGTH : GLenum
Resolving variable decl GL_ACTIVE_STENCIL_FACE_EXT : GLenum
Resolving variable decl GL_ACTIVE_TEXTURE : GLenum
Resolving variable decl GL_ACTIVE_TEXTURE_ARB : GLenum
Resolving variable decl GL_ACTIVE_UNIFORMS : GLenum
Resolving variable decl GL_ACTIVE_UNIFORM_MAX_LENGTH : GLenum
Resolving variable decl GL_ACTIVE_VARYINGS_NV : GLenum
Resolving variable decl GL_ACTIVE_VARYING_MAX_LENGTH_NV : GLenum
Resolving variable decl GL_ACTIVE_VERTEX_UNITS_ARB : GLenum
Resolving variable decl GL_ADD : GLenum
Resolving variable decl GL_ADD_ATI : GLenum
Resolving variable decl GL_ADD_SIGNED : GLenum
Resolving variable decl GL_ADD_SIGNED_ARB : GLenum
Resolving variable decl GL_ADD_SIGNED_EXT : GLenum
Resolving variable decl GL_ALIASED_LINE_WIDTH_RANGE : GLenum
Resolving variable decl GL_ALIASED_POINT_SIZE_RANGE : GLenum
Resolving variable decl GL_ALLOW_DRAW_FRG_HINT_PGI : GLenum
Resolving variable decl GL_ALLOW_DRAW_MEM_HINT_PGI : GLenum
Resolving variable decl GL_ALLOW_DRAW_OBJ_HINT_PGI : GLenum
Resolving variable decl GL_ALLOW_DRAW_WIN_HINT_PGI : GLenum
Resolving variable decl GL_ALL_ATTRIB_BITS : GLenum
Resolving variable decl GL_ALL_COMPLETED_NV : GLenum
Resolving variable decl GL_ALL_STATIC_DATA_IBM : GLenum
Resolving variable decl GL_ALPHA : GLenum
Resolving variable decl GL_ALPHA12 : GLenum
Resolving variable decl GL_ALPHA12_EXT : GLenum
Resolving variable decl GL_ALPHA16 : GLenum
Resolving variable decl GL_ALPHA16F_ARB : GLenum
Resolving variable decl GL_ALPHA16I_EXT : GLenum
Resolving variable decl GL_ALPHA16UI_EXT : GLenum
Resolving variable decl GL_ALPHA16_EXT : GLenum
Resolving variable decl GL_ALPHA16_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_ALPHA16_SIGNED_SGIX : GLenum
Resolving variable decl GL_ALPHA32F_ARB : GLenum
Resolving variable decl GL_ALPHA32I_EXT : GLenum
Resolving variable decl GL_ALPHA32UI_EXT : GLenum
Resolving variable decl GL_ALPHA4 : GLenum
Resolving variable decl GL_ALPHA4_EXT : GLenum
Resolving variable decl GL_ALPHA8 : GLenum
Resolving variable decl GL_ALPHA8I_EXT : GLenum
Resolving variable decl GL_ALPHA8UI_EXT : GLenum
Resolving variable decl GL_ALPHA8_EXT : GLenum
Resolving variable decl GL_ALPHA_BIAS : GLenum
Resolving variable decl GL_ALPHA_BITS : GLenum
Resolving variable decl GL_ALPHA_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_ALPHA_FLOAT16_APPLE : GLenum
Resolving variable decl GL_ALPHA_FLOAT16_ATI : GLenum
Resolving variable decl GL_ALPHA_FLOAT32_APPLE : GLenum
Resolving variable decl GL_ALPHA_FLOAT32_ATI : GLenum
Resolving variable decl GL_ALPHA_INTEGER : GLenum
Resolving variable decl GL_ALPHA_INTEGER_EXT : GLenum
Resolving variable decl GL_ALPHA_MAX_CLAMP_INGR : GLenum
Resolving variable decl GL_ALPHA_MAX_SGIX : GLenum
Resolving variable decl GL_ALPHA_MIN_CLAMP_INGR : GLenum
Resolving variable decl GL_ALPHA_MIN_SGIX : GLenum
Resolving variable decl GL_ALPHA_SCALE : GLenum
Resolving variable decl GL_ALPHA_SIGNED_SGIX : GLenum
Resolving variable decl GL_ALPHA_TEST : GLenum
Resolving variable decl GL_ALPHA_TEST_FUNC : GLenum
Resolving variable decl GL_ALPHA_TEST_REF : GLenum
Resolving variable decl GL_ALWAYS : GLenum
Resolving variable decl GL_ALWAYS_FAST_HINT_PGI : GLenum
Resolving variable decl GL_ALWAYS_SOFT_HINT_PGI : GLenum
Resolving variable decl GL_AMBIENT : GLenum
Resolving variable decl GL_AMBIENT_AND_DIFFUSE : GLenum
Resolving variable decl GL_AND : GLenum
Resolving variable decl GL_AND_INVERTED : GLenum
Resolving variable decl GL_AND_REVERSE : GLenum
Resolving variable decl GL_ARRAY_BUFFER : GLenum
Resolving variable decl GL_ARRAY_BUFFER_ARB : GLenum
Resolving variable decl GL_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_ARRAY_ELEMENT_LOCK_COUNT_EXT : GLenum
Resolving variable decl GL_ARRAY_ELEMENT_LOCK_FIRST_EXT : GLenum
Resolving variable decl GL_ARRAY_OBJECT_BUFFER_ATI : GLenum
Resolving variable decl GL_ARRAY_OBJECT_OFFSET_ATI : GLenum
Resolving variable decl GL_ASYNC_DRAW_PIXELS_SGIX : GLenum
Resolving variable decl GL_ASYNC_HISTOGRAM_SGIX : GLenum
Resolving variable decl GL_ASYNC_MARKER_SGIX : GLenum
Resolving variable decl GL_ASYNC_READ_PIXELS_SGIX : GLenum
Resolving variable decl GL_ASYNC_TEX_IMAGE_SGIX : GLenum
Resolving variable decl GL_ATTACHED_SHADERS : GLenum
Resolving variable decl GL_ATTENUATION_EXT : GLenum
Resolving variable decl GL_ATTRIB_ARRAY_POINTER_NV : GLenum
Resolving variable decl GL_ATTRIB_ARRAY_SIZE_NV : GLenum
Resolving variable decl GL_ATTRIB_ARRAY_STRIDE_NV : GLenum
Resolving variable decl GL_ATTRIB_ARRAY_TYPE_NV : GLenum
Resolving variable decl GL_ATTRIB_STACK_DEPTH : GLenum
Resolving variable decl GL_AUTO_NORMAL : GLenum
Resolving variable decl GL_AUX0 : GLenum
Resolving variable decl GL_AUX1 : GLenum
Resolving variable decl GL_AUX2 : GLenum
Resolving variable decl GL_AUX3 : GLenum
Resolving variable decl GL_AUX_BUFFERS : GLenum
Resolving variable decl GL_AVERAGE_EXT : GLenum
Resolving variable decl GL_BACK : GLenum
Resolving variable decl GL_BACK_LEFT : GLenum
Resolving variable decl GL_BACK_NORMALS_HINT_PGI : GLenum
Resolving variable decl GL_BACK_PRIMARY_COLOR_NV : GLenum
Resolving variable decl GL_BACK_RIGHT : GLenum
Resolving variable decl GL_BACK_SECONDARY_COLOR_NV : GLenum
Resolving variable decl GL_BGR : GLenum
Resolving variable decl GL_BGRA : GLenum
Resolving variable decl GL_BGRA_EXT : GLenum
Resolving variable decl GL_BGRA_INTEGER : GLenum
Resolving variable decl GL_BGRA_INTEGER_EXT : GLenum
Resolving variable decl GL_BGR_EXT : GLenum
Resolving variable decl GL_BGR_INTEGER : GLenum
Resolving variable decl GL_BGR_INTEGER_EXT : GLenum
Resolving variable decl GL_BIAS_BIT_ATI : GLenum
Resolving variable decl GL_BIAS_BY_NEGATIVE_ONE_HALF_NV : GLenum
Resolving variable decl GL_BINORMAL_ARRAY_EXT : GLenum
Resolving variable decl GL_BINORMAL_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_BINORMAL_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_BINORMAL_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_BITMAP : GLenum
Resolving variable decl GL_BITMAP_TOKEN : GLenum
Resolving variable decl GL_BLEND : GLenum
Resolving variable decl GL_BLEND_COLOR : GLenum
Resolving variable decl GL_BLEND_COLOR_EXT : GLenum
Resolving variable decl GL_BLEND_DST : GLenum
Resolving variable decl GL_BLEND_DST_ALPHA : GLenum
Resolving variable decl GL_BLEND_DST_ALPHA_EXT : GLenum
Resolving variable decl GL_BLEND_DST_RGB : GLenum
Resolving variable decl GL_BLEND_DST_RGB_EXT : GLenum
Resolving variable decl GL_BLEND_EQUATION : GLenum
Resolving variable decl GL_BLEND_EQUATION_ALPHA : GLenum
Resolving variable decl GL_BLEND_EQUATION_ALPHA_EXT : GLenum
Resolving variable decl GL_BLEND_EQUATION_EXT : GLenum
Resolving variable decl GL_BLEND_EQUATION_RGB : GLenum
Resolving variable decl GL_BLEND_EQUATION_RGB_EXT : GLenum
Resolving variable decl GL_BLEND_SRC : GLenum
Resolving variable decl GL_BLEND_SRC_ALPHA : GLenum
Resolving variable decl GL_BLEND_SRC_ALPHA_EXT : GLenum
Resolving variable decl GL_BLEND_SRC_RGB : GLenum
Resolving variable decl GL_BLEND_SRC_RGB_EXT : GLenum
Resolving variable decl GL_BLUE : GLenum
Resolving variable decl GL_BLUE_BIAS : GLenum
Resolving variable decl GL_BLUE_BITS : GLenum
Resolving variable decl GL_BLUE_BIT_ATI : GLenum
Resolving variable decl GL_BLUE_INTEGER : GLenum
Resolving variable decl GL_BLUE_INTEGER_EXT : GLenum
Resolving variable decl GL_BLUE_MAX_CLAMP_INGR : GLenum
Resolving variable decl GL_BLUE_MIN_CLAMP_INGR : GLenum
Resolving variable decl GL_BLUE_SCALE : GLenum
Resolving variable decl GL_BOOL : GLenum
Resolving variable decl GL_BOOL_ARB : GLenum
Resolving variable decl GL_BOOL_VEC2 : GLenum
Resolving variable decl GL_BOOL_VEC2_ARB : GLenum
Resolving variable decl GL_BOOL_VEC3 : GLenum
Resolving variable decl GL_BOOL_VEC3_ARB : GLenum
Resolving variable decl GL_BOOL_VEC4 : GLenum
Resolving variable decl GL_BOOL_VEC4_ARB : GLenum
Resolving variable decl GL_BUFFER_ACCESS : GLenum
Resolving variable decl GL_BUFFER_ACCESS_ARB : GLenum
Resolving variable decl GL_BUFFER_FLUSHING_UNMAP_APPLE : GLenum
Resolving variable decl GL_BUFFER_MAPPED : GLenum
Resolving variable decl GL_BUFFER_MAPPED_ARB : GLenum
Resolving variable decl GL_BUFFER_MAP_POINTER : GLenum
Resolving variable decl GL_BUFFER_MAP_POINTER_ARB : GLenum
Resolving variable decl GL_BUFFER_SERIALIZED_MODIFY_APPLE : GLenum
Resolving variable decl GL_BUFFER_SIZE : GLenum
Resolving variable decl GL_BUFFER_SIZE_ARB : GLenum
Resolving variable decl GL_BUFFER_USAGE : GLenum
Resolving variable decl GL_BUFFER_USAGE_ARB : GLenum
Resolving variable decl GL_BUMP_ENVMAP_ATI : GLenum
Resolving variable decl GL_BUMP_NUM_TEX_UNITS_ATI : GLenum
Resolving variable decl GL_BUMP_ROT_MATRIX_ATI : GLenum
Resolving variable decl GL_BUMP_ROT_MATRIX_SIZE_ATI : GLenum
Resolving variable decl GL_BUMP_TARGET_ATI : GLenum
Resolving variable decl GL_BUMP_TEX_UNITS_ATI : GLenum
Resolving variable decl GL_BYTE : GLenum
Resolving variable decl GL_C3F_V3F : GLenum
Resolving variable decl GL_C4F_N3F_V3F : GLenum
Resolving variable decl GL_C4UB_V2F : GLenum
Resolving variable decl GL_C4UB_V3F : GLenum
Resolving variable decl GL_CCW : GLenum
Resolving variable decl GL_CG_FRAGMENT_SHADER_EXT : GLenum
Resolving variable decl GL_CG_VERTEX_SHADER_EXT : GLenum
Resolving variable decl GL_CLAMP : GLenum
Resolving variable decl GL_CLAMP_FRAGMENT_COLOR : GLenum
Resolving variable decl GL_CLAMP_FRAGMENT_COLOR_ARB : GLenum
Resolving variable decl GL_CLAMP_READ_COLOR : GLenum
Resolving variable decl GL_CLAMP_READ_COLOR_ARB : GLenum
Resolving variable decl GL_CLAMP_TO_BORDER : GLenum
Resolving variable decl GL_CLAMP_TO_BORDER_ARB : GLenum
Resolving variable decl GL_CLAMP_TO_BORDER_SGIS : GLenum
Resolving variable decl GL_CLAMP_TO_EDGE : GLenum
Resolving variable decl GL_CLAMP_TO_EDGE_EXT : GLenum
Resolving variable decl GL_CLAMP_TO_EDGE_SGIS : GLenum
Resolving variable decl GL_CLAMP_VERTEX_COLOR : GLenum
Resolving variable decl GL_CLAMP_VERTEX_COLOR_ARB : GLenum
Resolving variable decl GL_CLEAR : GLenum
Resolving variable decl GL_CLIENT_ACTIVE_TEXTURE : GLenum
Resolving variable decl GL_CLIENT_ACTIVE_TEXTURE_ARB : GLenum
Resolving variable decl GL_CLIENT_ALL_ATTRIB_BITS : GLenum
Resolving variable decl GL_CLIENT_ATTRIB_STACK_DEPTH : GLenum
Resolving variable decl GL_CLIENT_PIXEL_STORE_BIT : GLenum
Resolving variable decl GL_CLIENT_VERTEX_ARRAY_BIT : GLenum
Resolving variable decl GL_CLIP_DISTANCE0 : GLenum
Resolving variable decl GL_CLIP_DISTANCE1 : GLenum
Resolving variable decl GL_CLIP_DISTANCE2 : GLenum
Resolving variable decl GL_CLIP_DISTANCE3 : GLenum
Resolving variable decl GL_CLIP_DISTANCE4 : GLenum
Resolving variable decl GL_CLIP_DISTANCE5 : GLenum
Resolving variable decl GL_CLIP_DISTANCE_NV : GLenum
Resolving variable decl GL_CLIP_FAR_HINT_PGI : GLenum
Resolving variable decl GL_CLIP_NEAR_HINT_PGI : GLenum
Resolving variable decl GL_CLIP_PLANE0 : GLenum
Resolving variable decl GL_CLIP_PLANE1 : GLenum
Resolving variable decl GL_CLIP_PLANE2 : GLenum
Resolving variable decl GL_CLIP_PLANE3 : GLenum
Resolving variable decl GL_CLIP_PLANE4 : GLenum
Resolving variable decl GL_CLIP_PLANE5 : GLenum
Resolving variable decl GL_CLIP_VOLUME_CLIPPING_HINT_EXT : GLenum
Resolving variable decl GL_CMYKA_EXT : GLenum
Resolving variable decl GL_CMYK_EXT : GLenum
Resolving variable decl GL_CND0_ATI : GLenum
Resolving variable decl GL_CND_ATI : GLenum
Resolving variable decl GL_COEFF : GLenum
Resolving variable decl GL_COLOR : GLenum
Resolving variable decl GL_COLOR3_BIT_PGI : GLenum
Resolving variable decl GL_COLOR4_BIT_PGI : GLenum
Resolving variable decl GL_COLOR_ALPHA_PAIRING_ATI : GLenum
Resolving variable decl GL_COLOR_ARRAY : GLenum
Resolving variable decl GL_COLOR_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_COLOR_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_COLOR_ARRAY_COUNT_EXT : GLenum
Resolving variable decl GL_COLOR_ARRAY_EXT : GLenum
Resolving variable decl GL_COLOR_ARRAY_LIST_IBM : GLenum
Resolving variable decl GL_COLOR_ARRAY_LIST_STRIDE_IBM : GLenum
Resolving variable decl GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL : GLenum
Resolving variable decl GL_COLOR_ARRAY_POINTER : GLenum
Resolving variable decl GL_COLOR_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_COLOR_ARRAY_SIZE : GLenum
Resolving variable decl GL_COLOR_ARRAY_SIZE_EXT : GLenum
Resolving variable decl GL_COLOR_ARRAY_STRIDE : GLenum
Resolving variable decl GL_COLOR_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_COLOR_ARRAY_TYPE : GLenum
Resolving variable decl GL_COLOR_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT0 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT0_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT1 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT10 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT10_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT11 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT11_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT12 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT12_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT13 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT13_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT14 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT14_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT15 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT15_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT1_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT2 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT2_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT3 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT3_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT4 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT4_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT5 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT5_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT6 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT6_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT7 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT7_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT8 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT8_EXT : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT9 : GLenum
Resolving variable decl GL_COLOR_ATTACHMENT9_EXT : GLenum
Resolving variable decl GL_COLOR_BUFFER_BIT : GLenum
Resolving variable decl GL_COLOR_CLEAR_VALUE : GLenum
Resolving variable decl GL_COLOR_FLOAT_APPLE : GLenum
Resolving variable decl GL_COLOR_INDEX : GLenum
Resolving variable decl GL_COLOR_INDEX12_EXT : GLenum
Resolving variable decl GL_COLOR_INDEX16_EXT : GLenum
Resolving variable decl GL_COLOR_INDEX1_EXT : GLenum
Resolving variable decl GL_COLOR_INDEX2_EXT : GLenum
Resolving variable decl GL_COLOR_INDEX4_EXT : GLenum
Resolving variable decl GL_COLOR_INDEX8_EXT : GLenum
Resolving variable decl GL_COLOR_INDEXES : GLenum
Resolving variable decl GL_COLOR_LOGIC_OP : GLenum
Resolving variable decl GL_COLOR_MATERIAL : GLenum
Resolving variable decl GL_COLOR_MATERIAL_FACE : GLenum
Resolving variable decl GL_COLOR_MATERIAL_PARAMETER : GLenum
Resolving variable decl GL_COLOR_MATRIX : GLenum
Resolving variable decl GL_COLOR_MATRIX_SGI : GLenum
Resolving variable decl GL_COLOR_MATRIX_STACK_DEPTH : GLenum
Resolving variable decl GL_COLOR_MATRIX_STACK_DEPTH_SGI : GLenum
Resolving variable decl GL_COLOR_SUM : GLenum
Resolving variable decl GL_COLOR_SUM_ARB : GLenum
Resolving variable decl GL_COLOR_SUM_CLAMP_NV : GLenum
Resolving variable decl GL_COLOR_SUM_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE : GLenum
Resolving variable decl GL_COLOR_TABLE_ALPHA_SIZE : GLenum
Resolving variable decl GL_COLOR_TABLE_ALPHA_SIZE_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE_ALPHA_SIZE_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_BIAS : GLenum
Resolving variable decl GL_COLOR_TABLE_BIAS_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_BLUE_SIZE : GLenum
Resolving variable decl GL_COLOR_TABLE_BLUE_SIZE_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE_BLUE_SIZE_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_FORMAT : GLenum
Resolving variable decl GL_COLOR_TABLE_FORMAT_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE_FORMAT_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_GREEN_SIZE : GLenum
Resolving variable decl GL_COLOR_TABLE_GREEN_SIZE_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE_GREEN_SIZE_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_INTENSITY_SIZE : GLenum
Resolving variable decl GL_COLOR_TABLE_INTENSITY_SIZE_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE_INTENSITY_SIZE_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_LUMINANCE_SIZE : GLenum
Resolving variable decl GL_COLOR_TABLE_LUMINANCE_SIZE_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE_LUMINANCE_SIZE_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_RED_SIZE : GLenum
Resolving variable decl GL_COLOR_TABLE_RED_SIZE_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE_RED_SIZE_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_SCALE : GLenum
Resolving variable decl GL_COLOR_TABLE_SCALE_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_SGI : GLenum
Resolving variable decl GL_COLOR_TABLE_WIDTH : GLenum
Resolving variable decl GL_COLOR_TABLE_WIDTH_EXT : GLenum
Resolving variable decl GL_COLOR_TABLE_WIDTH_SGI : GLenum
Resolving variable decl GL_COLOR_WRITEMASK : GLenum
Resolving variable decl GL_COMBINE : GLenum
Resolving variable decl GL_COMBINE4_NV : GLenum
Resolving variable decl GL_COMBINER0_NV : GLenum
Resolving variable decl GL_COMBINER1_NV : GLenum
Resolving variable decl GL_COMBINER2_NV : GLenum
Resolving variable decl GL_COMBINER3_NV : GLenum
Resolving variable decl GL_COMBINER4_NV : GLenum
Resolving variable decl GL_COMBINER5_NV : GLenum
Resolving variable decl GL_COMBINER6_NV : GLenum
Resolving variable decl GL_COMBINER7_NV : GLenum
Resolving variable decl GL_COMBINER_AB_DOT_PRODUCT_NV : GLenum
Resolving variable decl GL_COMBINER_AB_OUTPUT_NV : GLenum
Resolving variable decl GL_COMBINER_BIAS_NV : GLenum
Resolving variable decl GL_COMBINER_CD_DOT_PRODUCT_NV : GLenum
Resolving variable decl GL_COMBINER_CD_OUTPUT_NV : GLenum
Resolving variable decl GL_COMBINER_COMPONENT_USAGE_NV : GLenum
Resolving variable decl GL_COMBINER_INPUT_NV : GLenum
Resolving variable decl GL_COMBINER_MAPPING_NV : GLenum
Resolving variable decl GL_COMBINER_MUX_SUM_NV : GLenum
Resolving variable decl GL_COMBINER_SCALE_NV : GLenum
Resolving variable decl GL_COMBINER_SUM_OUTPUT_NV : GLenum
Resolving variable decl GL_COMBINE_ALPHA : GLenum
Resolving variable decl GL_COMBINE_ALPHA_ARB : GLenum
Resolving variable decl GL_COMBINE_ALPHA_EXT : GLenum
Resolving variable decl GL_COMBINE_ARB : GLenum
Resolving variable decl GL_COMBINE_EXT : GLenum
Resolving variable decl GL_COMBINE_RGB : GLenum
Resolving variable decl GL_COMBINE_RGB_ARB : GLenum
Resolving variable decl GL_COMBINE_RGB_EXT : GLenum
Resolving variable decl GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT : GLenum
Resolving variable decl GL_COMPARE_REF_TO_TEXTURE : GLenum
Resolving variable decl GL_COMPARE_R_TO_TEXTURE : GLenum
Resolving variable decl GL_COMPARE_R_TO_TEXTURE_ARB : GLenum
Resolving variable decl GL_COMPILE : GLenum
Resolving variable decl GL_COMPILE_AND_EXECUTE : GLenum
Resolving variable decl GL_COMPILE_STATUS : GLenum
Resolving variable decl GL_COMPRESSED_ALPHA : GLenum
Resolving variable decl GL_COMPRESSED_ALPHA_ARB : GLenum
Resolving variable decl GL_COMPRESSED_INTENSITY : GLenum
Resolving variable decl GL_COMPRESSED_INTENSITY_ARB : GLenum
Resolving variable decl GL_COMPRESSED_LUMINANCE : GLenum
Resolving variable decl GL_COMPRESSED_LUMINANCE_ALPHA : GLenum
Resolving variable decl GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI : GLenum
Resolving variable decl GL_COMPRESSED_LUMINANCE_ALPHA_ARB : GLenum
Resolving variable decl GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT : GLenum
Resolving variable decl GL_COMPRESSED_LUMINANCE_ARB : GLenum
Resolving variable decl GL_COMPRESSED_LUMINANCE_LATC1_EXT : GLenum
Resolving variable decl GL_COMPRESSED_RED : GLenum
Resolving variable decl GL_COMPRESSED_RED_GREEN_RGTC2_EXT : GLenum
Resolving variable decl GL_COMPRESSED_RED_RGTC1 : GLenum
Resolving variable decl GL_COMPRESSED_RED_RGTC1_EXT : GLenum
Resolving variable decl GL_COMPRESSED_RG : GLenum
Resolving variable decl GL_COMPRESSED_RGB : GLenum
Resolving variable decl GL_COMPRESSED_RGBA : GLenum
Resolving variable decl GL_COMPRESSED_RGBA_ARB : GLenum
Resolving variable decl GL_COMPRESSED_RGBA_FXT1_3DFX : GLenum
Resolving variable decl GL_COMPRESSED_RGBA_S3TC_DXT1_EXT : GLenum
Resolving variable decl GL_COMPRESSED_RGBA_S3TC_DXT3_EXT : GLenum
Resolving variable decl GL_COMPRESSED_RGBA_S3TC_DXT5_EXT : GLenum
Resolving variable decl GL_COMPRESSED_RGB_ARB : GLenum
Resolving variable decl GL_COMPRESSED_RGB_FXT1_3DFX : GLenum
Resolving variable decl GL_COMPRESSED_RGB_S3TC_DXT1_EXT : GLenum
Resolving variable decl GL_COMPRESSED_RG_RGTC2 : GLenum
Resolving variable decl GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SIGNED_RED_RGTC1 : GLenum
Resolving variable decl GL_COMPRESSED_SIGNED_RED_RGTC1_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SIGNED_RG_RGTC2 : GLenum
Resolving variable decl GL_COMPRESSED_SLUMINANCE : GLenum
Resolving variable decl GL_COMPRESSED_SLUMINANCE_ALPHA : GLenum
Resolving variable decl GL_COMPRESSED_SLUMINANCE_ALPHA_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SLUMINANCE_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SRGB : GLenum
Resolving variable decl GL_COMPRESSED_SRGB_ALPHA : GLenum
Resolving variable decl GL_COMPRESSED_SRGB_ALPHA_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SRGB_EXT : GLenum
Resolving variable decl GL_COMPRESSED_SRGB_S3TC_DXT1_EXT : GLenum
Resolving variable decl GL_COMPRESSED_TEXTURE_FORMATS : GLenum
Resolving variable decl GL_COMPRESSED_TEXTURE_FORMATS_ARB : GLenum
Resolving variable decl GL_COMP_BIT_ATI : GLenum
Resolving variable decl GL_CONSERVE_MEMORY_HINT_PGI : GLenum
Resolving variable decl GL_CONSTANT : GLenum
Resolving variable decl GL_CONSTANT_ALPHA : GLenum
Resolving variable decl GL_CONSTANT_ALPHA_EXT : GLenum
Resolving variable decl GL_CONSTANT_ARB : GLenum
Resolving variable decl GL_CONSTANT_ATTENUATION : GLenum
Resolving variable decl GL_CONSTANT_BORDER : GLenum
Resolving variable decl GL_CONSTANT_COLOR : GLenum
Resolving variable decl GL_CONSTANT_COLOR0_NV : GLenum
Resolving variable decl GL_CONSTANT_COLOR1_NV : GLenum
Resolving variable decl GL_CONSTANT_COLOR_EXT : GLenum
Resolving variable decl GL_CONSTANT_EXT : GLenum
Resolving variable decl GL_CONST_EYE_NV : GLenum
Resolving variable decl GL_CONTEXT_FLAGS : GLenum
Resolving variable decl GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT : GLenum
Resolving variable decl GL_CONVOLUTION_1D : GLenum
Resolving variable decl GL_CONVOLUTION_1D_EXT : GLenum
Resolving variable decl GL_CONVOLUTION_2D : GLenum
Resolving variable decl GL_CONVOLUTION_2D_EXT : GLenum
Resolving variable decl GL_CONVOLUTION_BORDER_COLOR : GLenum
Resolving variable decl GL_CONVOLUTION_BORDER_MODE : GLenum
Resolving variable decl GL_CONVOLUTION_BORDER_MODE_EXT : GLenum
Resolving variable decl GL_CONVOLUTION_FILTER_BIAS : GLenum
Resolving variable decl GL_CONVOLUTION_FILTER_BIAS_EXT : GLenum
Resolving variable decl GL_CONVOLUTION_FILTER_SCALE : GLenum
Resolving variable decl GL_CONVOLUTION_FILTER_SCALE_EXT : GLenum
Resolving variable decl GL_CONVOLUTION_FORMAT : GLenum
Resolving variable decl GL_CONVOLUTION_FORMAT_EXT : GLenum
Resolving variable decl GL_CONVOLUTION_HEIGHT : GLenum
Resolving variable decl GL_CONVOLUTION_HEIGHT_EXT : GLenum
Resolving variable decl GL_CONVOLUTION_HINT_SGIX : GLenum
Resolving variable decl GL_CONVOLUTION_WIDTH : GLenum
Resolving variable decl GL_CONVOLUTION_WIDTH_EXT : GLenum
Resolving variable decl GL_CON_0_ATI : GLenum
Resolving variable decl GL_CON_1_ATI : GLenum
Resolving variable decl GL_CON_2_ATI : GLenum
Resolving variable decl GL_CON_3_ATI : GLenum
Resolving variable decl GL_CON_4_ATI : GLenum
Resolving variable decl GL_CON_5_ATI : GLenum
Resolving variable decl GL_CON_6_ATI : GLenum
Resolving variable decl GL_CON_7_ATI : GLenum
Resolving variable decl GL_COORD_REPLACE : GLenum
Resolving variable decl GL_COORD_REPLACE_ARB : GLenum
Resolving variable decl GL_COORD_REPLACE_NV : GLenum
Resolving variable decl GL_COPY : GLenum
Resolving variable decl GL_COPY_INVERTED : GLenum
Resolving variable decl GL_COPY_PIXEL_TOKEN : GLenum
Resolving variable decl GL_CUBIC_EXT : GLenum
Resolving variable decl GL_CULL_FACE : GLenum
Resolving variable decl GL_CULL_FACE_MODE : GLenum
Resolving variable decl GL_CULL_FRAGMENT_NV : GLenum
Resolving variable decl GL_CULL_MODES_NV : GLenum
Resolving variable decl GL_CULL_VERTEX_IBM : GLenum
Resolving variable decl GL_CURRENT_ATTRIB_NV : GLenum
Resolving variable decl GL_CURRENT_BINORMAL_EXT : GLenum
Resolving variable decl GL_CURRENT_BIT : GLenum
Resolving variable decl GL_CURRENT_COLOR : GLenum
Resolving variable decl GL_CURRENT_FOG_COORD : GLenum
Resolving variable decl GL_CURRENT_FOG_COORDINATE : GLenum
Resolving variable decl GL_CURRENT_FOG_COORDINATE_EXT : GLenum
Resolving variable decl GL_CURRENT_INDEX : GLenum
Resolving variable decl GL_CURRENT_MATRIX_ARB : GLenum
Resolving variable decl GL_CURRENT_MATRIX_INDEX_ARB : GLenum
Resolving variable decl GL_CURRENT_MATRIX_NV : GLenum
Resolving variable decl GL_CURRENT_MATRIX_STACK_DEPTH_ARB : GLenum
Resolving variable decl GL_CURRENT_MATRIX_STACK_DEPTH_NV : GLenum
Resolving variable decl GL_CURRENT_NORMAL : GLenum
Resolving variable decl GL_CURRENT_OCCLUSION_QUERY_ID_NV : GLenum
Resolving variable decl GL_CURRENT_PALETTE_MATRIX_ARB : GLenum
Resolving variable decl GL_CURRENT_PROGRAM : GLenum
Resolving variable decl GL_CURRENT_QUERY : GLenum
Resolving variable decl GL_CURRENT_QUERY_ARB : GLenum
Resolving variable decl GL_CURRENT_RASTER_COLOR : GLenum
Resolving variable decl GL_CURRENT_RASTER_DISTANCE : GLenum
Resolving variable decl GL_CURRENT_RASTER_INDEX : GLenum
Resolving variable decl GL_CURRENT_RASTER_NORMAL_EXT : GLenum
Resolving variable decl GL_CURRENT_RASTER_POSITION : GLenum
Resolving variable decl GL_CURRENT_RASTER_POSITION_VALID : GLenum
Resolving variable decl GL_CURRENT_RASTER_SECONDARY_COLOR : GLenum
Resolving variable decl GL_CURRENT_RASTER_TEXTURE_COORDS : GLenum
Resolving variable decl GL_CURRENT_SAMPLE_COUNT_QUERY_NV : GLenum
Resolving variable decl GL_CURRENT_SECONDARY_COLOR : GLenum
Resolving variable decl GL_CURRENT_SECONDARY_COLOR_EXT : GLenum
Resolving variable decl GL_CURRENT_TANGENT_EXT : GLenum
Resolving variable decl GL_CURRENT_TEXTURE_COORDS : GLenum
Resolving variable decl GL_CURRENT_TIME_NV : GLenum
Resolving variable decl GL_CURRENT_VERTEX_ATTRIB : GLenum
Resolving variable decl GL_CURRENT_VERTEX_ATTRIB_ARB : GLenum
Resolving variable decl GL_CURRENT_VERTEX_EXT : GLenum
Resolving variable decl GL_CURRENT_VERTEX_WEIGHT_EXT : GLenum
Resolving variable decl GL_CURRENT_WEIGHT_ARB : GLenum
Resolving variable decl GL_CW : GLenum
Resolving variable decl GL_DECAL : GLenum
Resolving variable decl GL_DECR : GLenum
Resolving variable decl GL_DECR_WRAP : GLenum
Resolving variable decl GL_DECR_WRAP_EXT : GLenum
Resolving variable decl GL_DELETE_STATUS : GLenum
Resolving variable decl GL_DEPENDENT_AR_TEXTURE_2D_NV : GLenum
Resolving variable decl GL_DEPENDENT_GB_TEXTURE_2D_NV : GLenum
Resolving variable decl GL_DEPENDENT_HILO_TEXTURE_2D_NV : GLenum
Resolving variable decl GL_DEPENDENT_RGB_TEXTURE_3D_NV : GLenum
Resolving variable decl GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV : GLenum
Resolving variable decl GL_DEPTH : GLenum
Resolving variable decl GL_DEPTH24_STENCIL8 : GLenum
Resolving variable decl GL_DEPTH24_STENCIL8_EXT : GLenum
Resolving variable decl GL_DEPTH32F_STENCIL8 : GLenum
Resolving variable decl GL_DEPTH32F_STENCIL8_NV : GLenum
Resolving variable decl GL_DEPTH_ATTACHMENT : GLenum
Resolving variable decl GL_DEPTH_ATTACHMENT_EXT : GLenum
Resolving variable decl GL_DEPTH_BIAS : GLenum
Resolving variable decl GL_DEPTH_BITS : GLenum
Resolving variable decl GL_DEPTH_BOUNDS_EXT : GLenum
Resolving variable decl GL_DEPTH_BOUNDS_TEST_EXT : GLenum
Resolving variable decl GL_DEPTH_BUFFER : GLenum
Resolving variable decl GL_DEPTH_BUFFER_BIT : GLenum
Resolving variable decl GL_DEPTH_BUFFER_FLOAT_MODE_NV : GLenum
Resolving variable decl GL_DEPTH_CLAMP_NV : GLenum
Resolving variable decl GL_DEPTH_CLEAR_VALUE : GLenum
Resolving variable decl GL_DEPTH_COMPONENT : GLenum
Resolving variable decl GL_DEPTH_COMPONENT16 : GLenum
Resolving variable decl GL_DEPTH_COMPONENT16_ARB : GLenum
Resolving variable decl GL_DEPTH_COMPONENT16_SGIX : GLenum
Resolving variable decl GL_DEPTH_COMPONENT24 : GLenum
Resolving variable decl GL_DEPTH_COMPONENT24_ARB : GLenum
Resolving variable decl GL_DEPTH_COMPONENT24_SGIX : GLenum
Resolving variable decl GL_DEPTH_COMPONENT32 : GLenum
Resolving variable decl GL_DEPTH_COMPONENT32F : GLenum
Resolving variable decl GL_DEPTH_COMPONENT32F_NV : GLenum
Resolving variable decl GL_DEPTH_COMPONENT32_ARB : GLenum
Resolving variable decl GL_DEPTH_COMPONENT32_SGIX : GLenum
Resolving variable decl GL_DEPTH_FUNC : GLenum
Resolving variable decl GL_DEPTH_RANGE : GLenum
Resolving variable decl GL_DEPTH_SCALE : GLenum
Resolving variable decl GL_DEPTH_STENCIL : GLenum
Resolving variable decl GL_DEPTH_STENCIL_ATTACHMENT : GLenum
Resolving variable decl GL_DEPTH_STENCIL_EXT : GLenum
Resolving variable decl GL_DEPTH_STENCIL_NV : GLenum
Resolving variable decl GL_DEPTH_STENCIL_TO_BGRA_NV : GLenum
Resolving variable decl GL_DEPTH_STENCIL_TO_RGBA_NV : GLenum
Resolving variable decl GL_DEPTH_TEST : GLenum
Resolving variable decl GL_DEPTH_TEXTURE_MODE : GLenum
Resolving variable decl GL_DEPTH_TEXTURE_MODE_ARB : GLenum
Resolving variable decl GL_DEPTH_WRITEMASK : GLenum
Resolving variable decl GL_DIFFUSE : GLenum
Resolving variable decl GL_DISCARD_ATI : GLenum
Resolving variable decl GL_DISCARD_NV : GLenum
Resolving variable decl GL_DISTANCE_ATTENUATION_EXT : GLenum
Resolving variable decl GL_DITHER : GLenum
Resolving variable decl GL_DOMAIN : GLenum
Resolving variable decl GL_DONT_CARE : GLenum
Resolving variable decl GL_DOT2_ADD_ATI : GLenum
Resolving variable decl GL_DOT3_ATI : GLenum
Resolving variable decl GL_DOT3_RGB : GLenum
Resolving variable decl GL_DOT3_RGBA : GLenum
Resolving variable decl GL_DOT3_RGBA_ARB : GLenum
Resolving variable decl GL_DOT3_RGBA_EXT : GLenum
Resolving variable decl GL_DOT3_RGB_ARB : GLenum
Resolving variable decl GL_DOT3_RGB_EXT : GLenum
Resolving variable decl GL_DOT4_ATI : GLenum
Resolving variable decl GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_DEPTH_REPLACE_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_PASS_THROUGH_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_TEXTURE_1D_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_TEXTURE_2D_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_TEXTURE_3D_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV : GLenum
Resolving variable decl GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV : GLenum
Resolving variable decl GL_DOUBLE : GLenum
Resolving variable decl GL_DOUBLEBUFFER : GLenum
Resolving variable decl GL_DOUBLE_EXT : GLenum
Resolving variable decl GL_DRAW_BUFFER : GLenum
Resolving variable decl GL_DRAW_BUFFER0 : GLenum
Resolving variable decl GL_DRAW_BUFFER0_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER0_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER1 : GLenum
Resolving variable decl GL_DRAW_BUFFER10 : GLenum
Resolving variable decl GL_DRAW_BUFFER10_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER10_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER11 : GLenum
Resolving variable decl GL_DRAW_BUFFER11_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER11_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER12 : GLenum
Resolving variable decl GL_DRAW_BUFFER12_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER12_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER13 : GLenum
Resolving variable decl GL_DRAW_BUFFER13_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER13_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER14 : GLenum
Resolving variable decl GL_DRAW_BUFFER14_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER14_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER15 : GLenum
Resolving variable decl GL_DRAW_BUFFER15_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER15_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER1_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER1_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER2 : GLenum
Resolving variable decl GL_DRAW_BUFFER2_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER2_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER3 : GLenum
Resolving variable decl GL_DRAW_BUFFER3_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER3_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER4 : GLenum
Resolving variable decl GL_DRAW_BUFFER4_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER4_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER5 : GLenum
Resolving variable decl GL_DRAW_BUFFER5_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER5_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER6 : GLenum
Resolving variable decl GL_DRAW_BUFFER6_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER6_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER7 : GLenum
Resolving variable decl GL_DRAW_BUFFER7_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER7_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER8 : GLenum
Resolving variable decl GL_DRAW_BUFFER8_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER8_ATI : GLenum
Resolving variable decl GL_DRAW_BUFFER9 : GLenum
Resolving variable decl GL_DRAW_BUFFER9_ARB : GLenum
Resolving variable decl GL_DRAW_BUFFER9_ATI : GLenum
Resolving variable decl GL_DRAW_FRAMEBUFFER : GLenum
Resolving variable decl GL_DRAW_FRAMEBUFFER_BINDING : GLenum
Resolving variable decl GL_DRAW_FRAMEBUFFER_BINDING_EXT : GLenum
Resolving variable decl GL_DRAW_FRAMEBUFFER_EXT : GLenum
Resolving variable decl GL_DRAW_PIXELS_APPLE : GLenum
Resolving variable decl GL_DRAW_PIXEL_TOKEN : GLenum
Resolving variable decl GL_DSDT8_MAG8_INTENSITY8_NV : GLenum
Resolving variable decl GL_DSDT8_MAG8_NV : GLenum
Resolving variable decl GL_DSDT8_NV : GLenum
Resolving variable decl GL_DSDT_MAG_INTENSITY_NV : GLenum
Resolving variable decl GL_DSDT_MAG_NV : GLenum
Resolving variable decl GL_DSDT_MAG_VIB_NV : GLenum
Resolving variable decl GL_DSDT_NV : GLenum
Resolving variable decl GL_DST_ALPHA : GLenum
Resolving variable decl GL_DST_COLOR : GLenum
Resolving variable decl GL_DS_BIAS_NV : GLenum
Resolving variable decl GL_DS_SCALE_NV : GLenum
Resolving variable decl GL_DT_BIAS_NV : GLenum
Resolving variable decl GL_DT_SCALE_NV : GLenum
Resolving variable decl GL_DU8DV8_ATI : GLenum
Resolving variable decl GL_DUDV_ATI : GLenum
Resolving variable decl GL_DYNAMIC_ATI : GLenum
Resolving variable decl GL_DYNAMIC_COPY : GLenum
Resolving variable decl GL_DYNAMIC_COPY_ARB : GLenum
Resolving variable decl GL_DYNAMIC_DRAW : GLenum
Resolving variable decl GL_DYNAMIC_DRAW_ARB : GLenum
Resolving variable decl GL_DYNAMIC_READ : GLenum
Resolving variable decl GL_DYNAMIC_READ_ARB : GLenum
Resolving variable decl GL_EDGEFLAG_BIT_PGI : GLenum
Resolving variable decl GL_EDGE_FLAG : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_COUNT_EXT : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_EXT : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_LIST_IBM : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_POINTER : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_STRIDE : GLenum
Resolving variable decl GL_EDGE_FLAG_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_EIGHTH_BIT_ATI : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_APPLE : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_ATI : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_BUFFER : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_BUFFER_ARB : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_POINTER_APPLE : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_POINTER_ATI : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_TYPE_APPLE : GLenum
Resolving variable decl GL_ELEMENT_ARRAY_TYPE_ATI : GLenum
Resolving variable decl GL_EMBOSS_CONSTANT_NV : GLenum
Resolving variable decl GL_EMBOSS_LIGHT_NV : GLenum
Resolving variable decl GL_EMBOSS_MAP_NV : GLenum
Resolving variable decl GL_EMISSION : GLenum
Resolving variable decl GL_ENABLE_BIT : GLenum
Resolving variable decl GL_ENV_ADD_EXT : GLenum
Resolving variable decl GL_ENV_BLEND_EXT : GLenum
Resolving variable decl GL_ENV_COPY_EXT : GLenum
Resolving variable decl GL_ENV_MODULATE_EXT : GLenum
Resolving variable decl GL_ENV_REPLACE_EXT : GLenum
Resolving variable decl GL_ENV_REVERSE_BLEND_EXT : GLenum
Resolving variable decl GL_ENV_REVERSE_SUBTRACT_EXT : GLenum
Resolving variable decl GL_ENV_SUBTRACT_EXT : GLenum
Resolving variable decl GL_EQUAL : GLenum
Resolving variable decl GL_EQUIV : GLenum
Resolving variable decl GL_EVAL_2D_NV : GLenum
Resolving variable decl GL_EVAL_BIT : GLenum
Resolving variable decl GL_EVAL_FRACTIONAL_TESSELLATION_NV : GLenum
Resolving variable decl GL_EVAL_TRIANGULAR_2D_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB0_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB10_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB11_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB12_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB13_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB14_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB15_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB1_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB2_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB3_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB4_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB5_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB6_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB7_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB8_NV : GLenum
Resolving variable decl GL_EVAL_VERTEX_ATTRIB9_NV : GLenum
Resolving variable decl GL_EXP : GLenum
Resolving variable decl GL_EXP2 : GLenum
Resolving variable decl GL_EXPAND_NEGATE_NV : GLenum
Resolving variable decl GL_EXPAND_NORMAL_NV : GLenum
Resolving variable decl GL_EXTENDED_RANGE_SGIS : GLenum
Resolving variable decl GL_EXTENSIONS : GLenum
Resolving variable decl GL_EYE_DISTANCE_TO_LINE_SGIS : GLenum
Resolving variable decl GL_EYE_DISTANCE_TO_POINT_SGIS : GLenum
Resolving variable decl GL_EYE_LINEAR : GLenum
Resolving variable decl GL_EYE_LINE_SGIS : GLenum
Resolving variable decl GL_EYE_PLANE : GLenum
Resolving variable decl GL_EYE_PLANE_ABSOLUTE_NV : GLenum
Resolving variable decl GL_EYE_POINT_SGIS : GLenum
Resolving variable decl GL_EYE_RADIAL_NV : GLenum
Resolving variable decl GL_E_TIMES_F_NV : GLenum
Resolving variable decl GL_FALSE : GLenum
Resolving variable decl GL_FASTEST : GLenum
Resolving variable decl GL_FEEDBACK : GLenum
Resolving variable decl GL_FEEDBACK_BUFFER_POINTER : GLenum
Resolving variable decl GL_FEEDBACK_BUFFER_SIZE : GLenum
Resolving variable decl GL_FEEDBACK_BUFFER_TYPE : GLenum
Resolving variable decl GL_FENCE_APPLE : GLenum
Resolving variable decl GL_FENCE_CONDITION_NV : GLenum
Resolving variable decl GL_FENCE_STATUS_NV : GLenum
Resolving variable decl GL_FIELDS_NV : GLenum
Resolving variable decl GL_FILL : GLenum
Resolving variable decl GL_FIXED_ONLY : GLenum
Resolving variable decl GL_FIXED_ONLY_ARB : GLenum
Resolving variable decl GL_FLAT : GLenum
Resolving variable decl GL_FLOAT : GLenum
Resolving variable decl GL_FLOAT_32_UNSIGNED_INT_24_8_REV : GLenum
Resolving variable decl GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV : GLenum
Resolving variable decl GL_FLOAT_CLEAR_COLOR_VALUE_NV : GLenum
Resolving variable decl GL_FLOAT_MAT2 : GLenum
Resolving variable decl GL_FLOAT_MAT2_ARB : GLenum
Resolving variable decl GL_FLOAT_MAT3 : GLenum
Resolving variable decl GL_FLOAT_MAT3_ARB : GLenum
Resolving variable decl GL_FLOAT_MAT4 : GLenum
Resolving variable decl GL_FLOAT_MAT4_ARB : GLenum
Resolving variable decl GL_FLOAT_R16_NV : GLenum
Resolving variable decl GL_FLOAT_R32_NV : GLenum
Resolving variable decl GL_FLOAT_RG16_NV : GLenum
Resolving variable decl GL_FLOAT_RG32_NV : GLenum
Resolving variable decl GL_FLOAT_RGB16_NV : GLenum
Resolving variable decl GL_FLOAT_RGB32_NV : GLenum
Resolving variable decl GL_FLOAT_RGBA16_NV : GLenum
Resolving variable decl GL_FLOAT_RGBA32_NV : GLenum
Resolving variable decl GL_FLOAT_RGBA_MODE_NV : GLenum
Resolving variable decl GL_FLOAT_RGBA_NV : GLenum
Resolving variable decl GL_FLOAT_RGB_NV : GLenum
Resolving variable decl GL_FLOAT_RG_NV : GLenum
Resolving variable decl GL_FLOAT_R_NV : GLenum
Resolving variable decl GL_FLOAT_VEC2 : GLenum
Resolving variable decl GL_FLOAT_VEC2_ARB : GLenum
Resolving variable decl GL_FLOAT_VEC3 : GLenum
Resolving variable decl GL_FLOAT_VEC3_ARB : GLenum
Resolving variable decl GL_FLOAT_VEC4 : GLenum
Resolving variable decl GL_FLOAT_VEC4_ARB : GLenum
Resolving variable decl GL_FOG : GLenum
Resolving variable decl GL_FOG_BIT : GLenum
Resolving variable decl GL_FOG_COLOR : GLenum
Resolving variable decl GL_FOG_COORD : GLenum
Resolving variable decl GL_FOG_COORDINATE : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_EXT : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_LIST_IBM : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_POINTER : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_STRIDE : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_TYPE : GLenum
Resolving variable decl GL_FOG_COORDINATE_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_FOG_COORDINATE_EXT : GLenum
Resolving variable decl GL_FOG_COORDINATE_SOURCE : GLenum
Resolving variable decl GL_FOG_COORDINATE_SOURCE_EXT : GLenum
Resolving variable decl GL_FOG_COORD_ARRAY : GLenum
Resolving variable decl GL_FOG_COORD_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_FOG_COORD_ARRAY_POINTER : GLenum
Resolving variable decl GL_FOG_COORD_ARRAY_STRIDE : GLenum
Resolving variable decl GL_FOG_COORD_ARRAY_TYPE : GLenum
Resolving variable decl GL_FOG_COORD_SRC : GLenum
Resolving variable decl GL_FOG_DENSITY : GLenum
Resolving variable decl GL_FOG_DISTANCE_MODE_NV : GLenum
Resolving variable decl GL_FOG_END : GLenum
Resolving variable decl GL_FOG_HINT : GLenum
Resolving variable decl GL_FOG_INDEX : GLenum
Resolving variable decl GL_FOG_MODE : GLenum
Resolving variable decl GL_FOG_OFFSET_SGIX : GLenum
Resolving variable decl GL_FOG_OFFSET_VALUE_SGIX : GLenum
Resolving variable decl GL_FOG_PATCHY_FACTOR_SGIX : GLenum
Resolving variable decl GL_FOG_SPECULAR_TEXTURE_WIN : GLenum
Resolving variable decl GL_FOG_START : GLenum
Resolving variable decl GL_FORCE_BLUE_TO_ONE_NV : GLenum
Resolving variable decl GL_FORMAT_SUBSAMPLE_244_244_OML : GLenum
Resolving variable decl GL_FORMAT_SUBSAMPLE_24_24_OML : GLenum
Resolving variable decl GL_FRAGMENT_COLOR_EXT : GLenum
Resolving variable decl GL_FRAGMENT_COLOR_MATERIAL_EXT : GLenum
Resolving variable decl GL_FRAGMENT_COLOR_MATERIAL_FACE_EXT : GLenum
Resolving variable decl GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_EXT : GLenum
Resolving variable decl GL_FRAGMENT_DEPTH : GLenum
Resolving variable decl GL_FRAGMENT_DEPTH_EXT : GLenum
Resolving variable decl GL_FRAGMENT_FOG_SGIX : GLenum
Resolving variable decl GL_FRAGMENT_LIGHT0_EXT : GLenum
Resolving variable decl GL_FRAGMENT_LIGHT7_EXT : GLenum
Resolving variable decl GL_FRAGMENT_LIGHTING_EXT : GLenum
Resolving variable decl GL_FRAGMENT_LIGHT_MODEL_AMBIENT_EXT : GLenum
Resolving variable decl GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_EXT : GLenum
Resolving variable decl GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_EXT : GLenum
Resolving variable decl GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_EXT : GLenum
Resolving variable decl GL_FRAGMENT_MATERIAL_EXT : GLenum
Resolving variable decl GL_FRAGMENT_NORMAL_EXT : GLenum
Resolving variable decl GL_FRAGMENT_PROGRAM_ARB : GLenum
Resolving variable decl GL_FRAGMENT_PROGRAM_BINDING_NV : GLenum
Resolving variable decl GL_FRAGMENT_PROGRAM_NV : GLenum
Resolving variable decl GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV : GLenum
Resolving variable decl GL_FRAGMENT_SHADER : GLenum
Resolving variable decl GL_FRAGMENT_SHADER_ARB : GLenum
Resolving variable decl GL_FRAGMENT_SHADER_ATI : GLenum
Resolving variable decl GL_FRAGMENT_SHADER_DERIVATIVE_HINT : GLenum
Resolving variable decl GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB : GLenum
Resolving variable decl GL_FRAMEBUFFER : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL : GLenum
Resolving variable decl GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_BINDING : GLenum
Resolving variable decl GL_FRAMEBUFFER_BINDING_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_COMPLETE : GLenum
Resolving variable decl GL_FRAMEBUFFER_COMPLETE_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_DEFAULT : GLenum
Resolving variable decl GL_FRAMEBUFFER_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER : GLenum
Resolving variable decl GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_SRGB : GLenum
Resolving variable decl GL_FRAMEBUFFER_SRGB_CAPABLE_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_SRGB_EXT : GLenum
Resolving variable decl GL_FRAMEBUFFER_UNDEFINED : GLenum
Resolving variable decl GL_FRAMEBUFFER_UNSUPPORTED : GLenum
Resolving variable decl GL_FRAMEBUFFER_UNSUPPORTED_EXT : GLenum
Resolving variable decl GL_FRAME_NV : GLenum
Resolving variable decl GL_FRONT : GLenum
Resolving variable decl GL_FRONT_AND_BACK : GLenum
Resolving variable decl GL_FRONT_FACE : GLenum
Resolving variable decl GL_FRONT_LEFT : GLenum
Resolving variable decl GL_FRONT_RIGHT : GLenum
Resolving variable decl GL_FULL_RANGE_EXT : GLenum
Resolving variable decl GL_FULL_STIPPLE_HINT_PGI : GLenum
Resolving variable decl GL_FUNC_ADD : GLenum
Resolving variable decl GL_FUNC_ADD_EXT : GLenum
Resolving variable decl GL_FUNC_REVERSE_SUBTRACT : GLenum
Resolving variable decl GL_FUNC_REVERSE_SUBTRACT_EXT : GLenum
Resolving variable decl GL_FUNC_SUBTRACT : GLenum
Resolving variable decl GL_FUNC_SUBTRACT_EXT : GLenum
Resolving variable decl GL_GENERATE_MIPMAP : GLenum
Resolving variable decl GL_GENERATE_MIPMAP_HINT : GLenum
Resolving variable decl GL_GENERATE_MIPMAP_HINT_SGIS : GLenum
Resolving variable decl GL_GENERATE_MIPMAP_SGIS : GLenum
Resolving variable decl GL_GENERIC_ATTRIB_NV : GLenum
Resolving variable decl GL_GEOMETRY_INPUT_TYPE_ARB : GLenum
Resolving variable decl GL_GEOMETRY_INPUT_TYPE_EXT : GLenum
Resolving variable decl GL_GEOMETRY_OUTPUT_TYPE_ARB : GLenum
Resolving variable decl GL_GEOMETRY_OUTPUT_TYPE_EXT : GLenum
Resolving variable decl GL_GEOMETRY_PROGRAM_NV : GLenum
Resolving variable decl GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV : GLenum
Resolving variable decl GL_GEOMETRY_SHADER_ARB : GLenum
Resolving variable decl GL_GEOMETRY_SHADER_EXT : GLenum
Resolving variable decl GL_GEOMETRY_VERTICES_OUT_ARB : GLenum
Resolving variable decl GL_GEOMETRY_VERTICES_OUT_EXT : GLenum
Resolving variable decl GL_GEQUAL : GLenum
Resolving variable decl GL_GLOBAL_ALPHA_FACTOR_SUN : GLenum
Resolving variable decl GL_GLOBAL_ALPHA_SUN : GLenum
Resolving variable decl GL_GREATER : GLenum
Resolving variable decl GL_GREEN : GLenum
Resolving variable decl GL_GREEN_BIAS : GLenum
Resolving variable decl GL_GREEN_BITS : GLenum
Resolving variable decl GL_GREEN_BIT_ATI : GLenum
Resolving variable decl GL_GREEN_INTEGER : GLenum
Resolving variable decl GL_GREEN_INTEGER_EXT : GLenum
Resolving variable decl GL_GREEN_MAX_CLAMP_INGR : GLenum
Resolving variable decl GL_GREEN_MIN_CLAMP_INGR : GLenum
Resolving variable decl GL_GREEN_SCALE : GLenum
Resolving variable decl GL_HALF_APPLE : GLenum
Resolving variable decl GL_HALF_BIAS_NEGATE_NV : GLenum
Resolving variable decl GL_HALF_BIAS_NORMAL_NV : GLenum
Resolving variable decl GL_HALF_BIT_ATI : GLenum
Resolving variable decl GL_HALF_FLOAT : GLenum
Resolving variable decl GL_HALF_FLOAT_ARB : GLenum
Resolving variable decl GL_HALF_FLOAT_NV : GLenum
Resolving variable decl GL_HILO16_NV : GLenum
Resolving variable decl GL_HILO8_NV : GLenum
Resolving variable decl GL_HILO_NV : GLenum
Resolving variable decl GL_HINT_BIT : GLenum
Resolving variable decl GL_HISTOGRAM : GLenum
Resolving variable decl GL_HISTOGRAM_ALPHA_SIZE : GLenum
Resolving variable decl GL_HISTOGRAM_ALPHA_SIZE_EXT : GLenum
Resolving variable decl GL_HISTOGRAM_BLUE_SIZE : GLenum
Resolving variable decl GL_HISTOGRAM_BLUE_SIZE_EXT : GLenum
Resolving variable decl GL_HISTOGRAM_EXT : GLenum
Resolving variable decl GL_HISTOGRAM_FORMAT : GLenum
Resolving variable decl GL_HISTOGRAM_FORMAT_EXT : GLenum
Resolving variable decl GL_HISTOGRAM_GREEN_SIZE : GLenum
Resolving variable decl GL_HISTOGRAM_GREEN_SIZE_EXT : GLenum
Resolving variable decl GL_HISTOGRAM_LUMINANCE_SIZE : GLenum
Resolving variable decl GL_HISTOGRAM_LUMINANCE_SIZE_EXT : GLenum
Resolving variable decl GL_HISTOGRAM_RED_SIZE : GLenum
Resolving variable decl GL_HISTOGRAM_RED_SIZE_EXT : GLenum
Resolving variable decl GL_HISTOGRAM_SINK : GLenum
Resolving variable decl GL_HISTOGRAM_SINK_EXT : GLenum
Resolving variable decl GL_HISTOGRAM_WIDTH : GLenum
Resolving variable decl GL_HISTOGRAM_WIDTH_EXT : GLenum
Resolving variable decl GL_HI_BIAS_NV : GLenum
Resolving variable decl GL_HI_SCALE_NV : GLenum
Resolving variable decl GL_IDENTITY_NV : GLenum
Resolving variable decl GL_IGNORE_BORDER : GLenum
Resolving variable decl GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES : GLenum
Resolving variable decl GL_IMPLEMENTATION_COLOR_READ_TYPE_OES : GLenum
Resolving variable decl GL_INCR : GLenum
Resolving variable decl GL_INCR_WRAP : GLenum
Resolving variable decl GL_INCR_WRAP_EXT : GLenum
Resolving variable decl GL_INDEX : GLenum
Resolving variable decl GL_INDEX_ARRAY : GLenum
Resolving variable decl GL_INDEX_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_INDEX_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_INDEX_ARRAY_COUNT_EXT : GLenum
Resolving variable decl GL_INDEX_ARRAY_EXT : GLenum
Resolving variable decl GL_INDEX_ARRAY_LIST_IBM : GLenum
Resolving variable decl GL_INDEX_ARRAY_LIST_STRIDE_IBM : GLenum
Resolving variable decl GL_INDEX_ARRAY_POINTER : GLenum
Resolving variable decl GL_INDEX_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_INDEX_ARRAY_STRIDE : GLenum
Resolving variable decl GL_INDEX_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_INDEX_ARRAY_TYPE : GLenum
Resolving variable decl GL_INDEX_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_INDEX_BITS : GLenum
Resolving variable decl GL_INDEX_BIT_PGI : GLenum
Resolving variable decl GL_INDEX_CLEAR_VALUE : GLenum
Resolving variable decl GL_INDEX_LOGIC_OP : GLenum
Resolving variable decl GL_INDEX_MODE : GLenum
Resolving variable decl GL_INDEX_OFFSET : GLenum
Resolving variable decl GL_INDEX_SHIFT : GLenum
Resolving variable decl GL_INDEX_WRITEMASK : GLenum
Resolving variable decl GL_INFO_LOG_LENGTH : GLenum
Resolving variable decl GL_INT : GLenum
Resolving variable decl GL_INTENSITY : GLenum
Resolving variable decl GL_INTENSITY12 : GLenum
Resolving variable decl GL_INTENSITY12_EXT : GLenum
Resolving variable decl GL_INTENSITY16 : GLenum
Resolving variable decl GL_INTENSITY16F_ARB : GLenum
Resolving variable decl GL_INTENSITY16I_EXT : GLenum
Resolving variable decl GL_INTENSITY16UI_EXT : GLenum
Resolving variable decl GL_INTENSITY16_EXT : GLenum
Resolving variable decl GL_INTENSITY16_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_INTENSITY16_SIGNED_SGIX : GLenum
Resolving variable decl GL_INTENSITY32F_ARB : GLenum
Resolving variable decl GL_INTENSITY32I_EXT : GLenum
Resolving variable decl GL_INTENSITY32UI_EXT : GLenum
Resolving variable decl GL_INTENSITY4 : GLenum
Resolving variable decl GL_INTENSITY4_EXT : GLenum
Resolving variable decl GL_INTENSITY8 : GLenum
Resolving variable decl GL_INTENSITY8I_EXT : GLenum
Resolving variable decl GL_INTENSITY8UI_EXT : GLenum
Resolving variable decl GL_INTENSITY8_EXT : GLenum
Resolving variable decl GL_INTENSITY_EXT : GLenum
Resolving variable decl GL_INTENSITY_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_INTENSITY_FLOAT16_APPLE : GLenum
Resolving variable decl GL_INTENSITY_FLOAT16_ATI : GLenum
Resolving variable decl GL_INTENSITY_FLOAT32_APPLE : GLenum
Resolving variable decl GL_INTENSITY_FLOAT32_ATI : GLenum
Resolving variable decl GL_INTENSITY_SIGNED_SGIX : GLenum
Resolving variable decl GL_INTERLACE_OML : GLenum
Resolving variable decl GL_INTERLACE_READ_INGR : GLenum
Resolving variable decl GL_INTERLACE_READ_OML : GLenum
Resolving variable decl GL_INTERLACE_SGIX : GLenum
Resolving variable decl GL_INTERLEAVED_ATTRIBS : GLenum
Resolving variable decl GL_INTERLEAVED_ATTRIBS_EXT : GLenum
Resolving variable decl GL_INTERLEAVED_ATTRIBS_NV : GLenum
Resolving variable decl GL_INTERPOLATE : GLenum
Resolving variable decl GL_INTERPOLATE_ARB : GLenum
Resolving variable decl GL_INTERPOLATE_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_1D : GLenum
Resolving variable decl GL_INT_SAMPLER_1D_ARRAY : GLenum
Resolving variable decl GL_INT_SAMPLER_1D_ARRAY_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_1D_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_2D : GLenum
Resolving variable decl GL_INT_SAMPLER_2D_ARRAY : GLenum
Resolving variable decl GL_INT_SAMPLER_2D_ARRAY_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_2D_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_2D_RECT_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_3D : GLenum
Resolving variable decl GL_INT_SAMPLER_3D_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_BUFFER_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_CUBE : GLenum
Resolving variable decl GL_INT_SAMPLER_CUBE_EXT : GLenum
Resolving variable decl GL_INT_SAMPLER_RENDERBUFFER_NV : GLenum
Resolving variable decl GL_INT_VEC2 : GLenum
Resolving variable decl GL_INT_VEC2_ARB : GLenum
Resolving variable decl GL_INT_VEC3 : GLenum
Resolving variable decl GL_INT_VEC3_ARB : GLenum
Resolving variable decl GL_INT_VEC4 : GLenum
Resolving variable decl GL_INT_VEC4_ARB : GLenum
Resolving variable decl GL_INVALID_ENUM : GLenum
Resolving variable decl GL_INVALID_FRAMEBUFFER_OPERATION : GLenum
Resolving variable decl GL_INVALID_FRAMEBUFFER_OPERATION_EXT : GLenum
Resolving variable decl GL_INVALID_OPERATION : GLenum
Resolving variable decl GL_INVALID_VALUE : GLenum
Resolving variable decl GL_INVARIANT_DATATYPE_EXT : GLenum
Resolving variable decl GL_INVARIANT_EXT : GLenum
Resolving variable decl GL_INVARIANT_VALUE_EXT : GLenum
Resolving variable decl GL_INVERSE_NV : GLenum
Resolving variable decl GL_INVERSE_TRANSPOSE_NV : GLenum
Resolving variable decl GL_INVERT : GLenum
Resolving variable decl GL_INVERTED_SCREEN_W_REND : GLenum
Resolving variable decl GL_KEEP : GLenum
Resolving variable decl GL_KTX_BACK_REGION : GLenum
Resolving variable decl GL_KTX_FRONT_REGION : GLenum
Resolving variable decl GL_KTX_STENCIL_REGION : GLenum
Resolving variable decl GL_KTX_Z_REGION : GLenum
Resolving variable decl GL_LEFT : GLenum
Resolving variable decl GL_LEQUAL : GLenum
Resolving variable decl GL_LERP_ATI : GLenum
Resolving variable decl GL_LESS : GLenum
Resolving variable decl GL_LIGHT0 : GLenum
Resolving variable decl GL_LIGHT1 : GLenum
Resolving variable decl GL_LIGHT2 : GLenum
Resolving variable decl GL_LIGHT3 : GLenum
Resolving variable decl GL_LIGHT4 : GLenum
Resolving variable decl GL_LIGHT5 : GLenum
Resolving variable decl GL_LIGHT6 : GLenum
Resolving variable decl GL_LIGHT7 : GLenum
Resolving variable decl GL_LIGHTING : GLenum
Resolving variable decl GL_LIGHTING_BIT : GLenum
Resolving variable decl GL_LIGHT_ENV_MODE_EXT : GLenum
Resolving variable decl GL_LIGHT_MODEL_AMBIENT : GLenum
Resolving variable decl GL_LIGHT_MODEL_COLOR_CONTROL : GLenum
Resolving variable decl GL_LIGHT_MODEL_COLOR_CONTROL_EXT : GLenum
Resolving variable decl GL_LIGHT_MODEL_LOCAL_VIEWER : GLenum
Resolving variable decl GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE : GLenum
Resolving variable decl GL_LIGHT_MODEL_TWO_SIDE : GLenum
Resolving variable decl GL_LINE : GLenum
Resolving variable decl GL_LINEAR : GLenum
Resolving variable decl GL_LINEAR_ATTENUATION : GLenum
Resolving variable decl GL_LINEAR_MIPMAP_LINEAR : GLenum
Resolving variable decl GL_LINEAR_MIPMAP_NEAREST : GLenum
Resolving variable decl GL_LINES : GLenum
Resolving variable decl GL_LINES_ADJACENCY_ARB : GLenum
Resolving variable decl GL_LINES_ADJACENCY_EXT : GLenum
Resolving variable decl GL_LINE_BIT : GLenum
Resolving variable decl GL_LINE_LOOP : GLenum
Resolving variable decl GL_LINE_RESET_TOKEN : GLenum
Resolving variable decl GL_LINE_SMOOTH : GLenum
Resolving variable decl GL_LINE_SMOOTH_HINT : GLenum
Resolving variable decl GL_LINE_STIPPLE : GLenum
Resolving variable decl GL_LINE_STIPPLE_PATTERN : GLenum
Resolving variable decl GL_LINE_STIPPLE_REPEAT : GLenum
Resolving variable decl GL_LINE_STRIP : GLenum
Resolving variable decl GL_LINE_STRIP_ADJACENCY_ARB : GLenum
Resolving variable decl GL_LINE_STRIP_ADJACENCY_EXT : GLenum
Resolving variable decl GL_LINE_TOKEN : GLenum
Resolving variable decl GL_LINE_WIDTH : GLenum
Resolving variable decl GL_LINE_WIDTH_GRANULARITY : GLenum
Resolving variable decl GL_LINE_WIDTH_RANGE : GLenum
Resolving variable decl GL_LINK_STATUS : GLenum
Resolving variable decl GL_LIST_BASE : GLenum
Resolving variable decl GL_LIST_BIT : GLenum
Resolving variable decl GL_LIST_INDEX : GLenum
Resolving variable decl GL_LIST_MODE : GLenum
Resolving variable decl GL_LOAD : GLenum
Resolving variable decl GL_LOCAL_CONSTANT_DATATYPE_EXT : GLenum
Resolving variable decl GL_LOCAL_CONSTANT_EXT : GLenum
Resolving variable decl GL_LOCAL_CONSTANT_VALUE_EXT : GLenum
Resolving variable decl GL_LOCAL_EXT : GLenum
Resolving variable decl GL_LOGIC_OP : GLenum
Resolving variable decl GL_LOGIC_OP_MODE : GLenum
Resolving variable decl GL_LOWER_LEFT : GLenum
Resolving variable decl GL_LO_BIAS_NV : GLenum
Resolving variable decl GL_LO_SCALE_NV : GLenum
Resolving variable decl GL_LUMINANCE : GLenum
Resolving variable decl GL_LUMINANCE12 : GLenum
Resolving variable decl GL_LUMINANCE12_ALPHA12 : GLenum
Resolving variable decl GL_LUMINANCE12_ALPHA12_EXT : GLenum
Resolving variable decl GL_LUMINANCE12_ALPHA4 : GLenum
Resolving variable decl GL_LUMINANCE12_ALPHA4_EXT : GLenum
Resolving variable decl GL_LUMINANCE12_EXT : GLenum
Resolving variable decl GL_LUMINANCE16 : GLenum
Resolving variable decl GL_LUMINANCE16F_ARB : GLenum
Resolving variable decl GL_LUMINANCE16I_EXT : GLenum
Resolving variable decl GL_LUMINANCE16UI_EXT : GLenum
Resolving variable decl GL_LUMINANCE16_ALPHA16 : GLenum
Resolving variable decl GL_LUMINANCE16_ALPHA16_EXT : GLenum
Resolving variable decl GL_LUMINANCE16_ALPHA16_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_LUMINANCE16_ALPHA16_SIGNED_SGIX : GLenum
Resolving variable decl GL_LUMINANCE16_EXT : GLenum
Resolving variable decl GL_LUMINANCE16_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_LUMINANCE16_SIGNED_SGIX : GLenum
Resolving variable decl GL_LUMINANCE32F_ARB : GLenum
Resolving variable decl GL_LUMINANCE32I_EXT : GLenum
Resolving variable decl GL_LUMINANCE32UI_EXT : GLenum
Resolving variable decl GL_LUMINANCE4 : GLenum
Resolving variable decl GL_LUMINANCE4_ALPHA4 : GLenum
Resolving variable decl GL_LUMINANCE4_ALPHA4_EXT : GLenum
Resolving variable decl GL_LUMINANCE4_EXT : GLenum
Resolving variable decl GL_LUMINANCE6_ALPHA2 : GLenum
Resolving variable decl GL_LUMINANCE6_ALPHA2_EXT : GLenum
Resolving variable decl GL_LUMINANCE8 : GLenum
Resolving variable decl GL_LUMINANCE8I_EXT : GLenum
Resolving variable decl GL_LUMINANCE8UI_EXT : GLenum
Resolving variable decl GL_LUMINANCE8_ALPHA8 : GLenum
Resolving variable decl GL_LUMINANCE8_ALPHA8_EXT : GLenum
Resolving variable decl GL_LUMINANCE8_EXT : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA16F_ARB : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA16I_EXT : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA16UI_EXT : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA32F_ARB : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA32I_EXT : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA32UI_EXT : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA8I_EXT : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA8UI_EXT : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA_FLOAT16_APPLE : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA_FLOAT16_ATI : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA_FLOAT32_APPLE : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA_FLOAT32_ATI : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA_INTEGER_EXT : GLenum
Resolving variable decl GL_LUMINANCE_ALPHA_SIGNED_SGIX : GLenum
Resolving variable decl GL_LUMINANCE_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_LUMINANCE_FLOAT16_APPLE : GLenum
Resolving variable decl GL_LUMINANCE_FLOAT16_ATI : GLenum
Resolving variable decl GL_LUMINANCE_FLOAT32_APPLE : GLenum
Resolving variable decl GL_LUMINANCE_FLOAT32_ATI : GLenum
Resolving variable decl GL_LUMINANCE_INTEGER_EXT : GLenum
Resolving variable decl GL_LUMINANCE_SIGNED_SGIX : GLenum
Resolving variable decl GL_MAD_ATI : GLenum
Resolving variable decl GL_MAGNITUDE_BIAS_NV : GLenum
Resolving variable decl GL_MAGNITUDE_SCALE_NV : GLenum
Resolving variable decl GL_MAJOR_VERSION : GLenum
Resolving variable decl GL_MAP1_BINORMAL_EXT : GLenum
Resolving variable decl GL_MAP1_COLOR_4 : GLenum
Resolving variable decl GL_MAP1_GRID_DOMAIN : GLenum
Resolving variable decl GL_MAP1_GRID_SEGMENTS : GLenum
Resolving variable decl GL_MAP1_INDEX : GLenum
Resolving variable decl GL_MAP1_NORMAL : GLenum
Resolving variable decl GL_MAP1_TANGENT_EXT : GLenum
Resolving variable decl GL_MAP1_TEXTURE_COORD_1 : GLenum
Resolving variable decl GL_MAP1_TEXTURE_COORD_2 : GLenum
Resolving variable decl GL_MAP1_TEXTURE_COORD_3 : GLenum
Resolving variable decl GL_MAP1_TEXTURE_COORD_4 : GLenum
Resolving variable decl GL_MAP1_VERTEX_3 : GLenum
Resolving variable decl GL_MAP1_VERTEX_4 : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB0_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB10_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB11_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB12_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB13_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB14_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB15_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB1_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB2_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB3_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB4_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB5_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB6_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB7_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB8_4_NV : GLenum
Resolving variable decl GL_MAP1_VERTEX_ATTRIB9_4_NV : GLenum
Resolving variable decl GL_MAP2_BINORMAL_EXT : GLenum
Resolving variable decl GL_MAP2_COLOR_4 : GLenum
Resolving variable decl GL_MAP2_GRID_DOMAIN : GLenum
Resolving variable decl GL_MAP2_GRID_SEGMENTS : GLenum
Resolving variable decl GL_MAP2_INDEX : GLenum
Resolving variable decl GL_MAP2_NORMAL : GLenum
Resolving variable decl GL_MAP2_TANGENT_EXT : GLenum
Resolving variable decl GL_MAP2_TEXTURE_COORD_1 : GLenum
Resolving variable decl GL_MAP2_TEXTURE_COORD_2 : GLenum
Resolving variable decl GL_MAP2_TEXTURE_COORD_3 : GLenum
Resolving variable decl GL_MAP2_TEXTURE_COORD_4 : GLenum
Resolving variable decl GL_MAP2_VERTEX_3 : GLenum
Resolving variable decl GL_MAP2_VERTEX_4 : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB0_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB10_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB11_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB12_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB13_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB14_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB15_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB1_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB2_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB3_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB4_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB5_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB6_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB7_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB8_4_NV : GLenum
Resolving variable decl GL_MAP2_VERTEX_ATTRIB9_4_NV : GLenum
Resolving variable decl GL_MAP_ATTRIB_U_ORDER_NV : GLenum
Resolving variable decl GL_MAP_ATTRIB_V_ORDER_NV : GLenum
Resolving variable decl GL_MAP_COLOR : GLenum
Resolving variable decl GL_MAP_FLUSH_EXPLICIT_BIT : GLenum
Resolving variable decl GL_MAP_INVALIDATE_BUFFER_BIT : GLenum
Resolving variable decl GL_MAP_INVALIDATE_RANGE_BIT : GLenum
Resolving variable decl GL_MAP_READ_BIT : GLenum
Resolving variable decl GL_MAP_STENCIL : GLenum
Resolving variable decl GL_MAP_TESSELLATION_NV : GLenum
Resolving variable decl GL_MAP_UNSYNCHRONIZED_BIT : GLenum
Resolving variable decl GL_MAP_WRITE_BIT : GLenum
Resolving variable decl GL_MATERIAL_SIDE_HINT_PGI : GLenum
Resolving variable decl GL_MATRIX0_ARB : GLenum
Resolving variable decl GL_MATRIX0_NV : GLenum
Resolving variable decl GL_MATRIX10_ARB : GLenum
Resolving variable decl GL_MATRIX11_ARB : GLenum
Resolving variable decl GL_MATRIX12_ARB : GLenum
Resolving variable decl GL_MATRIX13_ARB : GLenum
Resolving variable decl GL_MATRIX14_ARB : GLenum
Resolving variable decl GL_MATRIX15_ARB : GLenum
Resolving variable decl GL_MATRIX16_ARB : GLenum
Resolving variable decl GL_MATRIX17_ARB : GLenum
Resolving variable decl GL_MATRIX18_ARB : GLenum
Resolving variable decl GL_MATRIX19_ARB : GLenum
Resolving variable decl GL_MATRIX1_ARB : GLenum
Resolving variable decl GL_MATRIX1_NV : GLenum
Resolving variable decl GL_MATRIX20_ARB : GLenum
Resolving variable decl GL_MATRIX21_ARB : GLenum
Resolving variable decl GL_MATRIX22_ARB : GLenum
Resolving variable decl GL_MATRIX23_ARB : GLenum
Resolving variable decl GL_MATRIX24_ARB : GLenum
Resolving variable decl GL_MATRIX25_ARB : GLenum
Resolving variable decl GL_MATRIX26_ARB : GLenum
Resolving variable decl GL_MATRIX27_ARB : GLenum
Resolving variable decl GL_MATRIX28_ARB : GLenum
Resolving variable decl GL_MATRIX29_ARB : GLenum
Resolving variable decl GL_MATRIX2_ARB : GLenum
Resolving variable decl GL_MATRIX2_NV : GLenum
Resolving variable decl GL_MATRIX30_ARB : GLenum
Resolving variable decl GL_MATRIX31_ARB : GLenum
Resolving variable decl GL_MATRIX3_ARB : GLenum
Resolving variable decl GL_MATRIX3_NV : GLenum
Resolving variable decl GL_MATRIX4_ARB : GLenum
Resolving variable decl GL_MATRIX4_NV : GLenum
Resolving variable decl GL_MATRIX5_ARB : GLenum
Resolving variable decl GL_MATRIX5_NV : GLenum
Resolving variable decl GL_MATRIX6_ARB : GLenum
Resolving variable decl GL_MATRIX6_NV : GLenum
Resolving variable decl GL_MATRIX7_ARB : GLenum
Resolving variable decl GL_MATRIX7_NV : GLenum
Resolving variable decl GL_MATRIX8_ARB : GLenum
Resolving variable decl GL_MATRIX9_ARB : GLenum
Resolving variable decl GL_MATRIX_EXT : GLenum
Resolving variable decl GL_MATRIX_INDEX_ARRAY_ARB : GLenum
Resolving variable decl GL_MATRIX_INDEX_ARRAY_POINTER_ARB : GLenum
Resolving variable decl GL_MATRIX_INDEX_ARRAY_SIZE_ARB : GLenum
Resolving variable decl GL_MATRIX_INDEX_ARRAY_STRIDE_ARB : GLenum
Resolving variable decl GL_MATRIX_INDEX_ARRAY_TYPE_ARB : GLenum
Resolving variable decl GL_MATRIX_MODE : GLenum
Resolving variable decl GL_MATRIX_PALETTE_ARB : GLenum
Resolving variable decl GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI : GLenum
Resolving variable decl GL_MAT_AMBIENT_BIT_PGI : GLenum
Resolving variable decl GL_MAT_COLOR_INDEXES_BIT_PGI : GLenum
Resolving variable decl GL_MAT_DIFFUSE_BIT_PGI : GLenum
Resolving variable decl GL_MAT_EMISSION_BIT_PGI : GLenum
Resolving variable decl GL_MAT_SHININESS_BIT_PGI : GLenum
Resolving variable decl GL_MAT_SPECULAR_BIT_PGI : GLenum
Resolving variable decl GL_MAX : GLenum
Resolving variable decl GL_MAX_3D_TEXTURE_SIZE : GLenum
Resolving variable decl GL_MAX_3D_TEXTURE_SIZE_EXT : GLenum
Resolving variable decl GL_MAX_ACTIVE_LIGHTS_EXT : GLenum
Resolving variable decl GL_MAX_ALPHA_SGIS : GLenum
Resolving variable decl GL_MAX_ARRAY_TEXTURE_LAYERS : GLenum
Resolving variable decl GL_MAX_ARRAY_TEXTURE_LAYERS_EXT : GLenum
Resolving variable decl GL_MAX_ASYNC_DRAW_PIXELS_SGIX : GLenum
Resolving variable decl GL_MAX_ASYNC_HISTOGRAM_SGIX : GLenum
Resolving variable decl GL_MAX_ASYNC_READ_PIXELS_SGIX : GLenum
Resolving variable decl GL_MAX_ASYNC_TEX_IMAGE_SGIX : GLenum
Resolving variable decl GL_MAX_ATTRIB_STACK_DEPTH : GLenum
Resolving variable decl GL_MAX_BINDABLE_UNIFORM_SIZE_EXT : GLenum
Resolving variable decl GL_MAX_BLUE_SGIS : GLenum
Resolving variable decl GL_MAX_CLIENT_ATTRIB_STACK_DEPTH : GLenum
Resolving variable decl GL_MAX_CLIP_DISTANCES : GLenum
Resolving variable decl GL_MAX_CLIP_PLANES : GLenum
Resolving variable decl GL_MAX_COLOR_ATTACHMENTS : GLenum
Resolving variable decl GL_MAX_COLOR_ATTACHMENTS_EXT : GLenum
Resolving variable decl GL_MAX_COLOR_MATRIX_STACK_DEPTH : GLenum
Resolving variable decl GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI : GLenum
Resolving variable decl GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS : GLenum
Resolving variable decl GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB : GLenum
Resolving variable decl GL_MAX_CONVOLUTION_HEIGHT : GLenum
Resolving variable decl GL_MAX_CONVOLUTION_HEIGHT_EXT : GLenum
Resolving variable decl GL_MAX_CONVOLUTION_WIDTH : GLenum
Resolving variable decl GL_MAX_CONVOLUTION_WIDTH_EXT : GLenum
Resolving variable decl GL_MAX_CUBE_MAP_TEXTURE_SIZE : GLenum
Resolving variable decl GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB : GLenum
Resolving variable decl GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT : GLenum
Resolving variable decl GL_MAX_DRAW_BUFFERS : GLenum
Resolving variable decl GL_MAX_DRAW_BUFFERS_ARB : GLenum
Resolving variable decl GL_MAX_DRAW_BUFFERS_ATI : GLenum
Resolving variable decl GL_MAX_ELEMENTS_INDICES : GLenum
Resolving variable decl GL_MAX_ELEMENTS_VERTICES : GLenum
Resolving variable decl GL_MAX_EVAL_ORDER : GLenum
Resolving variable decl GL_MAX_EXT : GLenum
Resolving variable decl GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT : GLenum
Resolving variable decl GL_MAX_FRAGMENT_LIGHTS_EXT : GLenum
Resolving variable decl GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV : GLenum
Resolving variable decl GL_MAX_FRAGMENT_UNIFORM_COMPONENTS : GLenum
Resolving variable decl GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB : GLenum
Resolving variable decl GL_MAX_GENERAL_COMBINERS_NV : GLenum
Resolving variable decl GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT : GLenum
Resolving variable decl GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB : GLenum
Resolving variable decl GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT : GLenum
Resolving variable decl GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB : GLenum
Resolving variable decl GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT : GLenum
Resolving variable decl GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB : GLenum
Resolving variable decl GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT : GLenum
Resolving variable decl GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB : GLenum
Resolving variable decl GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT : GLenum
Resolving variable decl GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB : GLenum
Resolving variable decl GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT : GLenum
Resolving variable decl GL_MAX_GREEN_SGIS : GLenum
Resolving variable decl GL_MAX_INTENSITY_SGIS : GLenum
Resolving variable decl GL_MAX_LIGHTS : GLenum
Resolving variable decl GL_MAX_LIST_NESTING : GLenum
Resolving variable decl GL_MAX_LUMINANCE_SGIS : GLenum
Resolving variable decl GL_MAX_MAP_TESSELLATION_NV : GLenum
Resolving variable decl GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB : GLenum
Resolving variable decl GL_MAX_MODELVIEW_STACK_DEPTH : GLenum
Resolving variable decl GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV : GLenum
Resolving variable decl GL_MAX_NAME_STACK_DEPTH : GLenum
Resolving variable decl GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT : GLenum
Resolving variable decl GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT : GLenum
Resolving variable decl GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT : GLenum
Resolving variable decl GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT : GLenum
Resolving variable decl GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT : GLenum
Resolving variable decl GL_MAX_PALETTE_MATRICES_ARB : GLenum
Resolving variable decl GL_MAX_PIXEL_MAP_TABLE : GLenum
Resolving variable decl GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT : GLenum
Resolving variable decl GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI : GLenum
Resolving variable decl GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_ATTRIBS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_CALL_DEPTH_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_ENV_PARAMETERS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_GENERIC_RESULTS_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_IF_DEPTH_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_LOOP_COUNT_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_LOOP_DEPTH_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_MATRICES_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_OUTPUT_VERTICES_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_PARAMETERS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_RESULT_COMPONENTS_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_TEMPORARIES_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_TEXEL_OFFSET : GLenum
Resolving variable decl GL_MAX_PROGRAM_TEXEL_OFFSET_NV : GLenum
Resolving variable decl GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV : GLenum
Resolving variable decl GL_MAX_PROJECTION_STACK_DEPTH : GLenum
Resolving variable decl GL_MAX_RATIONAL_EVAL_ORDER_NV : GLenum
Resolving variable decl GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB : GLenum
Resolving variable decl GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT : GLenum
Resolving variable decl GL_MAX_RECTANGLE_TEXTURE_SIZE_NV : GLenum
Resolving variable decl GL_MAX_RED_SGIS : GLenum
Resolving variable decl GL_MAX_RENDERBUFFER_SIZE : GLenum
Resolving variable decl GL_MAX_RENDERBUFFER_SIZE_EXT : GLenum
Resolving variable decl GL_MAX_SAMPLES : GLenum
Resolving variable decl GL_MAX_SAMPLES_EXT : GLenum
Resolving variable decl GL_MAX_SAMPLE_MASK_WORDS_NV : GLenum
Resolving variable decl GL_MAX_SHININESS_NV : GLenum
Resolving variable decl GL_MAX_SPOT_EXPONENT_NV : GLenum
Resolving variable decl GL_MAX_TEXTURE_BUFFER_SIZE_ARB : GLenum
Resolving variable decl GL_MAX_TEXTURE_BUFFER_SIZE_EXT : GLenum
Resolving variable decl GL_MAX_TEXTURE_COORDS : GLenum
Resolving variable decl GL_MAX_TEXTURE_COORDS_ARB : GLenum
Resolving variable decl GL_MAX_TEXTURE_COORDS_NV : GLenum
Resolving variable decl GL_MAX_TEXTURE_IMAGE_UNITS : GLenum
Resolving variable decl GL_MAX_TEXTURE_IMAGE_UNITS_ARB : GLenum
Resolving variable decl GL_MAX_TEXTURE_IMAGE_UNITS_NV : GLenum
Resolving variable decl GL_MAX_TEXTURE_LOD_BIAS : GLenum
Resolving variable decl GL_MAX_TEXTURE_LOD_BIAS_EXT : GLenum
Resolving variable decl GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT : GLenum
Resolving variable decl GL_MAX_TEXTURE_SIZE : GLenum
Resolving variable decl GL_MAX_TEXTURE_STACK_DEPTH : GLenum
Resolving variable decl GL_MAX_TEXTURE_UNITS : GLenum
Resolving variable decl GL_MAX_TEXTURE_UNITS_ARB : GLenum
Resolving variable decl GL_MAX_TRACK_MATRICES_NV : GLenum
Resolving variable decl GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT : GLenum
Resolving variable decl GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV : GLenum
Resolving variable decl GL_MAX_VARYING_COMPONENTS : GLenum
Resolving variable decl GL_MAX_VARYING_COMPONENTS_EXT : GLenum
Resolving variable decl GL_MAX_VARYING_FLOATS : GLenum
Resolving variable decl GL_MAX_VARYING_FLOATS_ARB : GLenum
Resolving variable decl GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_APPLE : GLenum
Resolving variable decl GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV : GLenum
Resolving variable decl GL_MAX_VERTEX_ATTRIBS : GLenum
Resolving variable decl GL_MAX_VERTEX_ATTRIBS_ARB : GLenum
Resolving variable decl GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT : GLenum
Resolving variable decl GL_MAX_VERTEX_HINT_PGI : GLenum
Resolving variable decl GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT : GLenum
Resolving variable decl GL_MAX_VERTEX_SHADER_INVARIANTS_EXT : GLenum
Resolving variable decl GL_MAX_VERTEX_SHADER_LOCALS_EXT : GLenum
Resolving variable decl GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT : GLenum
Resolving variable decl GL_MAX_VERTEX_SHADER_VARIANTS_EXT : GLenum
Resolving variable decl GL_MAX_VERTEX_STREAMS_ATI : GLenum
Resolving variable decl GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS : GLenum
Resolving variable decl GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB : GLenum
Resolving variable decl GL_MAX_VERTEX_UNIFORM_COMPONENTS : GLenum
Resolving variable decl GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB : GLenum
Resolving variable decl GL_MAX_VERTEX_UNITS_ARB : GLenum
Resolving variable decl GL_MAX_VERTEX_VARYING_COMPONENTS_ARB : GLenum
Resolving variable decl GL_MAX_VERTEX_VARYING_COMPONENTS_EXT : GLenum
Resolving variable decl GL_MAX_VIEWPORT_DIMS : GLenum
Resolving variable decl GL_MIN : GLenum
Resolving variable decl GL_MINMAX : GLenum
Resolving variable decl GL_MINMAX_EXT : GLenum
Resolving variable decl GL_MINMAX_FORMAT : GLenum
Resolving variable decl GL_MINMAX_FORMAT_EXT : GLenum
Resolving variable decl GL_MINMAX_SINK : GLenum
Resolving variable decl GL_MINMAX_SINK_EXT : GLenum
Resolving variable decl GL_MINOR_VERSION : GLenum
Resolving variable decl GL_MIN_ALPHA_SGIS : GLenum
Resolving variable decl GL_MIN_BLUE_SGIS : GLenum
Resolving variable decl GL_MIN_EXT : GLenum
Resolving variable decl GL_MIN_GREEN_SGIS : GLenum
Resolving variable decl GL_MIN_INTENSITY_SGIS : GLenum
Resolving variable decl GL_MIN_LUMINANCE_SGIS : GLenum
Resolving variable decl GL_MIN_PBUFFER_VIEWPORT_DIMS_APPLE : GLenum
Resolving variable decl GL_MIN_PROGRAM_TEXEL_OFFSET : GLenum
Resolving variable decl GL_MIN_PROGRAM_TEXEL_OFFSET_NV : GLenum
Resolving variable decl GL_MIN_RED_SGIS : GLenum
Resolving variable decl GL_MIRRORED_REPEAT : GLenum
Resolving variable decl GL_MIRRORED_REPEAT_ARB : GLenum
Resolving variable decl GL_MIRRORED_REPEAT_IBM : GLenum
Resolving variable decl GL_MIRROR_CLAMP_ATI : GLenum
Resolving variable decl GL_MIRROR_CLAMP_EXT : GLenum
Resolving variable decl GL_MIRROR_CLAMP_TO_BORDER_EXT : GLenum
Resolving variable decl GL_MIRROR_CLAMP_TO_EDGE_ATI : GLenum
Resolving variable decl GL_MIRROR_CLAMP_TO_EDGE_EXT : GLenum
Resolving variable decl GL_MODELVIEW : GLenum
Resolving variable decl GL_MODELVIEW0_ARB : GLenum
Resolving variable decl GL_MODELVIEW0_EXT : GLenum
Resolving variable decl GL_MODELVIEW0_MATRIX_EXT : GLenum
Resolving variable decl GL_MODELVIEW0_STACK_DEPTH_EXT : GLenum
Resolving variable decl GL_MODELVIEW10_ARB : GLenum
Resolving variable decl GL_MODELVIEW11_ARB : GLenum
Resolving variable decl GL_MODELVIEW12_ARB : GLenum
Resolving variable decl GL_MODELVIEW13_ARB : GLenum
Resolving variable decl GL_MODELVIEW14_ARB : GLenum
Resolving variable decl GL_MODELVIEW15_ARB : GLenum
Resolving variable decl GL_MODELVIEW16_ARB : GLenum
Resolving variable decl GL_MODELVIEW17_ARB : GLenum
Resolving variable decl GL_MODELVIEW18_ARB : GLenum
Resolving variable decl GL_MODELVIEW19_ARB : GLenum
Resolving variable decl GL_MODELVIEW1_ARB : GLenum
Resolving variable decl GL_MODELVIEW1_EXT : GLenum
Resolving variable decl GL_MODELVIEW1_MATRIX_EXT : GLenum
Resolving variable decl GL_MODELVIEW1_STACK_DEPTH_EXT : GLenum
Resolving variable decl GL_MODELVIEW20_ARB : GLenum
Resolving variable decl GL_MODELVIEW21_ARB : GLenum
Resolving variable decl GL_MODELVIEW22_ARB : GLenum
Resolving variable decl GL_MODELVIEW23_ARB : GLenum
Resolving variable decl GL_MODELVIEW24_ARB : GLenum
Resolving variable decl GL_MODELVIEW25_ARB : GLenum
Resolving variable decl GL_MODELVIEW26_ARB : GLenum
Resolving variable decl GL_MODELVIEW27_ARB : GLenum
Resolving variable decl GL_MODELVIEW28_ARB : GLenum
Resolving variable decl GL_MODELVIEW29_ARB : GLenum
Resolving variable decl GL_MODELVIEW2_ARB : GLenum
Resolving variable decl GL_MODELVIEW30_ARB : GLenum
Resolving variable decl GL_MODELVIEW31_ARB : GLenum
Resolving variable decl GL_MODELVIEW3_ARB : GLenum
Resolving variable decl GL_MODELVIEW4_ARB : GLenum
Resolving variable decl GL_MODELVIEW5_ARB : GLenum
Resolving variable decl GL_MODELVIEW6_ARB : GLenum
Resolving variable decl GL_MODELVIEW7_ARB : GLenum
Resolving variable decl GL_MODELVIEW8_ARB : GLenum
Resolving variable decl GL_MODELVIEW9_ARB : GLenum
Resolving variable decl GL_MODELVIEW_MATRIX : GLenum
Resolving variable decl GL_MODELVIEW_PROJECTION_NV : GLenum
Resolving variable decl GL_MODELVIEW_STACK_DEPTH : GLenum
Resolving variable decl GL_MODULATE : GLenum
Resolving variable decl GL_MODULATE_ADD_ATI : GLenum
Resolving variable decl GL_MODULATE_ADD_ATIX : GLenum
Resolving variable decl GL_MODULATE_SIGNED_ADD_ATI : GLenum
Resolving variable decl GL_MODULATE_SIGNED_ADD_ATIX : GLenum
Resolving variable decl GL_MODULATE_SUBTRACT_ATI : GLenum
Resolving variable decl GL_MODULATE_SUBTRACT_ATIX : GLenum
Resolving variable decl GL_MOV_ATI : GLenum
Resolving variable decl GL_MULT : GLenum
Resolving variable decl GL_MULTISAMPLE : GLenum
Resolving variable decl GL_MULTISAMPLE_3DFX : GLenum
Resolving variable decl GL_MULTISAMPLE_ARB : GLenum
Resolving variable decl GL_MULTISAMPLE_BIT : GLenum
Resolving variable decl GL_MULTISAMPLE_BIT_3DFX : GLenum
Resolving variable decl GL_MULTISAMPLE_BIT_ARB : GLenum
Resolving variable decl GL_MULTISAMPLE_BIT_EXT : GLenum
Resolving variable decl GL_MULTISAMPLE_COVERAGE_MODES_NV : GLenum
Resolving variable decl GL_MULTISAMPLE_EXT : GLenum
Resolving variable decl GL_MULTISAMPLE_FILTER_HINT_NV : GLenum
Resolving variable decl GL_MULTISAMPLE_SGIS : GLenum
Resolving variable decl GL_MUL_ATI : GLenum
Resolving variable decl GL_MVP_MATRIX_EXT : GLenum
Resolving variable decl GL_N3F_V3F : GLenum
Resolving variable decl GL_NAME_STACK_DEPTH : GLenum
Resolving variable decl GL_NAND : GLenum
Resolving variable decl GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI : GLenum
Resolving variable decl GL_NATIVE_GRAPHICS_END_HINT_PGI : GLenum
Resolving variable decl GL_NATIVE_GRAPHICS_HANDLE_PGI : GLenum
Resolving variable decl GL_NEAREST : GLenum
Resolving variable decl GL_NEAREST_MIPMAP_LINEAR : GLenum
Resolving variable decl GL_NEAREST_MIPMAP_NEAREST : GLenum
Resolving variable decl GL_NEGATE_BIT_ATI : GLenum
Resolving variable decl GL_NEGATIVE_ONE_EXT : GLenum
Resolving variable decl GL_NEGATIVE_W_EXT : GLenum
Resolving variable decl GL_NEGATIVE_X_EXT : GLenum
Resolving variable decl GL_NEGATIVE_Y_EXT : GLenum
Resolving variable decl GL_NEGATIVE_Z_EXT : GLenum
Resolving variable decl GL_NEVER : GLenum
Resolving variable decl GL_NICEST : GLenum
Resolving variable decl GL_NONE : GLenum
Resolving variable decl GL_NOOP : GLenum
Resolving variable decl GL_NOR : GLenum
Resolving variable decl GL_NORMALIZE : GLenum
Resolving variable decl GL_NORMALIZED_RANGE_EXT : GLenum
Resolving variable decl GL_NORMAL_ARRAY : GLenum
Resolving variable decl GL_NORMAL_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_NORMAL_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_NORMAL_ARRAY_COUNT_EXT : GLenum
Resolving variable decl GL_NORMAL_ARRAY_EXT : GLenum
Resolving variable decl GL_NORMAL_ARRAY_LIST_IBM : GLenum
Resolving variable decl GL_NORMAL_ARRAY_LIST_STRIDE_IBM : GLenum
Resolving variable decl GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL : GLenum
Resolving variable decl GL_NORMAL_ARRAY_POINTER : GLenum
Resolving variable decl GL_NORMAL_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_NORMAL_ARRAY_STRIDE : GLenum
Resolving variable decl GL_NORMAL_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_NORMAL_ARRAY_TYPE : GLenum
Resolving variable decl GL_NORMAL_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_NORMAL_BIT_PGI : GLenum
Resolving variable decl GL_NORMAL_MAP : GLenum
Resolving variable decl GL_NORMAL_MAP_ARB : GLenum
Resolving variable decl GL_NORMAL_MAP_EXT : GLenum
Resolving variable decl GL_NORMAL_MAP_NV : GLenum
Resolving variable decl GL_NOTEQUAL : GLenum
Resolving variable decl GL_NO_ERROR : GLenum
Resolving variable decl GL_NUM_COMPRESSED_TEXTURE_FORMATS : GLenum
Resolving variable decl GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB : GLenum
Resolving variable decl GL_NUM_EXTENSIONS : GLenum
Resolving variable decl GL_NUM_FILL_STREAMS_NV : GLenum
Resolving variable decl GL_NUM_FRAGMENT_CONSTANTS_ATI : GLenum
Resolving variable decl GL_NUM_FRAGMENT_REGISTERS_ATI : GLenum
Resolving variable decl GL_NUM_GENERAL_COMBINERS_NV : GLenum
Resolving variable decl GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI : GLenum
Resolving variable decl GL_NUM_INSTRUCTIONS_PER_PASS_ATI : GLenum
Resolving variable decl GL_NUM_INSTRUCTIONS_TOTAL_ATI : GLenum
Resolving variable decl GL_NUM_LOOPBACK_COMPONENTS_ATI : GLenum
Resolving variable decl GL_NUM_PASSES_ATI : GLenum
Resolving variable decl GL_OBJECT_ACTIVE_ATTRIBUTES_ARB : GLenum
Resolving variable decl GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB : GLenum
Resolving variable decl GL_OBJECT_ACTIVE_UNIFORMS_ARB : GLenum
Resolving variable decl GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB : GLenum
Resolving variable decl GL_OBJECT_ATTACHED_OBJECTS_ARB : GLenum
Resolving variable decl GL_OBJECT_BUFFER_SIZE_ATI : GLenum
Resolving variable decl GL_OBJECT_BUFFER_USAGE_ATI : GLenum
Resolving variable decl GL_OBJECT_COMPILE_STATUS_ARB : GLenum
Resolving variable decl GL_OBJECT_DELETE_STATUS_ARB : GLenum
Resolving variable decl GL_OBJECT_DISTANCE_TO_LINE_SGIS : GLenum
Resolving variable decl GL_OBJECT_DISTANCE_TO_POINT_SGIS : GLenum
Resolving variable decl GL_OBJECT_INFO_LOG_LENGTH_ARB : GLenum
Resolving variable decl GL_OBJECT_LINEAR : GLenum
Resolving variable decl GL_OBJECT_LINE_SGIS : GLenum
Resolving variable decl GL_OBJECT_LINK_STATUS_ARB : GLenum
Resolving variable decl GL_OBJECT_PLANE : GLenum
Resolving variable decl GL_OBJECT_POINT_SGIS : GLenum
Resolving variable decl GL_OBJECT_SHADER_SOURCE_LENGTH_ARB : GLenum
Resolving variable decl GL_OBJECT_SUBTYPE_ARB : GLenum
Resolving variable decl GL_OBJECT_TYPE_ARB : GLenum
Resolving variable decl GL_OBJECT_VALIDATE_STATUS_ARB : GLenum
Resolving variable decl GL_OCCLUSION_TEST_HP : GLenum
Resolving variable decl GL_OCCLUSION_TEST_RESULT_HP : GLenum
Resolving variable decl GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV : GLenum
Resolving variable decl GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV : GLenum
Resolving variable decl GL_OFFSET_HILO_TEXTURE_2D_NV : GLenum
Resolving variable decl GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV : GLenum
Resolving variable decl GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV : GLenum
Resolving variable decl GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV : GLenum
Resolving variable decl GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV : GLenum
Resolving variable decl GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_2D_BIAS_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_2D_MATRIX_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_2D_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_2D_SCALE_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_BIAS_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_MATRIX_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_RECTANGLE_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV : GLenum
Resolving variable decl GL_OFFSET_TEXTURE_SCALE_NV : GLenum
Resolving variable decl GL_ONE : GLenum
Resolving variable decl GL_ONE_EXT : GLenum
Resolving variable decl GL_ONE_MINUS_CONSTANT_ALPHA : GLenum
Resolving variable decl GL_ONE_MINUS_CONSTANT_ALPHA_EXT : GLenum
Resolving variable decl GL_ONE_MINUS_CONSTANT_COLOR : GLenum
Resolving variable decl GL_ONE_MINUS_CONSTANT_COLOR_EXT : GLenum
Resolving variable decl GL_ONE_MINUS_DST_ALPHA : GLenum
Resolving variable decl GL_ONE_MINUS_DST_COLOR : GLenum
Resolving variable decl GL_ONE_MINUS_SRC_ALPHA : GLenum
Resolving variable decl GL_ONE_MINUS_SRC_COLOR : GLenum
Resolving variable decl GL_OPERAND0_ALPHA : GLenum
Resolving variable decl GL_OPERAND0_ALPHA_ARB : GLenum
Resolving variable decl GL_OPERAND0_ALPHA_EXT : GLenum
Resolving variable decl GL_OPERAND0_RGB : GLenum
Resolving variable decl GL_OPERAND0_RGB_ARB : GLenum
Resolving variable decl GL_OPERAND0_RGB_EXT : GLenum
Resolving variable decl GL_OPERAND1_ALPHA : GLenum
Resolving variable decl GL_OPERAND1_ALPHA_ARB : GLenum
Resolving variable decl GL_OPERAND1_ALPHA_EXT : GLenum
Resolving variable decl GL_OPERAND1_RGB : GLenum
Resolving variable decl GL_OPERAND1_RGB_ARB : GLenum
Resolving variable decl GL_OPERAND1_RGB_EXT : GLenum
Resolving variable decl GL_OPERAND2_ALPHA : GLenum
Resolving variable decl GL_OPERAND2_ALPHA_ARB : GLenum
Resolving variable decl GL_OPERAND2_ALPHA_EXT : GLenum
Resolving variable decl GL_OPERAND2_RGB : GLenum
Resolving variable decl GL_OPERAND2_RGB_ARB : GLenum
Resolving variable decl GL_OPERAND2_RGB_EXT : GLenum
Resolving variable decl GL_OPERAND3_ALPHA_NV : GLenum
Resolving variable decl GL_OPERAND3_RGB_NV : GLenum
Resolving variable decl GL_OP_ADD_EXT : GLenum
Resolving variable decl GL_OP_CLAMP_EXT : GLenum
Resolving variable decl GL_OP_CROSS_PRODUCT_EXT : GLenum
Resolving variable decl GL_OP_DOT3_EXT : GLenum
Resolving variable decl GL_OP_DOT4_EXT : GLenum
Resolving variable decl GL_OP_EXP_BASE_2_EXT : GLenum
Resolving variable decl GL_OP_FLOOR_EXT : GLenum
Resolving variable decl GL_OP_FRAC_EXT : GLenum
Resolving variable decl GL_OP_INDEX_EXT : GLenum
Resolving variable decl GL_OP_LOG_BASE_2_EXT : GLenum
Resolving variable decl GL_OP_MADD_EXT : GLenum
Resolving variable decl GL_OP_MAX_EXT : GLenum
Resolving variable decl GL_OP_MIN_EXT : GLenum
Resolving variable decl GL_OP_MOV_EXT : GLenum
Resolving variable decl GL_OP_MULTIPLY_MATRIX_EXT : GLenum
Resolving variable decl GL_OP_MUL_EXT : GLenum
Resolving variable decl GL_OP_NEGATE_EXT : GLenum
Resolving variable decl GL_OP_POWER_EXT : GLenum
Resolving variable decl GL_OP_RECIP_EXT : GLenum
Resolving variable decl GL_OP_RECIP_SQRT_EXT : GLenum
Resolving variable decl GL_OP_ROUND_EXT : GLenum
Resolving variable decl GL_OP_SET_GE_EXT : GLenum
Resolving variable decl GL_OP_SET_LT_EXT : GLenum
Resolving variable decl GL_OP_SUB_EXT : GLenum
Resolving variable decl GL_OR : GLenum
Resolving variable decl GL_ORDER : GLenum
Resolving variable decl GL_OR_INVERTED : GLenum
Resolving variable decl GL_OR_REVERSE : GLenum
Resolving variable decl GL_OUTPUT_COLOR0_EXT : GLenum
Resolving variable decl GL_OUTPUT_COLOR1_EXT : GLenum
Resolving variable decl GL_OUTPUT_FOG_EXT : GLenum
Resolving variable decl GL_OUTPUT_POINT_SIZE_ATIX : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD0_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD10_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD11_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD12_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD13_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD14_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD15_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD16_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD17_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD18_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD19_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD1_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD20_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD21_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD22_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD23_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD24_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD25_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD26_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD27_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD28_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD29_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD2_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD30_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD31_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD3_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD4_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD5_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD6_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD7_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD8_EXT : GLenum
Resolving variable decl GL_OUTPUT_TEXTURE_COORD9_EXT : GLenum
Resolving variable decl GL_OUTPUT_VERTEX_EXT : GLenum
Resolving variable decl GL_OUT_OF_MEMORY : GLenum
Resolving variable decl GL_PACK_ALIGNMENT : GLenum
Resolving variable decl GL_PACK_CMYK_HINT_EXT : GLenum
Resolving variable decl GL_PACK_IMAGE_HEIGHT : GLenum
Resolving variable decl GL_PACK_IMAGE_HEIGHT_EXT : GLenum
Resolving variable decl GL_PACK_INVERT_MESA : GLenum
Resolving variable decl GL_PACK_LSB_FIRST : GLenum
Resolving variable decl GL_PACK_RESAMPLE_OML : GLenum
Resolving variable decl GL_PACK_RESAMPLE_SGIX : GLenum
Resolving variable decl GL_PACK_ROW_LENGTH : GLenum
Resolving variable decl GL_PACK_SKIP_IMAGES : GLenum
Resolving variable decl GL_PACK_SKIP_IMAGES_EXT : GLenum
Resolving variable decl GL_PACK_SKIP_PIXELS : GLenum
Resolving variable decl GL_PACK_SKIP_ROWS : GLenum
Resolving variable decl GL_PACK_SWAP_BYTES : GLenum
Resolving variable decl GL_PALETTE4_R5_G6_B5_OES : GLenum
Resolving variable decl GL_PALETTE4_RGB5_A1_OES : GLenum
Resolving variable decl GL_PALETTE4_RGB8_OES : GLenum
Resolving variable decl GL_PALETTE4_RGBA4_OES : GLenum
Resolving variable decl GL_PALETTE4_RGBA8_OES : GLenum
Resolving variable decl GL_PALETTE8_R5_G6_B5_OES : GLenum
Resolving variable decl GL_PALETTE8_RGB5_A1_OES : GLenum
Resolving variable decl GL_PALETTE8_RGB8_OES : GLenum
Resolving variable decl GL_PALETTE8_RGBA4_OES : GLenum
Resolving variable decl GL_PALETTE8_RGBA8_OES : GLenum
Resolving variable decl GL_PARALLEL_ARRAYS_INTEL : GLenum
Resolving variable decl GL_PASS_THROUGH_NV : GLenum
Resolving variable decl GL_PASS_THROUGH_TOKEN : GLenum
Resolving variable decl GL_PERSPECTIVE_CORRECTION_HINT : GLenum
Resolving variable decl GL_PERTURB_EXT : GLenum
Resolving variable decl GL_PER_STAGE_CONSTANTS_NV : GLenum
Resolving variable decl GL_PHONG_HINT_WIN : GLenum
Resolving variable decl GL_PHONG_WIN : GLenum
Resolving variable decl GL_PIXEL_COUNTER_BITS_NV : GLenum
Resolving variable decl GL_PIXEL_COUNT_AVAILABLE_NV : GLenum
Resolving variable decl GL_PIXEL_COUNT_NV : GLenum
Resolving variable decl GL_PIXEL_CUBIC_WEIGHT_EXT : GLenum
Resolving variable decl GL_PIXEL_MAG_FILTER_EXT : GLenum
Resolving variable decl GL_PIXEL_MAP_A_TO_A : GLenum
Resolving variable decl GL_PIXEL_MAP_A_TO_A_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_B_TO_B : GLenum
Resolving variable decl GL_PIXEL_MAP_B_TO_B_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_G_TO_G : GLenum
Resolving variable decl GL_PIXEL_MAP_G_TO_G_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_A : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_A_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_B : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_B_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_G : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_G_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_I : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_I_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_R : GLenum
Resolving variable decl GL_PIXEL_MAP_I_TO_R_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_R_TO_R : GLenum
Resolving variable decl GL_PIXEL_MAP_R_TO_R_SIZE : GLenum
Resolving variable decl GL_PIXEL_MAP_S_TO_S : GLenum
Resolving variable decl GL_PIXEL_MAP_S_TO_S_SIZE : GLenum
Resolving variable decl GL_PIXEL_MIN_FILTER_EXT : GLenum
Resolving variable decl GL_PIXEL_MODE_BIT : GLenum
Resolving variable decl GL_PIXEL_PACK_BUFFER : GLenum
Resolving variable decl GL_PIXEL_PACK_BUFFER_ARB : GLenum
Resolving variable decl GL_PIXEL_PACK_BUFFER_BINDING : GLenum
Resolving variable decl GL_PIXEL_PACK_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_PIXEL_PACK_BUFFER_BINDING_EXT : GLenum
Resolving variable decl GL_PIXEL_PACK_BUFFER_EXT : GLenum
Resolving variable decl GL_PIXEL_TRANSFORM_2D_EXT : GLenum
Resolving variable decl GL_PIXEL_TRANSFORM_2D_MATRIX_EXT : GLenum
Resolving variable decl GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT : GLenum
Resolving variable decl GL_PIXEL_UNPACK_BUFFER : GLenum
Resolving variable decl GL_PIXEL_UNPACK_BUFFER_ARB : GLenum
Resolving variable decl GL_PIXEL_UNPACK_BUFFER_BINDING : GLenum
Resolving variable decl GL_PIXEL_UNPACK_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_PIXEL_UNPACK_BUFFER_BINDING_EXT : GLenum
Resolving variable decl GL_PIXEL_UNPACK_BUFFER_EXT : GLenum
Resolving variable decl GL_PN_TRIANGLES_ATI : GLenum
Resolving variable decl GL_PN_TRIANGLES_NORMAL_MODE_ATI : GLenum
Resolving variable decl GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI : GLenum
Resolving variable decl GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI : GLenum
Resolving variable decl GL_PN_TRIANGLES_POINT_MODE_ATI : GLenum
Resolving variable decl GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI : GLenum
Resolving variable decl GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI : GLenum
Resolving variable decl GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI : GLenum
Resolving variable decl GL_POINT : GLenum
Resolving variable decl GL_POINTS : GLenum
Resolving variable decl GL_POINT_BIT : GLenum
Resolving variable decl GL_POINT_DISTANCE_ATTENUATION : GLenum
Resolving variable decl GL_POINT_DISTANCE_ATTENUATION_ARB : GLenum
Resolving variable decl GL_POINT_FADE_THRESHOLD_SIZE : GLenum
Resolving variable decl GL_POINT_FADE_THRESHOLD_SIZE_ARB : GLenum
Resolving variable decl GL_POINT_FADE_THRESHOLD_SIZE_EXT : GLenum
Resolving variable decl GL_POINT_SIZE : GLenum
Resolving variable decl GL_POINT_SIZE_GRANULARITY : GLenum
Resolving variable decl GL_POINT_SIZE_MAX : GLenum
Resolving variable decl GL_POINT_SIZE_MAX_ARB : GLenum
Resolving variable decl GL_POINT_SIZE_MAX_EXT : GLenum
Resolving variable decl GL_POINT_SIZE_MIN : GLenum
Resolving variable decl GL_POINT_SIZE_MIN_ARB : GLenum
Resolving variable decl GL_POINT_SIZE_MIN_EXT : GLenum
Resolving variable decl GL_POINT_SIZE_RANGE : GLenum
Resolving variable decl GL_POINT_SMOOTH : GLenum
Resolving variable decl GL_POINT_SMOOTH_HINT : GLenum
Resolving variable decl GL_POINT_SPRITE : GLenum
Resolving variable decl GL_POINT_SPRITE_ARB : GLenum
Resolving variable decl GL_POINT_SPRITE_COORD_ORIGIN : GLenum
Resolving variable decl GL_POINT_SPRITE_CULL_CENTER_ATIX : GLenum
Resolving variable decl GL_POINT_SPRITE_CULL_CLIP_ATIX : GLenum
Resolving variable decl GL_POINT_SPRITE_CULL_MODE_ATIX : GLenum
Resolving variable decl GL_POINT_SPRITE_NV : GLenum
Resolving variable decl GL_POINT_SPRITE_R_MODE_NV : GLenum
Resolving variable decl GL_POINT_TOKEN : GLenum
Resolving variable decl GL_POLYGON : GLenum
Resolving variable decl GL_POLYGON_BIT : GLenum
Resolving variable decl GL_POLYGON_MODE : GLenum
Resolving variable decl GL_POLYGON_OFFSET_BIAS_EXT : GLenum
Resolving variable decl GL_POLYGON_OFFSET_EXT : GLenum
Resolving variable decl GL_POLYGON_OFFSET_FACTOR : GLenum
Resolving variable decl GL_POLYGON_OFFSET_FACTOR_EXT : GLenum
Resolving variable decl GL_POLYGON_OFFSET_FILL : GLenum
Resolving variable decl GL_POLYGON_OFFSET_LINE : GLenum
Resolving variable decl GL_POLYGON_OFFSET_POINT : GLenum
Resolving variable decl GL_POLYGON_OFFSET_UNITS : GLenum
Resolving variable decl GL_POLYGON_SMOOTH : GLenum
Resolving variable decl GL_POLYGON_SMOOTH_HINT : GLenum
Resolving variable decl GL_POLYGON_STIPPLE : GLenum
Resolving variable decl GL_POLYGON_STIPPLE_BIT : GLenum
Resolving variable decl GL_POLYGON_TOKEN : GLenum
Resolving variable decl GL_POSITION : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_ALPHA_BIAS : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_ALPHA_SCALE : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_BLUE_BIAS : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_BLUE_SCALE : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_COLOR_TABLE : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_GREEN_BIAS : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_GREEN_SCALE : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_RED_BIAS : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_RED_BIAS_SGI : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_RED_SCALE : GLenum
Resolving variable decl GL_POST_COLOR_MATRIX_RED_SCALE_SGI : GLenum
Resolving variable decl GL_POST_CONVOLUTION_ALPHA_BIAS : GLenum
Resolving variable decl GL_POST_CONVOLUTION_ALPHA_BIAS_EXT : GLenum
Resolving variable decl GL_POST_CONVOLUTION_ALPHA_SCALE : GLenum
Resolving variable decl GL_POST_CONVOLUTION_ALPHA_SCALE_EXT : GLenum
Resolving variable decl GL_POST_CONVOLUTION_BLUE_BIAS : GLenum
Resolving variable decl GL_POST_CONVOLUTION_BLUE_BIAS_EXT : GLenum
Resolving variable decl GL_POST_CONVOLUTION_BLUE_SCALE : GLenum
Resolving variable decl GL_POST_CONVOLUTION_BLUE_SCALE_EXT : GLenum
Resolving variable decl GL_POST_CONVOLUTION_COLOR_TABLE : GLenum
Resolving variable decl GL_POST_CONVOLUTION_COLOR_TABLE_SGI : GLenum
Resolving variable decl GL_POST_CONVOLUTION_GREEN_BIAS : GLenum
Resolving variable decl GL_POST_CONVOLUTION_GREEN_BIAS_EXT : GLenum
Resolving variable decl GL_POST_CONVOLUTION_GREEN_SCALE : GLenum
Resolving variable decl GL_POST_CONVOLUTION_GREEN_SCALE_EXT : GLenum
Resolving variable decl GL_POST_CONVOLUTION_RED_BIAS : GLenum
Resolving variable decl GL_POST_CONVOLUTION_RED_BIAS_EXT : GLenum
Resolving variable decl GL_POST_CONVOLUTION_RED_SCALE : GLenum
Resolving variable decl GL_POST_CONVOLUTION_RED_SCALE_EXT : GLenum
Resolving variable decl GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX : GLenum
Resolving variable decl GL_POST_TEXTURE_FILTER_BIAS_SGIX : GLenum
Resolving variable decl GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX : GLenum
Resolving variable decl GL_POST_TEXTURE_FILTER_SCALE_SGIX : GLenum
Resolving variable decl GL_PREFER_DOUBLEBUFFER_HINT_PGI : GLenum
Resolving variable decl GL_PRESENT_DURATION_NV : GLenum
Resolving variable decl GL_PRESENT_TIME_NV : GLenum
Resolving variable decl GL_PRESERVE_ATI : GLenum
Resolving variable decl GL_PREVIOUS : GLenum
Resolving variable decl GL_PREVIOUS_ARB : GLenum
Resolving variable decl GL_PREVIOUS_EXT : GLenum
Resolving variable decl GL_PREVIOUS_TEXTURE_INPUT_NV : GLenum
Resolving variable decl GL_PRIMARY_COLOR : GLenum
Resolving variable decl GL_PRIMARY_COLOR_ARB : GLenum
Resolving variable decl GL_PRIMARY_COLOR_EXT : GLenum
Resolving variable decl GL_PRIMARY_COLOR_NV : GLenum
Resolving variable decl GL_PRIMITIVES_GENERATED : GLenum
Resolving variable decl GL_PRIMITIVES_GENERATED_EXT : GLenum
Resolving variable decl GL_PRIMITIVES_GENERATED_NV : GLenum
Resolving variable decl GL_PRIMITIVE_ID_NV : GLenum
Resolving variable decl GL_PRIMITIVE_RESTART_INDEX_NV : GLenum
Resolving variable decl GL_PRIMITIVE_RESTART_NV : GLenum
Resolving variable decl GL_PROGRAM_ADDRESS_REGISTERS_ARB : GLenum
Resolving variable decl GL_PROGRAM_ALU_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_PROGRAM_ATTRIBS_ARB : GLenum
Resolving variable decl GL_PROGRAM_ATTRIB_COMPONENTS_NV : GLenum
Resolving variable decl GL_PROGRAM_BINDING_ARB : GLenum
Resolving variable decl GL_PROGRAM_ERROR_POSITION_ARB : GLenum
Resolving variable decl GL_PROGRAM_ERROR_POSITION_NV : GLenum
Resolving variable decl GL_PROGRAM_ERROR_STRING_ARB : GLenum
Resolving variable decl GL_PROGRAM_ERROR_STRING_NV : GLenum
Resolving variable decl GL_PROGRAM_FORMAT_ARB : GLenum
Resolving variable decl GL_PROGRAM_FORMAT_ASCII_ARB : GLenum
Resolving variable decl GL_PROGRAM_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_PROGRAM_LENGTH_ARB : GLenum
Resolving variable decl GL_PROGRAM_LENGTH_NV : GLenum
Resolving variable decl GL_PROGRAM_MATRIX_EXT : GLenum
Resolving variable decl GL_PROGRAM_MATRIX_STACK_DEPTH_EXT : GLenum
Resolving variable decl GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB : GLenum
Resolving variable decl GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_PROGRAM_NATIVE_ATTRIBS_ARB : GLenum
Resolving variable decl GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_PROGRAM_NATIVE_PARAMETERS_ARB : GLenum
Resolving variable decl GL_PROGRAM_NATIVE_TEMPORARIES_ARB : GLenum
Resolving variable decl GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB : GLenum
Resolving variable decl GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_PROGRAM_OBJECT_ARB : GLenum
Resolving variable decl GL_PROGRAM_PARAMETERS_ARB : GLenum
Resolving variable decl GL_PROGRAM_PARAMETER_NV : GLenum
Resolving variable decl GL_PROGRAM_POINT_SIZE_ARB : GLenum
Resolving variable decl GL_PROGRAM_POINT_SIZE_EXT : GLenum
Resolving variable decl GL_PROGRAM_RESIDENT_NV : GLenum
Resolving variable decl GL_PROGRAM_RESULT_COMPONENTS_NV : GLenum
Resolving variable decl GL_PROGRAM_STRING_ARB : GLenum
Resolving variable decl GL_PROGRAM_STRING_NV : GLenum
Resolving variable decl GL_PROGRAM_TARGET_NV : GLenum
Resolving variable decl GL_PROGRAM_TEMPORARIES_ARB : GLenum
Resolving variable decl GL_PROGRAM_TEX_INDIRECTIONS_ARB : GLenum
Resolving variable decl GL_PROGRAM_TEX_INSTRUCTIONS_ARB : GLenum
Resolving variable decl GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB : GLenum
Resolving variable decl GL_PROJECTION : GLenum
Resolving variable decl GL_PROJECTION_MATRIX : GLenum
Resolving variable decl GL_PROJECTION_STACK_DEPTH : GLenum
Resolving variable decl GL_PROXY_COLOR_TABLE : GLenum
Resolving variable decl GL_PROXY_COLOR_TABLE_SGI : GLenum
Resolving variable decl GL_PROXY_HISTOGRAM : GLenum
Resolving variable decl GL_PROXY_HISTOGRAM_EXT : GLenum
Resolving variable decl GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE : GLenum
Resolving variable decl GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI : GLenum
Resolving variable decl GL_PROXY_POST_CONVOLUTION_COLOR_TABLE : GLenum
Resolving variable decl GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI : GLenum
Resolving variable decl GL_PROXY_TEXTURE_1D : GLenum
Resolving variable decl GL_PROXY_TEXTURE_1D_ARRAY : GLenum
Resolving variable decl GL_PROXY_TEXTURE_1D_ARRAY_EXT : GLenum
Resolving variable decl GL_PROXY_TEXTURE_1D_EXT : GLenum
Resolving variable decl GL_PROXY_TEXTURE_1D_STACK_MESAX : GLenum
Resolving variable decl GL_PROXY_TEXTURE_2D : GLenum
Resolving variable decl GL_PROXY_TEXTURE_2D_ARRAY : GLenum
Resolving variable decl GL_PROXY_TEXTURE_2D_ARRAY_EXT : GLenum
Resolving variable decl GL_PROXY_TEXTURE_2D_EXT : GLenum
Resolving variable decl GL_PROXY_TEXTURE_2D_STACK_MESAX : GLenum
Resolving variable decl GL_PROXY_TEXTURE_3D : GLenum
Resolving variable decl GL_PROXY_TEXTURE_3D_EXT : GLenum
Resolving variable decl GL_PROXY_TEXTURE_COLOR_TABLE_SGI : GLenum
Resolving variable decl GL_PROXY_TEXTURE_CUBE_MAP : GLenum
Resolving variable decl GL_PROXY_TEXTURE_CUBE_MAP_ARB : GLenum
Resolving variable decl GL_PROXY_TEXTURE_CUBE_MAP_EXT : GLenum
Resolving variable decl GL_PROXY_TEXTURE_RECTANGLE_ARB : GLenum
Resolving variable decl GL_PROXY_TEXTURE_RECTANGLE_EXT : GLenum
Resolving variable decl GL_PROXY_TEXTURE_RECTANGLE_NV : GLenum
Resolving variable decl GL_Q : GLenum
Resolving variable decl GL_QUADRATIC_ATTENUATION : GLenum
Resolving variable decl GL_QUADS : GLenum
Resolving variable decl GL_QUAD_MESH_SUN : GLenum
Resolving variable decl GL_QUAD_STRIP : GLenum
Resolving variable decl GL_QUARTER_BIT_ATI : GLenum
Resolving variable decl GL_QUERY_BY_REGION_NO_WAIT : GLenum
Resolving variable decl GL_QUERY_BY_REGION_NO_WAIT_NV : GLenum
Resolving variable decl GL_QUERY_BY_REGION_WAIT : GLenum
Resolving variable decl GL_QUERY_BY_REGION_WAIT_NV : GLenum
Resolving variable decl GL_QUERY_COUNTER_BITS : GLenum
Resolving variable decl GL_QUERY_COUNTER_BITS_ARB : GLenum
Resolving variable decl GL_QUERY_NO_WAIT : GLenum
Resolving variable decl GL_QUERY_NO_WAIT_NV : GLenum
Resolving variable decl GL_QUERY_RESULT : GLenum
Resolving variable decl GL_QUERY_RESULT_ARB : GLenum
Resolving variable decl GL_QUERY_RESULT_AVAILABLE : GLenum
Resolving variable decl GL_QUERY_RESULT_AVAILABLE_ARB : GLenum
Resolving variable decl GL_QUERY_RESULT_AVAILABLE_NV : GLenum
Resolving variable decl GL_QUERY_RESULT_NV : GLenum
Resolving variable decl GL_QUERY_WAIT : GLenum
Resolving variable decl GL_QUERY_WAIT_NV : GLenum
Resolving variable decl GL_R : GLenum
Resolving variable decl GL_R11F_G11F_B10F : GLenum
Resolving variable decl GL_R11F_G11F_B10F_EXT : GLenum
Resolving variable decl GL_R16 : GLenum
Resolving variable decl GL_R16F : GLenum
Resolving variable decl GL_R16I : GLenum
Resolving variable decl GL_R16UI : GLenum
Resolving variable decl GL_R1UI_C3F_V3F_SUN : GLenum
Resolving variable decl GL_R1UI_C4F_N3F_V3F_SUN : GLenum
Resolving variable decl GL_R1UI_C4UB_V3F_SUN : GLenum
Resolving variable decl GL_R1UI_N3F_V3F_SUN : GLenum
Resolving variable decl GL_R1UI_T2F_C4F_N3F_V3F_SUN : GLenum
Resolving variable decl GL_R1UI_T2F_N3F_V3F_SUN : GLenum
Resolving variable decl GL_R1UI_T2F_V3F_SUN : GLenum
Resolving variable decl GL_R1UI_V3F_SUN : GLenum
Resolving variable decl GL_R32F : GLenum
Resolving variable decl GL_R32I : GLenum
Resolving variable decl GL_R32UI : GLenum
Resolving variable decl GL_R3_G3_B2 : GLenum
Resolving variable decl GL_R8 : GLenum
Resolving variable decl GL_R8I : GLenum
Resolving variable decl GL_R8UI : GLenum
Resolving variable decl GL_RASTERIZER_DISCARD : GLenum
Resolving variable decl GL_RASTERIZER_DISCARD_EXT : GLenum
Resolving variable decl GL_RASTERIZER_DISCARD_NV : GLenum
Resolving variable decl GL_RASTER_POSITION_UNCLIPPED_IBM : GLenum
Resolving variable decl GL_READ_BUFFER : GLenum
Resolving variable decl GL_READ_FRAMEBUFFER : GLenum
Resolving variable decl GL_READ_FRAMEBUFFER_BINDING : GLenum
Resolving variable decl GL_READ_FRAMEBUFFER_BINDING_EXT : GLenum
Resolving variable decl GL_READ_FRAMEBUFFER_EXT : GLenum
Resolving variable decl GL_READ_ONLY : GLenum
Resolving variable decl GL_READ_ONLY_ARB : GLenum
Resolving variable decl GL_READ_PIXEL_DATA_RANGE_LENGTH_NV : GLenum
Resolving variable decl GL_READ_PIXEL_DATA_RANGE_NV : GLenum
Resolving variable decl GL_READ_PIXEL_DATA_RANGE_POINTER_NV : GLenum
Resolving variable decl GL_READ_WRITE : GLenum
Resolving variable decl GL_READ_WRITE_ARB : GLenum
Resolving variable decl GL_RECLAIM_MEMORY_HINT_PGI : GLenum
Resolving variable decl GL_RED : GLenum
Resolving variable decl GL_REDUCE : GLenum
Resolving variable decl GL_REDUCE_EXT : GLenum
Resolving variable decl GL_RED_BIAS : GLenum
Resolving variable decl GL_RED_BITS : GLenum
Resolving variable decl GL_RED_BIT_ATI : GLenum
Resolving variable decl GL_RED_INTEGER : GLenum
Resolving variable decl GL_RED_INTEGER_EXT : GLenum
Resolving variable decl GL_RED_MAX_CLAMP_INGR : GLenum
Resolving variable decl GL_RED_MIN_CLAMP_INGR : GLenum
Resolving variable decl GL_RED_SCALE : GLenum
Resolving variable decl GL_REFLECTION_MAP : GLenum
Resolving variable decl GL_REFLECTION_MAP_ARB : GLenum
Resolving variable decl GL_REFLECTION_MAP_EXT : GLenum
Resolving variable decl GL_REFLECTION_MAP_NV : GLenum
Resolving variable decl GL_REGISTER_COMBINERS_NV : GLenum
Resolving variable decl GL_REG_0_ATI : GLenum
Resolving variable decl GL_REG_1_ATI : GLenum
Resolving variable decl GL_REG_2_ATI : GLenum
Resolving variable decl GL_REG_3_ATI : GLenum
Resolving variable decl GL_REG_4_ATI : GLenum
Resolving variable decl GL_REG_5_ATI : GLenum
Resolving variable decl GL_RENDER : GLenum
Resolving variable decl GL_RENDERBUFFER : GLenum
Resolving variable decl GL_RENDERBUFFER_ALPHA_SIZE : GLenum
Resolving variable decl GL_RENDERBUFFER_ALPHA_SIZE_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_BINDING : GLenum
Resolving variable decl GL_RENDERBUFFER_BINDING_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_BLUE_SIZE : GLenum
Resolving variable decl GL_RENDERBUFFER_BLUE_SIZE_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_COLOR_SAMPLES_NV : GLenum
Resolving variable decl GL_RENDERBUFFER_COVERAGE_SAMPLES_NV : GLenum
Resolving variable decl GL_RENDERBUFFER_DEPTH_SIZE : GLenum
Resolving variable decl GL_RENDERBUFFER_DEPTH_SIZE_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_GREEN_SIZE : GLenum
Resolving variable decl GL_RENDERBUFFER_GREEN_SIZE_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_HEIGHT : GLenum
Resolving variable decl GL_RENDERBUFFER_HEIGHT_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_INTERNAL_FORMAT : GLenum
Resolving variable decl GL_RENDERBUFFER_INTERNAL_FORMAT_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_RED_SIZE : GLenum
Resolving variable decl GL_RENDERBUFFER_RED_SIZE_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_SAMPLES : GLenum
Resolving variable decl GL_RENDERBUFFER_SAMPLES_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_STENCIL_SIZE : GLenum
Resolving variable decl GL_RENDERBUFFER_STENCIL_SIZE_EXT : GLenum
Resolving variable decl GL_RENDERBUFFER_WIDTH : GLenum
Resolving variable decl GL_RENDERBUFFER_WIDTH_EXT : GLenum
Resolving variable decl GL_RENDERER : GLenum
Resolving variable decl GL_RENDER_MODE : GLenum
Resolving variable decl GL_REPEAT : GLenum
Resolving variable decl GL_REPLACE : GLenum
Resolving variable decl GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN : GLenum
Resolving variable decl GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN : GLenum
Resolving variable decl GL_REPLACEMENT_CODE_ARRAY_SUN : GLenum
Resolving variable decl GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN : GLenum
Resolving variable decl GL_REPLACEMENT_CODE_SUN : GLenum
Resolving variable decl GL_REPLACE_EXT : GLenum
Resolving variable decl GL_REPLACE_MIDDLE_SUN : GLenum
Resolving variable decl GL_REPLACE_OLDEST_SUN : GLenum
Resolving variable decl GL_REPLICATE_BORDER : GLenum
Resolving variable decl GL_RESAMPLE_AVERAGE_OML : GLenum
Resolving variable decl GL_RESAMPLE_DECIMATE_OML : GLenum
Resolving variable decl GL_RESAMPLE_DECIMATE_SGIX : GLenum
Resolving variable decl GL_RESAMPLE_REPLICATE_OML : GLenum
Resolving variable decl GL_RESAMPLE_REPLICATE_SGIX : GLenum
Resolving variable decl GL_RESAMPLE_ZERO_FILL_OML : GLenum
Resolving variable decl GL_RESAMPLE_ZERO_FILL_SGIX : GLenum
Resolving variable decl GL_RESCALE_NORMAL : GLenum
Resolving variable decl GL_RESCALE_NORMAL_EXT : GLenum
Resolving variable decl GL_RESTART_SUN : GLenum
Resolving variable decl GL_RETURN : GLenum
Resolving variable decl GL_RG : GLenum
Resolving variable decl GL_RG16 : GLenum
Resolving variable decl GL_RG16F : GLenum
Resolving variable decl GL_RG16I : GLenum
Resolving variable decl GL_RG16UI : GLenum
Resolving variable decl GL_RG32F : GLenum
Resolving variable decl GL_RG32I : GLenum
Resolving variable decl GL_RG32UI : GLenum
Resolving variable decl GL_RG8 : GLenum
Resolving variable decl GL_RG8I : GLenum
Resolving variable decl GL_RG8UI : GLenum
Resolving variable decl GL_RGB : GLenum
Resolving variable decl GL_RGB10 : GLenum
Resolving variable decl GL_RGB10_A2 : GLenum
Resolving variable decl GL_RGB10_A2_EXT : GLenum
Resolving variable decl GL_RGB10_EXT : GLenum
Resolving variable decl GL_RGB12 : GLenum
Resolving variable decl GL_RGB12_EXT : GLenum
Resolving variable decl GL_RGB16 : GLenum
Resolving variable decl GL_RGB16F : GLenum
Resolving variable decl GL_RGB16F_ARB : GLenum
Resolving variable decl GL_RGB16I : GLenum
Resolving variable decl GL_RGB16I_EXT : GLenum
Resolving variable decl GL_RGB16UI : GLenum
Resolving variable decl GL_RGB16UI_EXT : GLenum
Resolving variable decl GL_RGB16_EXT : GLenum
Resolving variable decl GL_RGB16_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_RGB16_SIGNED_SGIX : GLenum
Resolving variable decl GL_RGB2_EXT : GLenum
Resolving variable decl GL_RGB32F : GLenum
Resolving variable decl GL_RGB32F_ARB : GLenum
Resolving variable decl GL_RGB32I : GLenum
Resolving variable decl GL_RGB32I_EXT : GLenum
Resolving variable decl GL_RGB32UI : GLenum
Resolving variable decl GL_RGB32UI_EXT : GLenum
Resolving variable decl GL_RGB4 : GLenum
Resolving variable decl GL_RGB4_EXT : GLenum
Resolving variable decl GL_RGB4_S3TC : GLenum
Resolving variable decl GL_RGB5 : GLenum
Resolving variable decl GL_RGB5_A1 : GLenum
Resolving variable decl GL_RGB5_A1_EXT : GLenum
Resolving variable decl GL_RGB5_EXT : GLenum
Resolving variable decl GL_RGB8 : GLenum
Resolving variable decl GL_RGB8I : GLenum
Resolving variable decl GL_RGB8I_EXT : GLenum
Resolving variable decl GL_RGB8UI : GLenum
Resolving variable decl GL_RGB8UI_EXT : GLenum
Resolving variable decl GL_RGB8_EXT : GLenum
Resolving variable decl GL_RGB9_E5 : GLenum
Resolving variable decl GL_RGB9_E5_EXT : GLenum
Resolving variable decl GL_RGBA : GLenum
Resolving variable decl GL_RGBA12 : GLenum
Resolving variable decl GL_RGBA12_EXT : GLenum
Resolving variable decl GL_RGBA16 : GLenum
Resolving variable decl GL_RGBA16F : GLenum
Resolving variable decl GL_RGBA16F_ARB : GLenum
Resolving variable decl GL_RGBA16I : GLenum
Resolving variable decl GL_RGBA16I_EXT : GLenum
Resolving variable decl GL_RGBA16UI : GLenum
Resolving variable decl GL_RGBA16UI_EXT : GLenum
Resolving variable decl GL_RGBA16_EXT : GLenum
Resolving variable decl GL_RGBA16_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_RGBA16_SIGNED_SGIX : GLenum
Resolving variable decl GL_RGBA2 : GLenum
Resolving variable decl GL_RGBA2_EXT : GLenum
Resolving variable decl GL_RGBA32F : GLenum
Resolving variable decl GL_RGBA32F_ARB : GLenum
Resolving variable decl GL_RGBA32I : GLenum
Resolving variable decl GL_RGBA32I_EXT : GLenum
Resolving variable decl GL_RGBA32UI : GLenum
Resolving variable decl GL_RGBA32UI_EXT : GLenum
Resolving variable decl GL_RGBA4 : GLenum
Resolving variable decl GL_RGBA4_DXT5_S3TC : GLenum
Resolving variable decl GL_RGBA4_EXT : GLenum
Resolving variable decl GL_RGBA4_S3TC : GLenum
Resolving variable decl GL_RGBA8 : GLenum
Resolving variable decl GL_RGBA8I : GLenum
Resolving variable decl GL_RGBA8I_EXT : GLenum
Resolving variable decl GL_RGBA8UI : GLenum
Resolving variable decl GL_RGBA8UI_EXT : GLenum
Resolving variable decl GL_RGBA8_EXT : GLenum
Resolving variable decl GL_RGBA_DXT5_S3TC : GLenum
Resolving variable decl GL_RGBA_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_RGBA_FLOAT16_APPLE : GLenum
Resolving variable decl GL_RGBA_FLOAT16_ATI : GLenum
Resolving variable decl GL_RGBA_FLOAT32_APPLE : GLenum
Resolving variable decl GL_RGBA_FLOAT32_ATI : GLenum
Resolving variable decl GL_RGBA_FLOAT_MODE_ARB : GLenum
Resolving variable decl GL_RGBA_INTEGER : GLenum
Resolving variable decl GL_RGBA_INTEGER_EXT : GLenum
Resolving variable decl GL_RGBA_INTEGER_MODE_EXT : GLenum
Resolving variable decl GL_RGBA_MODE : GLenum
Resolving variable decl GL_RGBA_S3TC : GLenum
Resolving variable decl GL_RGBA_SIGNED_COMPONENTS_EXT : GLenum
Resolving variable decl GL_RGBA_SIGNED_SGIX : GLenum
Resolving variable decl GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV : GLenum
Resolving variable decl GL_RGB_EXTENDED_RANGE_SGIX : GLenum
Resolving variable decl GL_RGB_FLOAT16_APPLE : GLenum
Resolving variable decl GL_RGB_FLOAT16_ATI : GLenum
Resolving variable decl GL_RGB_FLOAT32_APPLE : GLenum
Resolving variable decl GL_RGB_FLOAT32_ATI : GLenum
Resolving variable decl GL_RGB_INTEGER : GLenum
Resolving variable decl GL_RGB_INTEGER_EXT : GLenum
Resolving variable decl GL_RGB_S3TC : GLenum
Resolving variable decl GL_RGB_SCALE : GLenum
Resolving variable decl GL_RGB_SCALE_ARB : GLenum
Resolving variable decl GL_RGB_SCALE_EXT : GLenum
Resolving variable decl GL_RGB_SIGNED_SGIX : GLenum
Resolving variable decl GL_RG_INTEGER : GLenum
Resolving variable decl GL_RIGHT : GLenum
Resolving variable decl GL_S : GLenum
Resolving variable decl GL_SAMPLER_1D : GLenum
Resolving variable decl GL_SAMPLER_1D_ARB : GLenum
Resolving variable decl GL_SAMPLER_1D_ARRAY : GLenum
Resolving variable decl GL_SAMPLER_1D_ARRAY_EXT : GLenum
Resolving variable decl GL_SAMPLER_1D_ARRAY_SHADOW : GLenum
Resolving variable decl GL_SAMPLER_1D_ARRAY_SHADOW_EXT : GLenum
Resolving variable decl GL_SAMPLER_1D_SHADOW : GLenum
Resolving variable decl GL_SAMPLER_1D_SHADOW_ARB : GLenum
Resolving variable decl GL_SAMPLER_2D : GLenum
Resolving variable decl GL_SAMPLER_2D_ARB : GLenum
Resolving variable decl GL_SAMPLER_2D_ARRAY : GLenum
Resolving variable decl GL_SAMPLER_2D_ARRAY_EXT : GLenum
Resolving variable decl GL_SAMPLER_2D_ARRAY_SHADOW : GLenum
Resolving variable decl GL_SAMPLER_2D_ARRAY_SHADOW_EXT : GLenum
Resolving variable decl GL_SAMPLER_2D_RECT_ARB : GLenum
Resolving variable decl GL_SAMPLER_2D_RECT_SHADOW_ARB : GLenum
Resolving variable decl GL_SAMPLER_2D_SHADOW : GLenum
Resolving variable decl GL_SAMPLER_2D_SHADOW_ARB : GLenum
Resolving variable decl GL_SAMPLER_3D : GLenum
Resolving variable decl GL_SAMPLER_3D_ARB : GLenum
Resolving variable decl GL_SAMPLER_BUFFER_EXT : GLenum
Resolving variable decl GL_SAMPLER_CUBE : GLenum
Resolving variable decl GL_SAMPLER_CUBE_ARB : GLenum
Resolving variable decl GL_SAMPLER_CUBE_SHADOW : GLenum
Resolving variable decl GL_SAMPLER_CUBE_SHADOW_EXT : GLenum
Resolving variable decl GL_SAMPLER_RENDERBUFFER_NV : GLenum
Resolving variable decl GL_SAMPLES : GLenum
Resolving variable decl GL_SAMPLES_3DFX : GLenum
Resolving variable decl GL_SAMPLES_ARB : GLenum
Resolving variable decl GL_SAMPLES_EXT : GLenum
Resolving variable decl GL_SAMPLES_PASSED : GLenum
Resolving variable decl GL_SAMPLES_PASSED_ARB : GLenum
Resolving variable decl GL_SAMPLES_SGIS : GLenum
Resolving variable decl GL_SAMPLE_ALPHA_TO_COVERAGE : GLenum
Resolving variable decl GL_SAMPLE_ALPHA_TO_COVERAGE_ARB : GLenum
Resolving variable decl GL_SAMPLE_ALPHA_TO_MASK_EXT : GLenum
Resolving variable decl GL_SAMPLE_ALPHA_TO_MASK_SGIS : GLenum
Resolving variable decl GL_SAMPLE_ALPHA_TO_ONE : GLenum
Resolving variable decl GL_SAMPLE_ALPHA_TO_ONE_ARB : GLenum
Resolving variable decl GL_SAMPLE_ALPHA_TO_ONE_EXT : GLenum
Resolving variable decl GL_SAMPLE_ALPHA_TO_ONE_SGIS : GLenum
Resolving variable decl GL_SAMPLE_BUFFERS : GLenum
Resolving variable decl GL_SAMPLE_BUFFERS_3DFX : GLenum
Resolving variable decl GL_SAMPLE_BUFFERS_ARB : GLenum
Resolving variable decl GL_SAMPLE_BUFFERS_EXT : GLenum
Resolving variable decl GL_SAMPLE_BUFFERS_SGIS : GLenum
Resolving variable decl GL_SAMPLE_COUNT_BITS_NV : GLenum
Resolving variable decl GL_SAMPLE_COUNT_NV : GLenum
Resolving variable decl GL_SAMPLE_COVERAGE : GLenum
Resolving variable decl GL_SAMPLE_COVERAGE_ARB : GLenum
Resolving variable decl GL_SAMPLE_COVERAGE_INVERT : GLenum
Resolving variable decl GL_SAMPLE_COVERAGE_INVERT_ARB : GLenum
Resolving variable decl GL_SAMPLE_COVERAGE_VALUE : GLenum
Resolving variable decl GL_SAMPLE_COVERAGE_VALUE_ARB : GLenum
Resolving variable decl GL_SAMPLE_MASK_EXT : GLenum
Resolving variable decl GL_SAMPLE_MASK_INVERT_EXT : GLenum
Resolving variable decl GL_SAMPLE_MASK_INVERT_SGIS : GLenum
Resolving variable decl GL_SAMPLE_MASK_NV : GLenum
Resolving variable decl GL_SAMPLE_MASK_SGIS : GLenum
Resolving variable decl GL_SAMPLE_MASK_VALUE_EXT : GLenum
Resolving variable decl GL_SAMPLE_MASK_VALUE_NV : GLenum
Resolving variable decl GL_SAMPLE_MASK_VALUE_SGIS : GLenum
Resolving variable decl GL_SAMPLE_PATTERN_EXT : GLenum
Resolving variable decl GL_SAMPLE_PATTERN_SGIS : GLenum
Resolving variable decl GL_SAMPLE_POSITION_NV : GLenum
Resolving variable decl GL_SATURATE_BIT_ATI : GLenum
Resolving variable decl GL_SCALAR_EXT : GLenum
Resolving variable decl GL_SCALE_BY_FOUR_NV : GLenum
Resolving variable decl GL_SCALE_BY_ONE_HALF_NV : GLenum
Resolving variable decl GL_SCALE_BY_TWO_NV : GLenum
Resolving variable decl GL_SCISSOR_BIT : GLenum
Resolving variable decl GL_SCISSOR_BOX : GLenum
Resolving variable decl GL_SCISSOR_TEST : GLenum
Resolving variable decl GL_SCREEN_COORDINATES_REND : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_EXT : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_LIST_IBM : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_POINTER : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_SIZE : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_SIZE_EXT : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_STRIDE : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_TYPE : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_SECONDARY_COLOR_ATIX : GLenum
Resolving variable decl GL_SECONDARY_COLOR_NV : GLenum
Resolving variable decl GL_SECONDARY_INTERPOLATOR_ATI : GLenum
Resolving variable decl GL_SELECT : GLenum
Resolving variable decl GL_SELECTION_BUFFER_POINTER : GLenum
Resolving variable decl GL_SELECTION_BUFFER_SIZE : GLenum
Resolving variable decl GL_SEPARABLE_2D : GLenum
Resolving variable decl GL_SEPARABLE_2D_EXT : GLenum
Resolving variable decl GL_SEPARATE_ATTRIBS : GLenum
Resolving variable decl GL_SEPARATE_ATTRIBS_EXT : GLenum
Resolving variable decl GL_SEPARATE_ATTRIBS_NV : GLenum
Resolving variable decl GL_SEPARATE_SPECULAR_COLOR : GLenum
Resolving variable decl GL_SEPARATE_SPECULAR_COLOR_EXT : GLenum
Resolving variable decl GL_SET : GLenum
Resolving variable decl GL_SHADER_CONSISTENT_NV : GLenum
Resolving variable decl GL_SHADER_OBJECT_ARB : GLenum
Resolving variable decl GL_SHADER_OPERATION_NV : GLenum
Resolving variable decl GL_SHADER_SOURCE_LENGTH : GLenum
Resolving variable decl GL_SHADER_TYPE : GLenum
Resolving variable decl GL_SHADE_MODEL : GLenum
Resolving variable decl GL_SHADING_LANGUAGE_VERSION : GLenum
Resolving variable decl GL_SHADING_LANGUAGE_VERSION_ARB : GLenum
Resolving variable decl GL_SHADOW_AMBIENT_SGIX : GLenum
Resolving variable decl GL_SHADOW_ATTENUATION_EXT : GLenum
Resolving variable decl GL_SHARED_TEXTURE_PALETTE_EXT : GLenum
Resolving variable decl GL_SHININESS : GLenum
Resolving variable decl GL_SHORT : GLenum
Resolving variable decl GL_SIGNED_ALPHA8_NV : GLenum
Resolving variable decl GL_SIGNED_ALPHA_NV : GLenum
Resolving variable decl GL_SIGNED_HILO16_NV : GLenum
Resolving variable decl GL_SIGNED_HILO8_NV : GLenum
Resolving variable decl GL_SIGNED_HILO_NV : GLenum
Resolving variable decl GL_SIGNED_IDENTITY_NV : GLenum
Resolving variable decl GL_SIGNED_INTENSITY8_NV : GLenum
Resolving variable decl GL_SIGNED_INTENSITY_NV : GLenum
Resolving variable decl GL_SIGNED_LUMINANCE8_ALPHA8_NV : GLenum
Resolving variable decl GL_SIGNED_LUMINANCE8_NV : GLenum
Resolving variable decl GL_SIGNED_LUMINANCE_ALPHA_NV : GLenum
Resolving variable decl GL_SIGNED_LUMINANCE_NV : GLenum
Resolving variable decl GL_SIGNED_NEGATE_NV : GLenum
Resolving variable decl GL_SIGNED_RGB8_NV : GLenum
Resolving variable decl GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV : GLenum
Resolving variable decl GL_SIGNED_RGBA8_NV : GLenum
Resolving variable decl GL_SIGNED_RGBA_NV : GLenum
Resolving variable decl GL_SIGNED_RGB_NV : GLenum
Resolving variable decl GL_SIGNED_RGB_UNSIGNED_ALPHA_NV : GLenum
Resolving variable decl GL_SINGLE_COLOR : GLenum
Resolving variable decl GL_SINGLE_COLOR_EXT : GLenum
Resolving variable decl GL_SLICE_ACCUM_SUN : GLenum
Resolving variable decl GL_SLUMINANCE : GLenum
Resolving variable decl GL_SLUMINANCE8 : GLenum
Resolving variable decl GL_SLUMINANCE8_ALPHA8 : GLenum
Resolving variable decl GL_SLUMINANCE8_ALPHA8_EXT : GLenum
Resolving variable decl GL_SLUMINANCE8_EXT : GLenum
Resolving variable decl GL_SLUMINANCE_ALPHA : GLenum
Resolving variable decl GL_SLUMINANCE_ALPHA_EXT : GLenum
Resolving variable decl GL_SLUMINANCE_EXT : GLenum
Resolving variable decl GL_SMOOTH : GLenum
Resolving variable decl GL_SMOOTH_LINE_WIDTH_GRANULARITY : GLenum
Resolving variable decl GL_SMOOTH_LINE_WIDTH_RANGE : GLenum
Resolving variable decl GL_SMOOTH_POINT_SIZE_GRANULARITY : GLenum
Resolving variable decl GL_SMOOTH_POINT_SIZE_RANGE : GLenum
Resolving variable decl GL_SOURCE0_ALPHA : GLenum
Resolving variable decl GL_SOURCE0_ALPHA_ARB : GLenum
Resolving variable decl GL_SOURCE0_ALPHA_EXT : GLenum
Resolving variable decl GL_SOURCE0_RGB : GLenum
Resolving variable decl GL_SOURCE0_RGB_ARB : GLenum
Resolving variable decl GL_SOURCE0_RGB_EXT : GLenum
Resolving variable decl GL_SOURCE1_ALPHA : GLenum
Resolving variable decl GL_SOURCE1_ALPHA_ARB : GLenum
Resolving variable decl GL_SOURCE1_ALPHA_EXT : GLenum
Resolving variable decl GL_SOURCE1_RGB : GLenum
Resolving variable decl GL_SOURCE1_RGB_ARB : GLenum
Resolving variable decl GL_SOURCE1_RGB_EXT : GLenum
Resolving variable decl GL_SOURCE2_ALPHA : GLenum
Resolving variable decl GL_SOURCE2_ALPHA_ARB : GLenum
Resolving variable decl GL_SOURCE2_ALPHA_EXT : GLenum
Resolving variable decl GL_SOURCE2_RGB : GLenum
Resolving variable decl GL_SOURCE2_RGB_ARB : GLenum
Resolving variable decl GL_SOURCE2_RGB_EXT : GLenum
Resolving variable decl GL_SOURCE3_ALPHA_NV : GLenum
Resolving variable decl GL_SOURCE3_RGB_NV : GLenum
Resolving variable decl GL_SPARE0_NV : GLenum
Resolving variable decl GL_SPARE0_PLUS_SECONDARY_COLOR_NV : GLenum
Resolving variable decl GL_SPARE1_NV : GLenum
Resolving variable decl GL_SPECULAR : GLenum
Resolving variable decl GL_SPHERE_MAP : GLenum
Resolving variable decl GL_SPOT_CUTOFF : GLenum
Resolving variable decl GL_SPOT_DIRECTION : GLenum
Resolving variable decl GL_SPOT_EXPONENT : GLenum
Resolving variable decl GL_SRC0_ALPHA : GLenum
Resolving variable decl GL_SRC0_RGB : GLenum
Resolving variable decl GL_SRC1_ALPHA : GLenum
Resolving variable decl GL_SRC1_RGB : GLenum
Resolving variable decl GL_SRC2_ALPHA : GLenum
Resolving variable decl GL_SRC2_RGB : GLenum
Resolving variable decl GL_SRC_ALPHA : GLenum
Resolving variable decl GL_SRC_ALPHA_SATURATE : GLenum
Resolving variable decl GL_SRC_COLOR : GLenum
Resolving variable decl GL_SRGB : GLenum
Resolving variable decl GL_SRGB8 : GLenum
Resolving variable decl GL_SRGB8_ALPHA8 : GLenum
Resolving variable decl GL_SRGB8_ALPHA8_EXT : GLenum
Resolving variable decl GL_SRGB8_EXT : GLenum
Resolving variable decl GL_SRGB_ALPHA : GLenum
Resolving variable decl GL_SRGB_ALPHA_EXT : GLenum
Resolving variable decl GL_SRGB_EXT : GLenum
Resolving variable decl GL_STACK_OVERFLOW : GLenum
Resolving variable decl GL_STACK_UNDERFLOW : GLenum
Resolving variable decl GL_STATIC_ATI : GLenum
Resolving variable decl GL_STATIC_COPY : GLenum
Resolving variable decl GL_STATIC_COPY_ARB : GLenum
Resolving variable decl GL_STATIC_DRAW : GLenum
Resolving variable decl GL_STATIC_DRAW_ARB : GLenum
Resolving variable decl GL_STATIC_READ : GLenum
Resolving variable decl GL_STATIC_READ_ARB : GLenum
Resolving variable decl GL_STATIC_VERTEX_ARRAY_IBM : GLenum
Resolving variable decl GL_STENCIL : GLenum
Resolving variable decl GL_STENCIL_ATTACHMENT : GLenum
Resolving variable decl GL_STENCIL_ATTACHMENT_EXT : GLenum
Resolving variable decl GL_STENCIL_BACK_FAIL : GLenum
Resolving variable decl GL_STENCIL_BACK_FAIL_ATI : GLenum
Resolving variable decl GL_STENCIL_BACK_FUNC : GLenum
Resolving variable decl GL_STENCIL_BACK_FUNC_ATI : GLenum
Resolving variable decl GL_STENCIL_BACK_PASS_DEPTH_FAIL : GLenum
Resolving variable decl GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI : GLenum
Resolving variable decl GL_STENCIL_BACK_PASS_DEPTH_PASS : GLenum
Resolving variable decl GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI : GLenum
Resolving variable decl GL_STENCIL_BACK_REF : GLenum
Resolving variable decl GL_STENCIL_BACK_VALUE_MASK : GLenum
Resolving variable decl GL_STENCIL_BACK_WRITEMASK : GLenum
Resolving variable decl GL_STENCIL_BITS : GLenum
Resolving variable decl GL_STENCIL_BUFFER : GLenum
Resolving variable decl GL_STENCIL_BUFFER_BIT : GLenum
Resolving variable decl GL_STENCIL_CLEAR_TAG_VALUE_EXT : GLenum
Resolving variable decl GL_STENCIL_CLEAR_VALUE : GLenum
Resolving variable decl GL_STENCIL_FAIL : GLenum
Resolving variable decl GL_STENCIL_FUNC : GLenum
Resolving variable decl GL_STENCIL_INDEX : GLenum
Resolving variable decl GL_STENCIL_INDEX1 : GLenum
Resolving variable decl GL_STENCIL_INDEX16 : GLenum
Resolving variable decl GL_STENCIL_INDEX16_EXT : GLenum
Resolving variable decl GL_STENCIL_INDEX1_EXT : GLenum
Resolving variable decl GL_STENCIL_INDEX4 : GLenum
Resolving variable decl GL_STENCIL_INDEX4_EXT : GLenum
Resolving variable decl GL_STENCIL_INDEX8 : GLenum
Resolving variable decl GL_STENCIL_INDEX8_EXT : GLenum
Resolving variable decl GL_STENCIL_PASS_DEPTH_FAIL : GLenum
Resolving variable decl GL_STENCIL_PASS_DEPTH_PASS : GLenum
Resolving variable decl GL_STENCIL_REF : GLenum
Resolving variable decl GL_STENCIL_TAG_BITS_EXT : GLenum
Resolving variable decl GL_STENCIL_TEST : GLenum
Resolving variable decl GL_STENCIL_TEST_TWO_SIDE_EXT : GLenum
Resolving variable decl GL_STENCIL_VALUE_MASK : GLenum
Resolving variable decl GL_STENCIL_WRITEMASK : GLenum
Resolving variable decl GL_STEREO : GLenum
Resolving variable decl GL_STORAGE_CACHED_APPLE : GLenum
Resolving variable decl GL_STORAGE_PRIVATE_APPLE : GLenum
Resolving variable decl GL_STORAGE_SHARED_APPLE : GLenum
Resolving variable decl GL_STREAM_COPY : GLenum
Resolving variable decl GL_STREAM_COPY_ARB : GLenum
Resolving variable decl GL_STREAM_DRAW : GLenum
Resolving variable decl GL_STREAM_DRAW_ARB : GLenum
Resolving variable decl GL_STREAM_READ : GLenum
Resolving variable decl GL_STREAM_READ_ARB : GLenum
Resolving variable decl GL_STRICT_DEPTHFUNC_HINT_PGI : GLenum
Resolving variable decl GL_STRICT_LIGHTING_HINT_PGI : GLenum
Resolving variable decl GL_STRICT_SCISSOR_HINT_PGI : GLenum
Resolving variable decl GL_SUBPIXEL_BITS : GLenum
Resolving variable decl GL_SUBTRACT : GLenum
Resolving variable decl GL_SUBTRACT_ARB : GLenum
Resolving variable decl GL_SUB_ATI : GLenum
Resolving variable decl GL_SWIZZLE_STQ_ATI : GLenum
Resolving variable decl GL_SWIZZLE_STQ_DQ_ATI : GLenum
Resolving variable decl GL_SWIZZLE_STRQ_ATI : GLenum
Resolving variable decl GL_SWIZZLE_STRQ_DQ_ATI : GLenum
Resolving variable decl GL_SWIZZLE_STR_ATI : GLenum
Resolving variable decl GL_SWIZZLE_STR_DR_ATI : GLenum
Resolving variable decl GL_T : GLenum
Resolving variable decl GL_T2F_C3F_V3F : GLenum
Resolving variable decl GL_T2F_C4F_N3F_V3F : GLenum
Resolving variable decl GL_T2F_C4UB_V3F : GLenum
Resolving variable decl GL_T2F_N3F_V3F : GLenum
Resolving variable decl GL_T2F_V3F : GLenum
Resolving variable decl GL_T4F_C4F_N3F_V4F : GLenum
Resolving variable decl GL_T4F_V4F : GLenum
Resolving variable decl GL_TABLE_TOO_LARGE : GLenum
Resolving variable decl GL_TANGENT_ARRAY_EXT : GLenum
Resolving variable decl GL_TANGENT_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_TANGENT_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_TANGENT_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_TEXCOORD1_BIT_PGI : GLenum
Resolving variable decl GL_TEXCOORD2_BIT_PGI : GLenum
Resolving variable decl GL_TEXCOORD3_BIT_PGI : GLenum
Resolving variable decl GL_TEXCOORD4_BIT_PGI : GLenum
Resolving variable decl GL_TEXTURE : GLenum
Resolving variable decl GL_TEXTURE0 : GLenum
Resolving variable decl GL_TEXTURE0_ARB : GLenum
Resolving variable decl GL_TEXTURE1 : GLenum
Resolving variable decl GL_TEXTURE10 : GLenum
Resolving variable decl GL_TEXTURE10_ARB : GLenum
Resolving variable decl GL_TEXTURE11 : GLenum
Resolving variable decl GL_TEXTURE11_ARB : GLenum
Resolving variable decl GL_TEXTURE12 : GLenum
Resolving variable decl GL_TEXTURE12_ARB : GLenum
Resolving variable decl GL_TEXTURE13 : GLenum
Resolving variable decl GL_TEXTURE13_ARB : GLenum
Resolving variable decl GL_TEXTURE14 : GLenum
Resolving variable decl GL_TEXTURE14_ARB : GLenum
Resolving variable decl GL_TEXTURE15 : GLenum
Resolving variable decl GL_TEXTURE15_ARB : GLenum
Resolving variable decl GL_TEXTURE16 : GLenum
Resolving variable decl GL_TEXTURE16_ARB : GLenum
Resolving variable decl GL_TEXTURE17 : GLenum
Resolving variable decl GL_TEXTURE17_ARB : GLenum
Resolving variable decl GL_TEXTURE18 : GLenum
Resolving variable decl GL_TEXTURE18_ARB : GLenum
Resolving variable decl GL_TEXTURE19 : GLenum
Resolving variable decl GL_TEXTURE19_ARB : GLenum
Resolving variable decl GL_TEXTURE1_ARB : GLenum
Resolving variable decl GL_TEXTURE2 : GLenum
Resolving variable decl GL_TEXTURE20 : GLenum
Resolving variable decl GL_TEXTURE20_ARB : GLenum
Resolving variable decl GL_TEXTURE21 : GLenum
Resolving variable decl GL_TEXTURE21_ARB : GLenum
Resolving variable decl GL_TEXTURE22 : GLenum
Resolving variable decl GL_TEXTURE22_ARB : GLenum
Resolving variable decl GL_TEXTURE23 : GLenum
Resolving variable decl GL_TEXTURE23_ARB : GLenum
Resolving variable decl GL_TEXTURE24 : GLenum
Resolving variable decl GL_TEXTURE24_ARB : GLenum
Resolving variable decl GL_TEXTURE25 : GLenum
Resolving variable decl GL_TEXTURE25_ARB : GLenum
Resolving variable decl GL_TEXTURE26 : GLenum
Resolving variable decl GL_TEXTURE26_ARB : GLenum
Resolving variable decl GL_TEXTURE27 : GLenum
Resolving variable decl GL_TEXTURE27_ARB : GLenum
Resolving variable decl GL_TEXTURE28 : GLenum
Resolving variable decl GL_TEXTURE28_ARB : GLenum
Resolving variable decl GL_TEXTURE29 : GLenum
Resolving variable decl GL_TEXTURE29_ARB : GLenum
Resolving variable decl GL_TEXTURE2_ARB : GLenum
Resolving variable decl GL_TEXTURE3 : GLenum
Resolving variable decl GL_TEXTURE30 : GLenum
Resolving variable decl GL_TEXTURE30_ARB : GLenum
Resolving variable decl GL_TEXTURE31 : GLenum
Resolving variable decl GL_TEXTURE31_ARB : GLenum
Resolving variable decl GL_TEXTURE3_ARB : GLenum
Resolving variable decl GL_TEXTURE4 : GLenum
Resolving variable decl GL_TEXTURE4_ARB : GLenum
Resolving variable decl GL_TEXTURE5 : GLenum
Resolving variable decl GL_TEXTURE5_ARB : GLenum
Resolving variable decl GL_TEXTURE6 : GLenum
Resolving variable decl GL_TEXTURE6_ARB : GLenum
Resolving variable decl GL_TEXTURE7 : GLenum
Resolving variable decl GL_TEXTURE7_ARB : GLenum
Resolving variable decl GL_TEXTURE8 : GLenum
Resolving variable decl GL_TEXTURE8_ARB : GLenum
Resolving variable decl GL_TEXTURE9 : GLenum
Resolving variable decl GL_TEXTURE9_ARB : GLenum
Resolving variable decl GL_TEXTURE_1D : GLenum
Resolving variable decl GL_TEXTURE_1D_ARRAY : GLenum
Resolving variable decl GL_TEXTURE_1D_ARRAY_EXT : GLenum
Resolving variable decl GL_TEXTURE_1D_BINDING_EXT : GLenum
Resolving variable decl GL_TEXTURE_1D_STACK_BINDING_MESAX : GLenum
Resolving variable decl GL_TEXTURE_1D_STACK_MESAX : GLenum
Resolving variable decl GL_TEXTURE_2D : GLenum
Resolving variable decl GL_TEXTURE_2D_ARRAY : GLenum
Resolving variable decl GL_TEXTURE_2D_ARRAY_EXT : GLenum
Resolving variable decl GL_TEXTURE_2D_BINDING_EXT : GLenum
Resolving variable decl GL_TEXTURE_2D_STACK_BINDING_MESAX : GLenum
Resolving variable decl GL_TEXTURE_2D_STACK_MESAX : GLenum
Resolving variable decl GL_TEXTURE_3D : GLenum
Resolving variable decl GL_TEXTURE_3D_BINDING_EXT : GLenum
Resolving variable decl GL_TEXTURE_3D_EXT : GLenum
Resolving variable decl GL_TEXTURE_ALPHA_SIZE : GLenum
Resolving variable decl GL_TEXTURE_ALPHA_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_ALPHA_TYPE : GLenum
Resolving variable decl GL_TEXTURE_ALPHA_TYPE_ARB : GLenum
Resolving variable decl GL_TEXTURE_APPLICATION_MODE_EXT : GLenum
Resolving variable decl GL_TEXTURE_BASE_LEVEL : GLenum
Resolving variable decl GL_TEXTURE_BASE_LEVEL_SGIS : GLenum
Resolving variable decl GL_TEXTURE_BINDING_1D : GLenum
Resolving variable decl GL_TEXTURE_BINDING_1D_ARRAY : GLenum
Resolving variable decl GL_TEXTURE_BINDING_1D_ARRAY_EXT : GLenum
Resolving variable decl GL_TEXTURE_BINDING_2D : GLenum
Resolving variable decl GL_TEXTURE_BINDING_2D_ARRAY : GLenum
Resolving variable decl GL_TEXTURE_BINDING_2D_ARRAY_EXT : GLenum
Resolving variable decl GL_TEXTURE_BINDING_3D : GLenum
Resolving variable decl GL_TEXTURE_BINDING_BUFFER_ARB : GLenum
Resolving variable decl GL_TEXTURE_BINDING_BUFFER_EXT : GLenum
Resolving variable decl GL_TEXTURE_BINDING_CUBE_MAP : GLenum
Resolving variable decl GL_TEXTURE_BINDING_CUBE_MAP_ARB : GLenum
Resolving variable decl GL_TEXTURE_BINDING_CUBE_MAP_EXT : GLenum
Resolving variable decl GL_TEXTURE_BINDING_RECTANGLE_ARB : GLenum
Resolving variable decl GL_TEXTURE_BINDING_RECTANGLE_EXT : GLenum
Resolving variable decl GL_TEXTURE_BINDING_RECTANGLE_NV : GLenum
Resolving variable decl GL_TEXTURE_BINDING_RENDERBUFFER_NV : GLenum
Resolving variable decl GL_TEXTURE_BIT : GLenum
Resolving variable decl GL_TEXTURE_BLUE_SIZE : GLenum
Resolving variable decl GL_TEXTURE_BLUE_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_BLUE_TYPE : GLenum
Resolving variable decl GL_TEXTURE_BLUE_TYPE_ARB : GLenum
Resolving variable decl GL_TEXTURE_BORDER : GLenum
Resolving variable decl GL_TEXTURE_BORDER_COLOR : GLenum
Resolving variable decl GL_TEXTURE_BORDER_VALUES_NV : GLenum
Resolving variable decl GL_TEXTURE_BUFFER_ARB : GLenum
Resolving variable decl GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB : GLenum
Resolving variable decl GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT : GLenum
Resolving variable decl GL_TEXTURE_BUFFER_EXT : GLenum
Resolving variable decl GL_TEXTURE_BUFFER_FORMAT_ARB : GLenum
Resolving variable decl GL_TEXTURE_BUFFER_FORMAT_EXT : GLenum
Resolving variable decl GL_TEXTURE_COLOR_TABLE_SGI : GLenum
Resolving variable decl GL_TEXTURE_COMPARE_FAIL_VALUE_ARB : GLenum
Resolving variable decl GL_TEXTURE_COMPARE_FUNC : GLenum
Resolving variable decl GL_TEXTURE_COMPARE_FUNC_ARB : GLenum
Resolving variable decl GL_TEXTURE_COMPARE_MODE : GLenum
Resolving variable decl GL_TEXTURE_COMPARE_MODE_ARB : GLenum
Resolving variable decl GL_TEXTURE_COMPARE_OPERATOR_SGIX : GLenum
Resolving variable decl GL_TEXTURE_COMPARE_SGIX : GLenum
Resolving variable decl GL_TEXTURE_COMPONENTS : GLenum
Resolving variable decl GL_TEXTURE_COMPRESSED : GLenum
Resolving variable decl GL_TEXTURE_COMPRESSED_ARB : GLenum
Resolving variable decl GL_TEXTURE_COMPRESSED_IMAGE_SIZE : GLenum
Resolving variable decl GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB : GLenum
Resolving variable decl GL_TEXTURE_COMPRESSION_HINT : GLenum
Resolving variable decl GL_TEXTURE_COMPRESSION_HINT_ARB : GLenum
Resolving variable decl GL_TEXTURE_CONSTANT_DATA_SUNX : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_COUNT_EXT : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_EXT : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_LIST_IBM : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_POINTER : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_SIZE : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_STRIDE : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_TYPE : GLenum
Resolving variable decl GL_TEXTURE_COORD_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_TEXTURE_COORD_NV : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_ARB : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_EXT : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_X : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_Y : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_Z : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_X : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_Y : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_Z : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB : GLenum
Resolving variable decl GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT : GLenum
Resolving variable decl GL_TEXTURE_DEPTH : GLenum
Resolving variable decl GL_TEXTURE_DEPTH_EXT : GLenum
Resolving variable decl GL_TEXTURE_DEPTH_SIZE : GLenum
Resolving variable decl GL_TEXTURE_DEPTH_SIZE_ARB : GLenum
Resolving variable decl GL_TEXTURE_DEPTH_TYPE : GLenum
Resolving variable decl GL_TEXTURE_DEPTH_TYPE_ARB : GLenum
Resolving variable decl GL_TEXTURE_DS_SIZE_NV : GLenum
Resolving variable decl GL_TEXTURE_DT_SIZE_NV : GLenum
Resolving variable decl GL_TEXTURE_ENV : GLenum
Resolving variable decl GL_TEXTURE_ENV0_EXT : GLenum
Resolving variable decl GL_TEXTURE_ENV_COLOR : GLenum
Resolving variable decl GL_TEXTURE_ENV_MODE : GLenum
Resolving variable decl GL_TEXTURE_ENV_MODE_ALPHA_EXT : GLenum
Resolving variable decl GL_TEXTURE_ENV_SHIFT_EXT : GLenum
Resolving variable decl GL_TEXTURE_FILTER_CONTROL : GLenum
Resolving variable decl GL_TEXTURE_FILTER_CONTROL_EXT : GLenum
Resolving variable decl GL_TEXTURE_FLOAT_COMPONENTS_NV : GLenum
Resolving variable decl GL_TEXTURE_FOG_SGIX : GLenum
Resolving variable decl GL_TEXTURE_GEN_MODE : GLenum
Resolving variable decl GL_TEXTURE_GEN_Q : GLenum
Resolving variable decl GL_TEXTURE_GEN_R : GLenum
Resolving variable decl GL_TEXTURE_GEN_S : GLenum
Resolving variable decl GL_TEXTURE_GEN_T : GLenum
Resolving variable decl GL_TEXTURE_GEQUAL_R_SGIX : GLenum
Resolving variable decl GL_TEXTURE_GREEN_SIZE : GLenum
Resolving variable decl GL_TEXTURE_GREEN_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_GREEN_TYPE : GLenum
Resolving variable decl GL_TEXTURE_GREEN_TYPE_ARB : GLenum
Resolving variable decl GL_TEXTURE_HEIGHT : GLenum
Resolving variable decl GL_TEXTURE_HI_SIZE_NV : GLenum
Resolving variable decl GL_TEXTURE_INDEX_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_INTENSITY_SIZE : GLenum
Resolving variable decl GL_TEXTURE_INTENSITY_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_INTENSITY_TYPE : GLenum
Resolving variable decl GL_TEXTURE_INTENSITY_TYPE_ARB : GLenum
Resolving variable decl GL_TEXTURE_INTERNAL_FORMAT : GLenum
Resolving variable decl GL_TEXTURE_LEQUAL_R_SGIX : GLenum
Resolving variable decl GL_TEXTURE_LIGHT_EXT : GLenum
Resolving variable decl GL_TEXTURE_LOD_BIAS : GLenum
Resolving variable decl GL_TEXTURE_LOD_BIAS_EXT : GLenum
Resolving variable decl GL_TEXTURE_LO_SIZE_NV : GLenum
Resolving variable decl GL_TEXTURE_LUMINANCE_SIZE : GLenum
Resolving variable decl GL_TEXTURE_LUMINANCE_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_LUMINANCE_TYPE : GLenum
Resolving variable decl GL_TEXTURE_LUMINANCE_TYPE_ARB : GLenum
Resolving variable decl GL_TEXTURE_MAG_FILTER : GLenum
Resolving variable decl GL_TEXTURE_MAG_SIZE_NV : GLenum
Resolving variable decl GL_TEXTURE_MATERIAL_FACE_EXT : GLenum
Resolving variable decl GL_TEXTURE_MATERIAL_PARAMETER_EXT : GLenum
Resolving variable decl GL_TEXTURE_MATRIX : GLenum
Resolving variable decl GL_TEXTURE_MAX_ANISOTROPY_EXT : GLenum
Resolving variable decl GL_TEXTURE_MAX_CLAMP_R_SGIX : GLenum
Resolving variable decl GL_TEXTURE_MAX_CLAMP_S_SGIX : GLenum
Resolving variable decl GL_TEXTURE_MAX_CLAMP_T_SGIX : GLenum
Resolving variable decl GL_TEXTURE_MAX_LEVEL : GLenum
Resolving variable decl GL_TEXTURE_MAX_LEVEL_SGIS : GLenum
Resolving variable decl GL_TEXTURE_MAX_LOD : GLenum
Resolving variable decl GL_TEXTURE_MAX_LOD_SGIS : GLenum
Resolving variable decl GL_TEXTURE_MIN_FILTER : GLenum
Resolving variable decl GL_TEXTURE_MIN_LOD : GLenum
Resolving variable decl GL_TEXTURE_MIN_LOD_SGIS : GLenum
Resolving variable decl GL_TEXTURE_MULTI_BUFFER_HINT_SGIX : GLenum
Resolving variable decl GL_TEXTURE_NORMAL_EXT : GLenum
Resolving variable decl GL_TEXTURE_OUTPUT_ALPHA_ATIX : GLenum
Resolving variable decl GL_TEXTURE_OUTPUT_RGB_ATIX : GLenum
Resolving variable decl GL_TEXTURE_POINT_MODE_ATIX : GLenum
Resolving variable decl GL_TEXTURE_POINT_ONE_COORD_ATIX : GLenum
Resolving variable decl GL_TEXTURE_POINT_SPRITE_ATIX : GLenum
Resolving variable decl GL_TEXTURE_PRIORITY : GLenum
Resolving variable decl GL_TEXTURE_PRIORITY_EXT : GLenum
Resolving variable decl GL_TEXTURE_RANGE_LENGTH_APPLE : GLenum
Resolving variable decl GL_TEXTURE_RANGE_POINTER_APPLE : GLenum
Resolving variable decl GL_TEXTURE_RECTANGLE_ARB : GLenum
Resolving variable decl GL_TEXTURE_RECTANGLE_EXT : GLenum
Resolving variable decl GL_TEXTURE_RECTANGLE_NV : GLenum
Resolving variable decl GL_TEXTURE_RED_SIZE : GLenum
Resolving variable decl GL_TEXTURE_RED_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_RED_TYPE : GLenum
Resolving variable decl GL_TEXTURE_RED_TYPE_ARB : GLenum
Resolving variable decl GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV : GLenum
Resolving variable decl GL_TEXTURE_RENDERBUFFER_NV : GLenum
Resolving variable decl GL_TEXTURE_RESIDENT : GLenum
Resolving variable decl GL_TEXTURE_RESIDENT_EXT : GLenum
Resolving variable decl GL_TEXTURE_SHADER_NV : GLenum
Resolving variable decl GL_TEXTURE_SHARED_SIZE : GLenum
Resolving variable decl GL_TEXTURE_SHARED_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_STACK_DEPTH : GLenum
Resolving variable decl GL_TEXTURE_STENCIL_SIZE : GLenum
Resolving variable decl GL_TEXTURE_STENCIL_SIZE_EXT : GLenum
Resolving variable decl GL_TEXTURE_STORAGE_HINT_APPLE : GLenum
Resolving variable decl GL_TEXTURE_SWIZZLE_A_EXT : GLenum
Resolving variable decl GL_TEXTURE_SWIZZLE_B_EXT : GLenum
Resolving variable decl GL_TEXTURE_SWIZZLE_G_EXT : GLenum
Resolving variable decl GL_TEXTURE_SWIZZLE_RGBA_EXT : GLenum
Resolving variable decl GL_TEXTURE_SWIZZLE_R_EXT : GLenum
Resolving variable decl GL_TEXTURE_UNSIGNED_REMAP_MODE_NV : GLenum
Resolving variable decl GL_TEXTURE_WIDTH : GLenum
Resolving variable decl GL_TEXTURE_WRAP_R : GLenum
Resolving variable decl GL_TEXTURE_WRAP_R_EXT : GLenum
Resolving variable decl GL_TEXTURE_WRAP_S : GLenum
Resolving variable decl GL_TEXTURE_WRAP_T : GLenum
Resolving variable decl GL_TEXT_FRAGMENT_SHADER_ATI : GLenum
Resolving variable decl GL_TIME_ELAPSED_EXT : GLenum
Resolving variable decl GL_TRACK_MATRIX_NV : GLenum
Resolving variable decl GL_TRACK_MATRIX_TRANSFORM_NV : GLenum
Resolving variable decl GL_TRANSFORM_BIT : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_ATTRIBS_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_BINDING : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_EXT : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_MODE : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_SIZE : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_START : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_BUFFER_START_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_RECORD_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_VARYINGS : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_VARYINGS_EXT : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_VARYINGS_NV : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH : GLenum
Resolving variable decl GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT : GLenum
Resolving variable decl GL_TRANSFORM_HINT_APPLE : GLenum
Resolving variable decl GL_TRANSPOSE_COLOR_MATRIX : GLenum
Resolving variable decl GL_TRANSPOSE_COLOR_MATRIX_ARB : GLenum
Resolving variable decl GL_TRANSPOSE_CURRENT_MATRIX_ARB : GLenum
Resolving variable decl GL_TRANSPOSE_MODELVIEW_MATRIX : GLenum
Resolving variable decl GL_TRANSPOSE_MODELVIEW_MATRIX_ARB : GLenum
Resolving variable decl GL_TRANSPOSE_NV : GLenum
Resolving variable decl GL_TRANSPOSE_PROGRAM_MATRIX_EXT : GLenum
Resolving variable decl GL_TRANSPOSE_PROJECTION_MATRIX : GLenum
Resolving variable decl GL_TRANSPOSE_PROJECTION_MATRIX_ARB : GLenum
Resolving variable decl GL_TRANSPOSE_TEXTURE_MATRIX : GLenum
Resolving variable decl GL_TRANSPOSE_TEXTURE_MATRIX_ARB : GLenum
Resolving variable decl GL_TRIANGLES : GLenum
Resolving variable decl GL_TRIANGLES_ADJACENCY_ARB : GLenum
Resolving variable decl GL_TRIANGLES_ADJACENCY_EXT : GLenum
Resolving variable decl GL_TRIANGLE_FAN : GLenum
Resolving variable decl GL_TRIANGLE_LIST_SUN : GLenum
Resolving variable decl GL_TRIANGLE_MESH_SUN : GLenum
Resolving variable decl GL_TRIANGLE_STRIP : GLenum
Resolving variable decl GL_TRIANGLE_STRIP_ADJACENCY_ARB : GLenum
Resolving variable decl GL_TRIANGLE_STRIP_ADJACENCY_EXT : GLenum
Resolving variable decl GL_TRUE : GLenum
Resolving variable decl GL_UNIFORM_BUFFER_BINDING_EXT : GLenum
Resolving variable decl GL_UNIFORM_BUFFER_EXT : GLenum
Resolving variable decl GL_UNPACK_ALIGNMENT : GLenum
Resolving variable decl GL_UNPACK_CLIENT_STORAGE_APPLE : GLenum
Resolving variable decl GL_UNPACK_CMYK_HINT_EXT : GLenum
Resolving variable decl GL_UNPACK_CONSTANT_DATA_SUNX : GLenum
Resolving variable decl GL_UNPACK_IMAGE_HEIGHT : GLenum
Resolving variable decl GL_UNPACK_IMAGE_HEIGHT_EXT : GLenum
Resolving variable decl GL_UNPACK_LSB_FIRST : GLenum
Resolving variable decl GL_UNPACK_RESAMPLE_OML : GLenum
Resolving variable decl GL_UNPACK_RESAMPLE_SGIX : GLenum
Resolving variable decl GL_UNPACK_ROW_LENGTH : GLenum
Resolving variable decl GL_UNPACK_SKIP_IMAGES : GLenum
Resolving variable decl GL_UNPACK_SKIP_IMAGES_EXT : GLenum
Resolving variable decl GL_UNPACK_SKIP_PIXELS : GLenum
Resolving variable decl GL_UNPACK_SKIP_ROWS : GLenum
Resolving variable decl GL_UNPACK_SWAP_BYTES : GLenum
Resolving variable decl GL_UNSIGNED_BYTE : GLenum
Resolving variable decl GL_UNSIGNED_BYTE_2_3_3_REV : GLenum
Resolving variable decl GL_UNSIGNED_BYTE_3_3_2 : GLenum
Resolving variable decl GL_UNSIGNED_BYTE_3_3_2_EXT : GLenum
Resolving variable decl GL_UNSIGNED_IDENTITY_NV : GLenum
Resolving variable decl GL_UNSIGNED_INT : GLenum
Resolving variable decl GL_UNSIGNED_INT_10F_11F_11F_REV : GLenum
Resolving variable decl GL_UNSIGNED_INT_10F_11F_11F_REV_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_10_10_10_2 : GLenum
Resolving variable decl GL_UNSIGNED_INT_10_10_10_2_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_24_8 : GLenum
Resolving variable decl GL_UNSIGNED_INT_24_8_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_24_8_NV : GLenum
Resolving variable decl GL_UNSIGNED_INT_2_10_10_10_REV : GLenum
Resolving variable decl GL_UNSIGNED_INT_5_9_9_9_REV : GLenum
Resolving variable decl GL_UNSIGNED_INT_5_9_9_9_REV_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_8_8_8_8 : GLenum
Resolving variable decl GL_UNSIGNED_INT_8_8_8_8_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_8_8_8_8_REV : GLenum
Resolving variable decl GL_UNSIGNED_INT_8_8_S8_S8_REV_NV : GLenum
Resolving variable decl GL_UNSIGNED_INT_S8_S8_8_8_NV : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_1D : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_1D_ARRAY : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_1D_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_2D : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_2D_ARRAY : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_2D_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_3D : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_3D_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_CUBE : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_CUBE_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV : GLenum
Resolving variable decl GL_UNSIGNED_INT_VEC2 : GLenum
Resolving variable decl GL_UNSIGNED_INT_VEC2_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_VEC3 : GLenum
Resolving variable decl GL_UNSIGNED_INT_VEC3_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INT_VEC4 : GLenum
Resolving variable decl GL_UNSIGNED_INT_VEC4_EXT : GLenum
Resolving variable decl GL_UNSIGNED_INVERT_NV : GLenum
Resolving variable decl GL_UNSIGNED_NORMALIZED : GLenum
Resolving variable decl GL_UNSIGNED_NORMALIZED_ARB : GLenum
Resolving variable decl GL_UNSIGNED_SHORT : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_1_5_5_5_REV : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_4_4_4_4 : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_4_4_4_4_EXT : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_4_4_4_4_REV : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_5_5_5_1 : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_5_5_5_1_EXT : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_5_6_5 : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_5_6_5_REV : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_8_8_APPLE : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_8_8_MESA : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_8_8_REV_APPLE : GLenum
Resolving variable decl GL_UNSIGNED_SHORT_8_8_REV_MESA : GLenum
Resolving variable decl GL_UPPER_LEFT : GLenum
Resolving variable decl GL_V2F : GLenum
Resolving variable decl GL_V3F : GLenum
Resolving variable decl GL_VALIDATE_STATUS : GLenum
Resolving variable decl GL_VARIABLE_A_NV : GLenum
Resolving variable decl GL_VARIABLE_B_NV : GLenum
Resolving variable decl GL_VARIABLE_C_NV : GLenum
Resolving variable decl GL_VARIABLE_D_NV : GLenum
Resolving variable decl GL_VARIABLE_E_NV : GLenum
Resolving variable decl GL_VARIABLE_F_NV : GLenum
Resolving variable decl GL_VARIABLE_G_NV : GLenum
Resolving variable decl GL_VARIANT_ARRAY_EXT : GLenum
Resolving variable decl GL_VARIANT_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_VARIANT_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_VARIANT_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_VARIANT_DATATYPE_EXT : GLenum
Resolving variable decl GL_VARIANT_EXT : GLenum
Resolving variable decl GL_VARIANT_VALUE_EXT : GLenum
Resolving variable decl GL_VECTOR_EXT : GLenum
Resolving variable decl GL_VENDOR : GLenum
Resolving variable decl GL_VERSION : GLenum
Resolving variable decl GL_VERSION_1_1 : GLenum
Resolving variable decl GL_VERSION_1_2 : GLenum
Resolving variable decl GL_VERSION_1_3 : GLenum
Resolving variable decl GL_VERSION_1_4 : GLenum
Resolving variable decl GL_VERSION_1_5 : GLenum
Resolving variable decl GL_VERSION_2_0 : GLenum
Resolving variable decl GL_VERSION_2_1 : GLenum
Resolving variable decl GL_VERSION_3_0 : GLenum
Resolving variable decl GL_VERTEX23_BIT_PGI : GLenum
Resolving variable decl GL_VERTEX4_BIT_PGI : GLenum
Resolving variable decl GL_VERTEX_ARRAY : GLenum
Resolving variable decl GL_VERTEX_ARRAY_BINDING : GLenum
Resolving variable decl GL_VERTEX_ARRAY_BINDING_APPLE : GLenum
Resolving variable decl GL_VERTEX_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_VERTEX_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_VERTEX_ARRAY_COUNT_EXT : GLenum
Resolving variable decl GL_VERTEX_ARRAY_EXT : GLenum
Resolving variable decl GL_VERTEX_ARRAY_LIST_IBM : GLenum
Resolving variable decl GL_VERTEX_ARRAY_LIST_STRIDE_IBM : GLenum
Resolving variable decl GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL : GLenum
Resolving variable decl GL_VERTEX_ARRAY_POINTER : GLenum
Resolving variable decl GL_VERTEX_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_VERTEX_ARRAY_RANGE_APPLE : GLenum
Resolving variable decl GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE : GLenum
Resolving variable decl GL_VERTEX_ARRAY_RANGE_LENGTH_NV : GLenum
Resolving variable decl GL_VERTEX_ARRAY_RANGE_NV : GLenum
Resolving variable decl GL_VERTEX_ARRAY_RANGE_POINTER_APPLE : GLenum
Resolving variable decl GL_VERTEX_ARRAY_RANGE_POINTER_NV : GLenum
Resolving variable decl GL_VERTEX_ARRAY_RANGE_VALID_NV : GLenum
Resolving variable decl GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV : GLenum
Resolving variable decl GL_VERTEX_ARRAY_SIZE : GLenum
Resolving variable decl GL_VERTEX_ARRAY_SIZE_EXT : GLenum
Resolving variable decl GL_VERTEX_ARRAY_STORAGE_HINT_APPLE : GLenum
Resolving variable decl GL_VERTEX_ARRAY_STRIDE : GLenum
Resolving variable decl GL_VERTEX_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_VERTEX_ARRAY_TYPE : GLenum
Resolving variable decl GL_VERTEX_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY0_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY10_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY11_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY12_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY13_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY14_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY15_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY1_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY2_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY3_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY4_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY5_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY6_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY7_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY8_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY9_NV : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_ENABLED : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_INTEGER : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_NORMALIZED : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_POINTER : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_SIZE : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_STRIDE : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_TYPE : GLenum
Resolving variable decl GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB : GLenum
Resolving variable decl GL_VERTEX_BLEND_ARB : GLenum
Resolving variable decl GL_VERTEX_CONSISTENT_HINT_PGI : GLenum
Resolving variable decl GL_VERTEX_DATA_HINT_PGI : GLenum
Resolving variable decl GL_VERTEX_ID_NV : GLenum
Resolving variable decl GL_VERTEX_PRECLIP_HINT_SGIX : GLenum
Resolving variable decl GL_VERTEX_PRECLIP_SGIX : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_ARB : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_BINDING_NV : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_NV : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_POINT_SIZE : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_POINT_SIZE_ARB : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_POINT_SIZE_NV : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_TWO_SIDE : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_TWO_SIDE_ARB : GLenum
Resolving variable decl GL_VERTEX_PROGRAM_TWO_SIDE_NV : GLenum
Resolving variable decl GL_VERTEX_SHADER : GLenum
Resolving variable decl GL_VERTEX_SHADER_ARB : GLenum
Resolving variable decl GL_VERTEX_SHADER_BINDING_EXT : GLenum
Resolving variable decl GL_VERTEX_SHADER_EXT : GLenum
Resolving variable decl GL_VERTEX_SHADER_INSTRUCTIONS_EXT : GLenum
Resolving variable decl GL_VERTEX_SHADER_INVARIANTS_EXT : GLenum
Resolving variable decl GL_VERTEX_SHADER_LOCALS_EXT : GLenum
Resolving variable decl GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT : GLenum
Resolving variable decl GL_VERTEX_SHADER_OPTIMIZED_EXT : GLenum
Resolving variable decl GL_VERTEX_SHADER_VARIANTS_EXT : GLenum
Resolving variable decl GL_VERTEX_SOURCE_ATI : GLenum
Resolving variable decl GL_VERTEX_STATE_PROGRAM_NV : GLenum
Resolving variable decl GL_VERTEX_STREAM0_ATI : GLenum
Resolving variable decl GL_VERTEX_STREAM1_ATI : GLenum
Resolving variable decl GL_VERTEX_STREAM2_ATI : GLenum
Resolving variable decl GL_VERTEX_STREAM3_ATI : GLenum
Resolving variable decl GL_VERTEX_STREAM4_ATI : GLenum
Resolving variable decl GL_VERTEX_STREAM5_ATI : GLenum
Resolving variable decl GL_VERTEX_STREAM6_ATI : GLenum
Resolving variable decl GL_VERTEX_STREAM7_ATI : GLenum
Resolving variable decl GL_VERTEX_WEIGHTING_EXT : GLenum
Resolving variable decl GL_VERTEX_WEIGHT_ARRAY_EXT : GLenum
Resolving variable decl GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT : GLenum
Resolving variable decl GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT : GLenum
Resolving variable decl GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT : GLenum
Resolving variable decl GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT : GLenum
Resolving variable decl GL_VIBRANCE_BIAS_NV : GLenum
Resolving variable decl GL_VIBRANCE_SCALE_NV : GLenum
Resolving variable decl GL_VIEWPORT : GLenum
Resolving variable decl GL_VIEWPORT_BIT : GLenum
Resolving variable decl GL_WEIGHT_ARRAY_ARB : GLenum
Resolving variable decl GL_WEIGHT_ARRAY_BUFFER_BINDING : GLenum
Resolving variable decl GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB : GLenum
Resolving variable decl GL_WEIGHT_ARRAY_POINTER_ARB : GLenum
Resolving variable decl GL_WEIGHT_ARRAY_SIZE_ARB : GLenum
Resolving variable decl GL_WEIGHT_ARRAY_STRIDE_ARB : GLenum
Resolving variable decl GL_WEIGHT_ARRAY_TYPE_ARB : GLenum
Resolving variable decl GL_WEIGHT_SUM_UNITY_ARB : GLenum
Resolving variable decl GL_WIDE_LINE_HINT_PGI : GLenum
Resolving variable decl GL_WRAP_BORDER : GLenum
Resolving variable decl GL_WRAP_BORDER_SUN : GLenum
Resolving variable decl GL_WRITE_ONLY : GLenum
Resolving variable decl GL_WRITE_ONLY_ARB : GLenum
Resolving variable decl GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV : GLenum
Resolving variable decl GL_WRITE_PIXEL_DATA_RANGE_NV : GLenum
Resolving variable decl GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV : GLenum
Resolving variable decl GL_W_EXT : GLenum
Resolving variable decl GL_XOR : GLenum
Resolving variable decl GL_X_EXT : GLenum
Resolving variable decl GL_YCBCR_422_APPLE : GLenum
Resolving variable decl GL_YCBCR_MESA : GLenum
Resolving variable decl GL_Y_EXT : GLenum
Resolving variable decl GL_ZERO : GLenum
Resolving variable decl GL_ZERO_EXT : GLenum
Resolving variable decl GL_ZOOM_X : GLenum
Resolving variable decl GL_ZOOM_Y : GLenum
Resolving variable decl GL_Z_EXT : GLenum
====== Resolving type decl CoverDecl GLenum
====== Resolving type decl ClassDecl GLenumClass
     - type unsigned int still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLenumClass
====== Resolving type decl CoverDecl GLbitfield
====== Resolving type decl ClassDecl GLbitfieldClass
     - type unsigned int still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLbitfieldClass
====== Resolving type decl CoverDecl GLuint
====== Resolving type decl ClassDecl GLuintClass
     - type unsigned int still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLuintClass
====== Resolving type decl CoverDecl GLint
====== Resolving type decl ClassDecl GLintClass
     - type int still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLintClass
====== Resolving type decl CoverDecl GLsizei
====== Resolving type decl ClassDecl GLsizeiClass
     - type int still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLsizeiClass
====== Resolving type decl CoverDecl GLboolean
====== Resolving type decl ClassDecl GLbooleanClass
     - type unsigned char still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLbooleanClass
====== Resolving type decl CoverDecl GLbyte
====== Resolving type decl ClassDecl GLbyteClass
     - type signed char still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLbyteClass
====== Resolving type decl CoverDecl GLshort
====== Resolving type decl ClassDecl GLshortClass
     - type short still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLshortClass
====== Resolving type decl CoverDecl GLubyte
====== Resolving type decl ClassDecl GLubyteClass
     - type unsigned char still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLubyteClass
====== Resolving type decl CoverDecl GLushort
====== Resolving type decl ClassDecl GLushortClass
     - type unsigned short still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLushortClass
====== Resolving type decl CoverDecl GLulong
====== Resolving type decl ClassDecl GLulongClass
     - type unsigned long still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLulongClass
====== Resolving type decl CoverDecl GLfloat
====== Resolving type decl ClassDecl GLfloatClass
     - type float still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLfloatClass
====== Resolving type decl CoverDecl GLclampf
====== Resolving type decl ClassDecl GLclampfClass
     - type float still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLclampfClass
====== Resolving type decl CoverDecl GLdouble
====== Resolving type decl ClassDecl GLdoubleClass
     - type double still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLdoubleClass
====== Resolving type decl CoverDecl GLclampd
====== Resolving type decl ClassDecl GLclampdClass
     - type double still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLclampdClass
====== Resolving type decl CoverDecl GLvoid
====== Resolving type decl ClassDecl GLvoidClass
     - type void still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLvoidClass
====== Resolving type decl CoverDecl GLint64EXT
====== Resolving type decl ClassDecl GLint64EXTClass
     - type long long still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLint64EXTClass
====== Resolving type decl CoverDecl GLuint64EXT
====== Resolving type decl ClassDecl GLuint64EXTClass
     - type unsigned long long still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLuint64EXTClass
====== Resolving type decl CoverDecl GLhalf
====== Resolving type decl ClassDecl GLhalfClass
     - type unsigned short still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLhalfClass
====== Resolving type decl CoverDecl GLcharARB
====== Resolving type decl ClassDecl GLcharARBClass
     - type char still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLcharARBClass
====== Resolving type decl CoverDecl GLhandleARB
====== Resolving type decl ClassDecl GLhandleARBClass
     - type unsigned int still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLhandleARBClass
====== Resolving type decl CoverDecl GLchar
====== Resolving type decl ClassDecl GLcharClass
     - type char still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLcharClass
====== Resolving type decl CoverDecl GLsizeiptrARB
====== Resolving type decl ClassDecl GLsizeiptrARBClass
     - type ptrdiff_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLsizeiptrARBClass
====== Resolving type decl CoverDecl GLintptrARB
====== Resolving type decl ClassDecl GLintptrARBClass
     - type ptrdiff_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLintptrARBClass
====== Resolving type decl CoverDecl GLsizeiptr
====== Resolving type decl ClassDecl GLsizeiptrClass
     - type ptrdiff_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLsizeiptrClass
====== Resolving type decl CoverDecl GLintptr
====== Resolving type decl ClassDecl GLintptrClass
     - type ptrdiff_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl GLintptrClass
Resolving variable decl v : GLhalf*
Resolving variable decl index : GLuint
Resolving variable decl v : GLint*
Resolving variable decl p : GLfloat*
Resolving variable decl tc : GLfloat*
Resolving variable decl c : GLfloat*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLuint*
Resolving variable decl programObj : GLhandleARB
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl face : GLenum
Resolving variable decl sfail : GLenum
Resolving variable decl dpfail : GLenum
Resolving variable decl dppass : GLenum
Resolving variable decl n : GLsizei
Resolving variable decl arrays : GLuint*
Resolving variable decl matrixMode : GLenum
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl red : GLbyte
Resolving variable decl green : GLbyte
Resolving variable decl blue : GLbyte
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl type : GLenum
Resolving variable decl ustride : GLsizei
Resolving variable decl vstride : GLsizei
Resolving variable decl uorder : GLint
Resolving variable decl vorder : GLint
Resolving variable decl packed : GLboolean
Resolving variable decl points : Void*
Resolving variable decl size : GLsizei
Resolving variable decl buffer : GLuint*
Resolving variable decl n : GLsizei
Resolving variable decl textures : GLuint*
Resolving variable decl residences : GLboolean*
Resolving variable decl target : GLenum
Resolving variable decl reset : GLboolean
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl values : Void*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl p : GLdouble*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl xorig : GLfloat
Resolving variable decl yorig : GLfloat
Resolving variable decl xmove : GLfloat
Resolving variable decl ymove : GLfloat
Resolving variable decl bitmap : GLubyte*
Resolving variable decl x1 : GLshort
Resolving variable decl y1 : GLshort
Resolving variable decl x2 : GLshort
Resolving variable decl y2 : GLshort
Resolving variable decl target : GLenum
Resolving variable decl coverageSamples : GLsizei
Resolving variable decl colorSamples : GLsizei
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl red : GLdouble
Resolving variable decl green : GLdouble
Resolving variable decl blue : GLdouble
Resolving variable decl p : GLdouble*
Resolving variable decl face : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl red : GLfloat
Resolving variable decl green : GLfloat
Resolving variable decl blue : GLfloat
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl target : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl g : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl a : GLfloat
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl buffer : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl arg0 : GLint
Resolving variable decl arg1 : GLsizei
Resolving variable decl arg2 : GLuint*
Resolving variable decl framebuffer : GLuint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl renderbuffer : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl red : GLint
Resolving variable decl green : GLint
Resolving variable decl blue : GLint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl n : GLsizei
Resolving variable decl textures : GLuint*
Resolving variable decl residences : GLboolean*
Resolving variable decl arg0 : GLuint
Resolving variable decl target : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl internalformat : GLenum
Resolving variable decl sink : GLboolean
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl w : GLint
Resolving variable decl mask : GLubyte*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl stage : GLenum
Resolving variable decl portion : GLenum
Resolving variable decl variable : GLenum
Resolving variable decl input : GLenum
Resolving variable decl mapping : GLenum
Resolving variable decl componentUsage : GLenum
Resolving variable decl index : GLuint
Resolving variable decl v : GLhalf*
Resolving variable decl v : GLubyte*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl mask : GLbitfield
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLuint*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl s : GLhalf
Resolving variable decl t : GLhalf
Resolving variable decl r : GLhalf
Resolving variable decl q : GLhalf
Resolving variable decl object : GLenum
Resolving variable decl name : GLint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint*
Resolving variable decl array : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl num : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl r : GLubyte
Resolving variable decl g : GLubyte
Resolving variable decl b : GLubyte
Resolving variable decl a : GLubyte
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl fence : GLuint
Resolving variable decl p : GLshort*
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl u : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl v : GLbyte*
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLintptr
Resolving variable decl size : GLsizeiptr
Resolving variable decl data : Void*
Resolving variable decl rc : GLuint*
Resolving variable decl tc : GLfloat*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl address : GLuint
Resolving variable decl matrix : GLenum
Resolving variable decl transform : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl id : GLuint
Resolving variable decl len : GLsizei
Resolving variable decl program : GLubyte*
Resolving variable decl v : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl v : GLubyte*
Resolving variable decl u : GLfloat
Resolving variable decl red : GLshort
Resolving variable decl green : GLshort
Resolving variable decl blue : GLshort
Resolving variable decl buffer : GLuint
Resolving variable decl cap : GLenum
Resolving variable decl u : GLdouble*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl id : GLuint
Resolving variable decl shader : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl p : GLint*
Resolving variable decl index : GLuint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl normalized : GLboolean
Resolving variable decl stride : GLsizei
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLuint
Resolving variable decl id : GLuint
Resolving variable decl addr : GLshort*
Resolving variable decl buffer : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl p : GLint*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLdouble*
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl frontfunc : GLenum
Resolving variable decl backfunc : GLenum
Resolving variable decl ref : GLint
Resolving variable decl mask : GLuint
Resolving variable decl marker : GLuint
Resolving variable decl mask : GLuint
Resolving variable decl sfactorRGB : GLenum
Resolving variable decl dfactorRGB : GLenum
Resolving variable decl sfactorAlpha : GLenum
Resolving variable decl dfactorAlpha : GLenum
Resolving variable decl stream : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl c : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl points : GLfloat*
Resolving variable decl face : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl framebuffer : GLuint
Resolving variable decl mode : GLenum
Resolving variable decl id : GLuint
Resolving variable decl len : GLsizei
Resolving variable decl name : GLubyte*
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl p : GLfloat*
Resolving variable decl rc : GLuint*
Resolving variable decl tc : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl obj : GLhandleARB
Resolving variable decl maxLength : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl infoLog : GLcharARB*
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl v : GLdouble*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl red : GLuint
Resolving variable decl green : GLuint
Resolving variable decl blue : GLuint
Resolving variable decl alpha : GLuint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl params : GLuint*
Resolving variable decl id : GLuint
Resolving variable decl code : GLubyte
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLuint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLushort*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl type : GLenum
Resolving variable decl pointer : Void**
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl n : GLsizei
Resolving variable decl fences : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl opcode : GLenum
Resolving variable decl array : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl index : GLuint
Resolving variable decl v : GLhalf*
Resolving variable decl target : GLenum
Resolving variable decl offset : GLintptr
Resolving variable decl size : GLsizeiptr
Resolving variable decl target : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl q : GLfloat
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLushort*
Resolving variable decl v : GLhalf*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl index : GLuint
Resolving variable decl x : GLhalf
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl image : Void*
Resolving variable decl shader : GLuint
Resolving variable decl bufSize : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl infoLog : GLchar*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl row : GLvoid*
Resolving variable decl column : GLvoid*
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl op : GLenum
Resolving variable decl value : GLfloat
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl video_slot : GLuint
Resolving variable decl minPresentTime : GLuint64EXT
Resolving variable decl beginPresentTimeId : GLuint
Resolving variable decl presentDurationId : GLuint
Resolving variable decl type : GLenum
Resolving variable decl target0 : GLenum
Resolving variable decl fill0 : GLuint
Resolving variable decl target1 : GLenum
Resolving variable decl fill1 : GLuint
Resolving variable decl target2 : GLenum
Resolving variable decl fill2 : GLuint
Resolving variable decl target3 : GLenum
Resolving variable decl fill3 : GLuint
Resolving variable decl region : GLenum
Resolving variable decl n : GLsizei
Resolving variable decl framebuffers : GLuint*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl shaderObj : GLhandleARB
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl id : GLuint
Resolving variable decl len : GLsizei
Resolving variable decl name : GLubyte*
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl red : GLuint
Resolving variable decl green : GLuint
Resolving variable decl blue : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl id : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl v : GLuint*
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl arg0 : GLint
Resolving variable decl arg1 : GLsizei
Resolving variable decl arg2 : GLuint*
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl size : GLint
Resolving variable decl weights : GLshort*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl array : GLuint
Resolving variable decl target : GLenum
Resolving variable decl v : GLhalf*
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl framebuffer : GLuint
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl region : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl xDest : GLint
Resolving variable decl yDest : GLint
Resolving variable decl modeRGB : GLenum
Resolving variable decl modeAlpha : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl r : GLdouble
Resolving variable decl q : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl array : GLenum
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl v2 : GLfloat
Resolving variable decl arg0 : GLint
Resolving variable decl arg1 : GLsizei
Resolving variable decl arg2 : GLuint*
Resolving variable decl r : GLfloat
Resolving variable decl g : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl v : GLhalf*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : GLvoid*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLint*
Resolving variable decl index : GLuint
Resolving variable decl x : GLubyte
Resolving variable decl y : GLubyte
Resolving variable decl z : GLubyte
Resolving variable decl w : GLubyte
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl q : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl v : GLint*
Resolving variable decl v : GLint*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl num : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl value : GLclampf
Resolving variable decl invert : GLboolean
Resolving variable decl target : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl index : GLuint
Resolving variable decl x : GLubyte
Resolving variable decl y : GLubyte
Resolving variable decl z : GLubyte
Resolving variable decl w : GLubyte
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl r : GLint
Resolving variable decl q : GLint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl texture : GLenum
Resolving variable decl range : GLsizei
Resolving variable decl mode : GLenum
Resolving variable decl start : GLuint
Resolving variable decl end : GLuint
Resolving variable decl first : GLint
Resolving variable decl count : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl n : GLsizei
Resolving variable decl textures : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl access : GLenum
Resolving variable decl programObj : GLhandleARB
Resolving variable decl name : GLcharARB*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLuint
Resolving variable decl v1 : GLuint
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v : GLdouble*
Resolving variable decl red : GLhalf
Resolving variable decl green : GLhalf
Resolving variable decl blue : GLhalf
Resolving variable decl v : GLint*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl table : GLvoid*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl v2 : GLfloat
Resolving variable decl v3 : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl tc : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl m : GLdouble*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl fence : GLuint
Resolving variable decl condition : GLenum
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl r : GLshort
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLvoid**
Resolving variable decl buf : GLuint
Resolving variable decl r : GLboolean
Resolving variable decl g : GLboolean
Resolving variable decl b : GLboolean
Resolving variable decl a : GLboolean
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl filter : GLenum
Resolving variable decl weights : GLfloat*
Resolving variable decl texunit : GLenum
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl target : GLenum
Resolving variable decl s : GLhalf
Resolving variable decl t : GLhalf
Resolving variable decl video_slot : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl tc : GLfloat*
Resolving variable decl c : GLfloat*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl start : GLsizei
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl op : GLenum
Resolving variable decl dst : GLuint
Resolving variable decl dstMod : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg1Rep : GLuint
Resolving variable decl arg1Mod : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg2Rep : GLuint
Resolving variable decl arg2Mod : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl obj : GLhandleARB
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl img : Void*
Resolving variable decl flag : GLboolean*
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl r : GLshort
Resolving variable decl q : GLshort
Resolving variable decl p : GLdouble*
Resolving variable decl length : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl v : GLfloat*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl p : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl s : GLhalf
Resolving variable decl t : GLhalf
Resolving variable decl r : GLhalf
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl count : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl op : GLenum
Resolving variable decl dst : GLuint
Resolving variable decl dstMod : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg1Rep : GLuint
Resolving variable decl arg1Mod : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg2Rep : GLuint
Resolving variable decl arg2Mod : GLuint
Resolving variable decl arg3 : GLuint
Resolving variable decl arg3Rep : GLuint
Resolving variable decl arg3Mod : GLuint
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl internalFormat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl data : Void*
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl row : GLvoid*
Resolving variable decl column : GLvoid*
Resolving variable decl span : GLvoid*
Resolving variable decl index : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl plane : GLenum
Resolving variable decl equation : GLfloat*
Resolving variable decl id : GLuint
Resolving variable decl addr : GLbyte*
Resolving variable decl n : GLsizei
Resolving variable decl fences : GLuint*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl size : GLfloat
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl shader : GLuint
Resolving variable decl red : GLushort
Resolving variable decl green : GLushort
Resolving variable decl blue : GLushort
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl framebuffer : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl bufs : GLenum*
Resolving variable decl op : GLenum
Resolving variable decl dst : GLuint
Resolving variable decl dstMask : GLuint
Resolving variable decl dstMod : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg1Rep : GLuint
Resolving variable decl arg1Mod : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg2Rep : GLuint
Resolving variable decl arg2Mod : GLuint
Resolving variable decl arg3 : GLuint
Resolving variable decl arg3Rep : GLuint
Resolving variable decl arg3Mod : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLushort*
Resolving variable decl c : GLfloat
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl fence : GLuint
Resolving variable decl buffer : GLuint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl mode : GLenum
Resolving variable decl first : GLint
Resolving variable decl count : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat
Resolving variable decl mode : GLenum
Resolving variable decl start : GLuint
Resolving variable decl end : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl type : GLenum
Resolving variable decl indices : GLvoid*
Resolving variable decl index : GLuint
Resolving variable decl x : GLhalf
Resolving variable decl y : GLhalf
Resolving variable decl z : GLhalf
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalFormat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl map : GLenum
Resolving variable decl mapsize : GLsizei
Resolving variable decl values : GLushort*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl params : GLint*
Resolving variable decl array : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl variable : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl w : GLshort
Resolving variable decl target : GLenum
Resolving variable decl offset : GLintptrARB
Resolving variable decl size : GLsizeiptrARB
Resolving variable decl data : GLvoid*
Resolving variable decl id : GLuint
Resolving variable decl v : GLushort*
Resolving variable decl index : GLuint
Resolving variable decl x : GLhalf
Resolving variable decl y : GLhalf
Resolving variable decl z : GLhalf
Resolving variable decl w : GLhalf
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl weight : GLhalf*
Resolving variable decl program : GLuint
Resolving variable decl name : GLchar*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl buffer : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLuint
Resolving variable decl y : GLuint
Resolving variable decl z : GLuint
Resolving variable decl w : GLuint
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl access : GLenum
Resolving variable decl target : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLenum
Resolving variable decl arg3 : GLsizei
Resolving variable decl arg4 : GLvoid*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLshort*
Resolving variable decl depth : GLclampd
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLint
Resolving variable decl arg3 : GLint
Resolving variable decl arg4 : GLint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl programObj : GLhandleARB
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl count : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl n : GLsizei
Resolving variable decl fences : GLuint*
Resolving variable decl obj : GLhandleARB
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl w : GLshort
Resolving variable decl v : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl v : GLubyte*
Resolving variable decl v : GLubyte*
Resolving variable decl s : GLhalf
Resolving variable decl t : GLhalf
Resolving variable decl r : GLhalf
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl v : GLubyte*
Resolving variable decl rc : GLuint*
Resolving variable decl tc : GLfloat*
Resolving variable decl c : GLfloat*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl list : GLuint
Resolving variable decl index : GLuint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl image : Void*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl v2 : GLint
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl p : GLint*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl layer : GLint
Resolving variable decl array : GLenum
Resolving variable decl index : GLuint
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl data : Void*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl plane : GLenum
Resolving variable decl equation : GLfloat*
Resolving variable decl primitiveMode : GLenum
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLuint*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl index : GLuint
Resolving variable decl v : GLint*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl programObj : GLhandleARB
Resolving variable decl v : GLbyte*
Resolving variable decl m : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl image : GLvoid*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLuint
Resolving variable decl v1 : GLuint
Resolving variable decl v2 : GLuint
Resolving variable decl program : GLuint
Resolving variable decl array : GLenum
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl red : GLubyte
Resolving variable decl green : GLubyte
Resolving variable decl blue : GLubyte
Resolving variable decl length : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl target : GLenum
Resolving variable decl v : GLhalf*
Resolving variable decl framebuffer : GLuint
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl layer : GLint
Resolving variable decl rc : GLuint*
Resolving variable decl v : GLfloat*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl len : GLsizei
Resolving variable decl string : Void*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLuint
Resolving variable decl stage : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl mode : GLenum*
Resolving variable decl count : GLsizei*
Resolving variable decl type : GLenum
Resolving variable decl indices : GLvoid**
Resolving variable decl primcount : GLsizei
Resolving variable decl modestride : GLint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl v2 : GLfloat
Resolving variable decl v3 : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl internalformat : GLenum
Resolving variable decl sink : GLboolean
Resolving variable decl region : GLenum
Resolving variable decl zNear : GLclampd
Resolving variable decl zFar : GLclampd
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl red : GLuint
Resolving variable decl green : GLuint
Resolving variable decl blue : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl programObj : GLhandleARB
Resolving variable decl index : GLuint
Resolving variable decl maxLength : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl size : GLint*
Resolving variable decl type : GLenum*
Resolving variable decl name : GLcharARB*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLint*
Resolving variable decl id : GLuint
Resolving variable decl cap : GLenum
Resolving variable decl frontfunc : GLenum
Resolving variable decl backfunc : GLenum
Resolving variable decl ref : GLint
Resolving variable decl mask : GLuint
Resolving variable decl coord : GLfloat*
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLdouble
Resolving variable decl video_slot : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint64EXT*
Resolving variable decl video_slot : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl matrixMode : GLenum
Resolving variable decl m : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl v : GLubyte*
Resolving variable decl texture : GLenum
Resolving variable decl framebuffer : GLuint
Resolving variable decl target : GLenum
Resolving variable decl flag : GLboolean
Resolving variable decl n : GLsizei
Resolving variable decl framebuffers : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLintptr
Resolving variable decl size : GLsizeiptr
Resolving variable decl target : GLenum
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl r : GLshort
Resolving variable decl q : GLshort
Resolving variable decl un : GLint
Resolving variable decl u1 : GLdouble
Resolving variable decl u2 : GLdouble
Resolving variable decl vn : GLint
Resolving variable decl v1 : GLdouble
Resolving variable decl v2 : GLdouble
Resolving variable decl size : GLint
Resolving variable decl weights : GLubyte*
Resolving variable decl obj : GLhandleARB
Resolving variable decl maxLength : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl source : GLcharARB*
Resolving variable decl target : GLenum
Resolving variable decl stream : GLenum
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLuint*
Resolving variable decl un : GLint
Resolving variable decl u1 : GLfloat
Resolving variable decl u2 : GLfloat
Resolving variable decl vn : GLint
Resolving variable decl v1 : GLfloat
Resolving variable decl v2 : GLfloat
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl id : GLuint
Resolving variable decl len : GLsizei
Resolving variable decl name : GLubyte*
Resolving variable decl v : GLdouble*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl target : GLenum
Resolving variable decl samples : GLsizei
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl v2 : GLfloat
Resolving variable decl red : GLushort
Resolving variable decl green : GLushort
Resolving variable decl blue : GLushort
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl _func : GLenum
Resolving variable decl ref : GLclampf
Resolving variable decl coord : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl v : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl v : GLubyte*
Resolving variable decl n : GLsizei
Resolving variable decl points : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v : GLhalf*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint*
Resolving variable decl red : GLdouble
Resolving variable decl green : GLdouble
Resolving variable decl blue : GLdouble
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl renderbuffer : GLuint
Resolving variable decl stream : GLenum
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl count : GLuint
Resolving variable decl attribs : GLint*
Resolving variable decl bufferMode : GLenum
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl p : GLshort*
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl r : GLdouble
Resolving variable decl depth : GLclampd
Resolving variable decl nx : GLhalf
Resolving variable decl ny : GLhalf
Resolving variable decl nz : GLhalf
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl id : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl extent : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl length : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl face : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl mode : GLenum
Resolving variable decl target : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl r : GLint
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLhalf*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl program : GLuint
Resolving variable decl maxCount : GLsizei
Resolving variable decl count : GLsizei*
Resolving variable decl shaders : GLuint*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLint*
Resolving variable decl array : GLuint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl c : GLint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl id : GLuint
Resolving variable decl u : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLint
Resolving variable decl pointer : GLvoid**
Resolving variable decl ptrstride : GLint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl renderbuffer : GLuint
Resolving variable decl target : GLenum
Resolving variable decl s : GLhalf
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl v : GLint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint*
Resolving variable decl arg0 : GLint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl fail : GLenum
Resolving variable decl zfail : GLenum
Resolving variable decl zpass : GLenum
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl r : GLshort
Resolving variable decl target : GLenum
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLfloat*
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl count : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl r : GLdouble
Resolving variable decl q : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl image : Void*
Resolving variable decl matrixMode : GLenum
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl id : GLuint
Resolving variable decl addr : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl q : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl v2 : GLint
Resolving variable decl v3 : GLint
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl row : Void*
Resolving variable decl column : Void*
Resolving variable decl span : Void*
Resolving variable decl program : GLuint
Resolving variable decl bufSize : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl infoLog : GLchar*
Resolving variable decl mask : GLbitfield
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl factor : GLushort
Resolving variable decl v : GLshort*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl pname : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg3 : GLintptr
Resolving variable decl arg4 : GLsizeiptr
Resolving variable decl program : GLuint
Resolving variable decl name : GLchar*
Resolving variable decl matrixMode : GLenum
Resolving variable decl angle : GLdouble
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl r : GLint
Resolving variable decl q : GLint
Resolving variable decl res : GLuint
Resolving variable decl in : GLuint
Resolving variable decl outX : GLenum
Resolving variable decl outY : GLenum
Resolving variable decl outZ : GLenum
Resolving variable decl outW : GLenum
Resolving variable decl target : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLsizei
Resolving variable decl arg2 : GLint*
Resolving variable decl arg3 : GLenum
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl program : GLuint
Resolving variable decl index : GLuint
Resolving variable decl location : GLint*
Resolving variable decl r : GLubyte
Resolving variable decl g : GLubyte
Resolving variable decl b : GLubyte
Resolving variable decl a : GLubyte
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v : GLshort*
Resolving variable decl factor : GLfloat
Resolving variable decl units : GLfloat
Resolving variable decl coord : GLfloat
Resolving variable decl mode : GLenum
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl code : GLushort
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl red : GLboolean
Resolving variable decl green : GLboolean
Resolving variable decl blue : GLboolean
Resolving variable decl alpha : GLboolean
Resolving variable decl index : GLuint
Resolving variable decl x : GLhalf
Resolving variable decl y : GLhalf
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl target : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl shader : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl strings : GLchar**
Resolving variable decl lengths : GLint*
Resolving variable decl mode : GLenum
Resolving variable decl first : GLint*
Resolving variable decl count : GLsizei*
Resolving variable decl primcount : GLsizei
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl v : GLint*
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl target : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl red : GLbyte
Resolving variable decl green : GLbyte
Resolving variable decl blue : GLbyte
Resolving variable decl alpha : GLbyte
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl p : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl w : GLshort
Resolving variable decl c : GLubyte*
Resolving variable decl red : GLdouble
Resolving variable decl green : GLdouble
Resolving variable decl blue : GLdouble
Resolving variable decl alpha : GLdouble
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl r : GLshort
Resolving variable decl q : GLshort
Resolving variable decl region : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl v : GLfloat*
Resolving variable decl face : GLenum
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl red : GLfloat
Resolving variable decl green : GLfloat
Resolving variable decl blue : GLfloat
Resolving variable decl alpha : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLint
Resolving variable decl arg3 : GLint
Resolving variable decl v : GLfloat*
Resolving variable decl cap : GLenum
Resolving variable decl v : GLushort*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl type : GLenum
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint*
Resolving variable decl red : GLint
Resolving variable decl green : GLint
Resolving variable decl blue : GLint
Resolving variable decl alpha : GLint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLuint*
Resolving variable decl flag : GLboolean
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl first : GLint
Resolving variable decl count : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : GLvoid*
Resolving variable decl p : GLint*
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl n : GLsizei
Resolving variable decl textures : GLuint*
Resolving variable decl v : GLdouble*
Resolving variable decl dataType : GLenum
Resolving variable decl storageType : GLenum
Resolving variable decl range : GLenum
Resolving variable decl components : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl matrixMode : GLenum
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl v : GLint*
Resolving variable decl list : GLuint
Resolving variable decl mode : GLenum
Resolving variable decl face : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl id : GLuint
Resolving variable decl addr : GLint*
Resolving variable decl target : GLenum
Resolving variable decl s : GLshort
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl coord : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl mode : GLenum
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl coord : GLfloat
Resolving variable decl v : GLdouble*
Resolving variable decl mode : GLenum
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLint*
Resolving variable decl red : GLshort
Resolving variable decl green : GLshort
Resolving variable decl blue : GLshort
Resolving variable decl alpha : GLshort
Resolving variable decl target : GLenum
Resolving variable decl v : GLint*
Resolving variable decl stage : GLenum
Resolving variable decl portion : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl id : GLuint
Resolving variable decl addr : GLushort*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLuint*
Resolving variable decl red : GLclampf
Resolving variable decl green : GLclampf
Resolving variable decl blue : GLclampf
Resolving variable decl alpha : GLclampf
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLint*
Resolving variable decl stage : GLenum
Resolving variable decl portion : GLenum
Resolving variable decl variable : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl target : GLenum
Resolving variable decl length : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl v : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl n : GLsizei
Resolving variable decl bufs : GLenum*
Resolving variable decl program : GLuint
Resolving variable decl shader : GLuint
Resolving variable decl range : GLuint
Resolving variable decl mode : GLenum
Resolving variable decl first : GLint
Resolving variable decl count : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl residences : GLboolean*
Resolving variable decl index : GLint
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLboolean*
Resolving variable decl index : GLuint
Resolving variable decl target : GLenum
Resolving variable decl s : GLhalf
Resolving variable decl t : GLhalf
Resolving variable decl r : GLhalf
Resolving variable decl q : GLhalf
Resolving variable decl target : GLenum
Resolving variable decl points : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl normalized : GLboolean
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl c : GLubyte
Resolving variable decl stream : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl map : GLenum
Resolving variable decl values : GLuint*
Resolving variable decl p : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl woffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl extent : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl sink : GLboolean
Resolving variable decl framebuffer : GLuint
Resolving variable decl attachment : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl offset : GLintptr
Resolving variable decl size : GLsizeiptr
Resolving variable decl data : GLvoid*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl id : GLuint
Resolving variable decl v : GLbyte*
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLhalf*
Resolving variable decl program : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl locations : GLint*
Resolving variable decl bufferMode : GLenum
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint*
Resolving variable decl arg0 : GLint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg3 : GLuint
Resolving variable decl arg4 : GLuint
Resolving variable decl target : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLint*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl string : Void*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl data : GLint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLbyte*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLbyte
Resolving variable decl y : GLbyte
Resolving variable decl z : GLbyte
Resolving variable decl programObj : GLhandleARB
Resolving variable decl name : GLcharARB*
Resolving variable decl marker : GLuint
Resolving variable decl range : GLsizei
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl v : GLushort*
Resolving variable decl program : GLuint
Resolving variable decl name : GLchar*
Resolving variable decl red : GLclampf
Resolving variable decl green : GLclampf
Resolving variable decl blue : GLclampf
Resolving variable decl alpha : GLclampf
Resolving variable decl name : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl textures : GLuint*
Resolving variable decl priorities : GLclampf*
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl un : GLint
Resolving variable decl u1 : GLdouble
Resolving variable decl u2 : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl target : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl un : GLint
Resolving variable decl u1 : GLfloat
Resolving variable decl u2 : GLfloat
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl name : GLuint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalFormat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLint*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl target : GLenum
Resolving variable decl query : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl matrixMode : GLenum
Resolving variable decl m : GLdouble*
Resolving variable decl rc : GLuint*
Resolving variable decl c : GLubyte*
Resolving variable decl v : GLfloat*
Resolving variable decl red : GLbyte
Resolving variable decl green : GLbyte
Resolving variable decl blue : GLbyte
Resolving variable decl target : GLenum
Resolving variable decl v : GLint*
Resolving variable decl v1 : GLshort*
Resolving variable decl v2 : GLshort*
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl program : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl value : GLenum
Resolving variable decl v : GLint*
Resolving variable decl factor : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl w : GLshort
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl m : GLdouble*
Resolving variable decl mode : GLenum
Resolving variable decl count : GLsizei*
Resolving variable decl type : GLenum
Resolving variable decl indices : GLvoid**
Resolving variable decl primcount : GLsizei
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLfloat*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl pattern : GLenum
Resolving variable decl v : GLint*
Resolving variable decl angle : GLdouble
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl pname : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl fence : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl index : GLuint
Resolving variable decl val : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl id : GLuint
Resolving variable decl mode : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl angle : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl shaderType : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl res : GLuint
Resolving variable decl in : GLuint
Resolving variable decl outX : GLenum
Resolving variable decl outY : GLenum
Resolving variable decl outZ : GLenum
Resolving variable decl outW : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl table : Void*
Resolving variable decl program : GLuint
Resolving variable decl shader : GLuint
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl v1 : GLfloat*
Resolving variable decl v2 : GLfloat*
Resolving variable decl mode : GLenum
Resolving variable decl count : GLsizei
Resolving variable decl factor : GLshort
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl offset : GLintptr
Resolving variable decl size : GLsizeiptr
Resolving variable decl data : GLvoid*
Resolving variable decl v : GLshort*
Resolving variable decl video_slot : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v : GLint*
Resolving variable decl stage : GLenum
Resolving variable decl portion : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl id : GLuint
Resolving variable decl type : GLenum
Resolving variable decl addr : GLvoid*
Resolving variable decl id : GLuint
Resolving variable decl light : GLenum
Resolving variable decl value : GLenum
Resolving variable decl data : GLint*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLuint
Resolving variable decl y : GLuint
Resolving variable decl z : GLuint
Resolving variable decl w : GLuint
Resolving variable decl factor : GLfloat
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl c : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl shaderObj : GLhandleARB
Resolving variable decl count : GLsizei
Resolving variable decl string : GLcharARB**
Resolving variable decl length : GLint*
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl buffers : GLuint*
Resolving variable decl v : GLdouble*
Resolving variable decl rc : GLuint
Resolving variable decl r : GLfloat
Resolving variable decl g : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl stream : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl pname : GLenum
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl c : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl r : GLdouble
Resolving variable decl p : GLshort*
Resolving variable decl index : GLuint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl normalized : GLboolean
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl renderbuffer : GLuint
Resolving variable decl target : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl r : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl w : GLint
Resolving variable decl target : GLenum
Resolving variable decl c : GLint
Resolving variable decl n : GLsizei
Resolving variable decl programs : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl framebuffer : GLuint
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl stride : GLint
Resolving variable decl pointer : GLboolean**
Resolving variable decl ptrstride : GLint
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl coord : GLdouble
Resolving variable decl m : GLdouble*
Resolving variable decl m : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl r : GLint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl len : GLsizei
Resolving variable decl string : Void*
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl pointer : Void**
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLubyte
Resolving variable decl g : GLubyte
Resolving variable decl b : GLubyte
Resolving variable decl a : GLubyte
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl m : GLfloat*
Resolving variable decl m : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLfloat*
Resolving variable decl id : GLuint
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLuint
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl img : Void*
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLvoid**
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl n : GLsizei
Resolving variable decl bufs : GLenum*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLbyte*
Resolving variable decl shader : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLint*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLuint*
Resolving variable decl containerObj : GLhandleARB
Resolving variable decl attachedObj : GLhandleARB
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl table : Void*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl w : GLshort
Resolving variable decl red : GLbyte
Resolving variable decl green : GLbyte
Resolving variable decl blue : GLbyte
Resolving variable decl c : GLshort
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLuint*
Resolving variable decl mask : GLbitfield
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v : GLuint*
Resolving variable decl code : GLushort*
Resolving variable decl red : GLdouble
Resolving variable decl green : GLdouble
Resolving variable decl blue : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl x : GLuint
Resolving variable decl y : GLuint
Resolving variable decl z : GLuint
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl g : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl type : GLenum
Resolving variable decl pointer : Void*
Resolving variable decl target : GLenum
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl r : GLshort
Resolving variable decl program : GLuint
Resolving variable decl index : GLuint
Resolving variable decl bufSize : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl size : GLsizei*
Resolving variable decl type : GLenum*
Resolving variable decl name : GLchar*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl buffer : GLuint
Resolving variable decl face : GLenum
Resolving variable decl value : GLenum
Resolving variable decl red : GLfloat
Resolving variable decl green : GLfloat
Resolving variable decl blue : GLfloat
Resolving variable decl tc : GLfloat*
Resolving variable decl c : GLubyte*
Resolving variable decl v : GLfloat*
Resolving variable decl c : GLubyte*
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLint
Resolving variable decl v : GLhalf*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl red : GLint
Resolving variable decl green : GLint
Resolving variable decl blue : GLint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg3 : GLuint
Resolving variable decl arg4 : GLuint
Resolving variable decl index : GLuint
Resolving variable decl x : GLuint
Resolving variable decl target : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLuint*
Resolving variable decl p : GLshort*
Resolving variable decl zmin : GLdouble
Resolving variable decl zmax : GLdouble
Resolving variable decl id : GLuint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLuint
Resolving variable decl addr : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : GLvoid*
Resolving variable decl mode : GLenum
Resolving variable decl start : GLuint
Resolving variable decl end : GLuint
Resolving variable decl first : GLint*
Resolving variable decl count : GLsizei*
Resolving variable decl primcount : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl v : GLint*
Resolving variable decl mask : GLubyte*
Resolving variable decl v : GLbyte*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl layer : GLint
Resolving variable decl red : GLubyte
Resolving variable decl green : GLubyte
Resolving variable decl blue : GLubyte
Resolving variable decl alpha : GLubyte
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLuint
Resolving variable decl v1 : GLuint
Resolving variable decl v2 : GLuint
Resolving variable decl v3 : GLuint
Resolving variable decl target : GLenum
Resolving variable decl address : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl width : GLfloat
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl v2 : GLint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl program : GLuint
Resolving variable decl index : GLuint
Resolving variable decl maxLength : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl size : GLint*
Resolving variable decl type : GLenum*
Resolving variable decl name : GLchar*
Resolving variable decl target : GLenum
Resolving variable decl id : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl n : GLsizei
Resolving variable decl buffers : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl program : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint*
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl p : GLdouble*
Resolving variable decl red : GLint
Resolving variable decl green : GLint
Resolving variable decl blue : GLint
Resolving variable decl alpha : GLint
Resolving variable decl plane : GLenum
Resolving variable decl equation : GLdouble*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl factor : GLint
Resolving variable decl pattern : GLushort
Resolving variable decl red : GLshort
Resolving variable decl green : GLshort
Resolving variable decl blue : GLshort
Resolving variable decl framebuffer : GLuint
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl face : GLenum
Resolving variable decl n : GLsizei
Resolving variable decl renderbuffers : GLuint*
Resolving variable decl p : GLfloat*
Resolving variable decl red : GLuint
Resolving variable decl green : GLuint
Resolving variable decl blue : GLuint
Resolving variable decl alpha : GLuint
Resolving variable decl map : GLenum
Resolving variable decl values : GLfloat*
Resolving variable decl p : GLfloat*
Resolving variable decl object : GLenum
Resolving variable decl name : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl arrays : GLuint*
Resolving variable decl buffer : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : Void**
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl n : GLsizei
Resolving variable decl framebuffers : GLuint*
Resolving variable decl program : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl varyings : Char**
Resolving variable decl bufferMode : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl res : GLuint
Resolving variable decl src : GLuint
Resolving variable decl num : GLuint
Resolving variable decl rc : GLuint
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl row : Void*
Resolving variable decl column : Void*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl buffer : GLuint
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl c : GLfloat*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl mask : GLbitfield
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl divisor : GLuint
Resolving variable decl renderbuffer : GLuint
Resolving variable decl samples : GLsizei
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl mode : GLenum
Resolving variable decl x : GLhalf
Resolving variable decl y : GLhalf
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl pname : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl red : GLushort
Resolving variable decl green : GLushort
Resolving variable decl blue : GLushort
Resolving variable decl alpha : GLushort
Resolving variable decl fog : GLhalf
Resolving variable decl base : GLuint
Resolving variable decl size : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl usage : GLenum
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl programObj : GLhandleARB
Resolving variable decl index : GLuint
Resolving variable decl name : GLcharARB*
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLvoid**
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLchar*
Resolving variable decl index : GLuint
Resolving variable decl v : GLushort*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl data : GLfloat*
Resolving variable decl markerp : GLuint*
Resolving variable decl v : GLushort*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLboolean*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl rc : GLuint*
Resolving variable decl c : GLfloat*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLbyte*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl weight : GLfloat
Resolving variable decl rc : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalFormat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl v : GLushort*
Resolving variable decl coord : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLshort*
Resolving variable decl containerObj : GLhandleARB
Resolving variable decl obj : GLhandleARB
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl token : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl buffer : GLuint
Resolving variable decl fence : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLint*
Resolving variable decl matrixMode : GLenum
Resolving variable decl angle : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl mode : GLenum
Resolving variable decl first : GLint*
Resolving variable decl count : GLsizei*
Resolving variable decl primcount : GLsizei
Resolving variable decl index : GLuint
Resolving variable decl v : GLbyte*
Resolving variable decl v : GLshort*
Resolving variable decl _func : GLenum
Resolving variable decl ref : GLint
Resolving variable decl mask : GLuint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl v2 : GLfloat
Resolving variable decl v3 : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl r : GLint
Resolving variable decl q : GLint
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLboolean*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl depth : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl pointer : GLvoid**
Resolving variable decl v : GLshort*
Resolving variable decl index : GLuint
Resolving variable decl v : GLubyte*
Resolving variable decl name : GLuint
Resolving variable decl mode : GLenum*
Resolving variable decl first : GLint*
Resolving variable decl count : GLsizei*
Resolving variable decl primcount : GLsizei
Resolving variable decl modestride : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLint
Resolving variable decl pointer : GLvoid**
Resolving variable decl ptrstride : GLint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl v2 : GLint
Resolving variable decl v3 : GLint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLint*
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl pointer : GLvoid**
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl color : GLuint
Resolving variable decl name : GLchar*
Resolving variable decl s : GLdouble
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl p : GLfloat
Resolving variable decl q : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl code : GLubyte*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v : GLint*
Resolving variable decl pname : GLenum
Resolving variable decl params : GLboolean*
Resolving variable decl renderbuffer : GLuint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl s : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl mode : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLuint
Resolving variable decl size : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl preserve : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl s : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl p : GLint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl v : GLushort*
Resolving variable decl target : GLenum
Resolving variable decl limit : GLint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLfloat*
Resolving variable decl i : GLint
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl i : GLint
Resolving variable decl j : GLint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat*
Resolving variable decl m : GLdouble*
Resolving variable decl factor : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl u : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl access : GLenum
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl layer : GLint
Resolving variable decl equation : GLdouble*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl id : GLuint
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLubyte*
Resolving variable decl size : GLint
Resolving variable decl weights : GLbyte*
Resolving variable decl p : GLint*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl m : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl offset : GLintptr
Resolving variable decl length : GLsizeiptr
Resolving variable decl obj : GLint
Resolving variable decl maxLength : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl source : GLchar*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl mask : GLuint
Resolving variable decl light : GLenum
Resolving variable decl value : GLenum
Resolving variable decl data : GLfloat*
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl framebuffer : GLuint
Resolving variable decl mode : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl sink : GLboolean
Resolving variable decl s : GLshort
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLhalf*
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl factor : GLfloat
Resolving variable decl bias : GLfloat
Resolving variable decl mode : GLenum
Resolving variable decl first : GLint
Resolving variable decl count : GLsizei
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl v2 : GLint
Resolving variable decl v3 : GLint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLint
Resolving variable decl pointer : GLvoid**
Resolving variable decl ptrstride : GLint
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl u1 : GLdouble
Resolving variable decl u2 : GLdouble
Resolving variable decl ustride : GLint
Resolving variable decl uorder : GLint
Resolving variable decl v1 : GLdouble
Resolving variable decl v2 : GLdouble
Resolving variable decl vstride : GLint
Resolving variable decl vorder : GLint
Resolving variable decl points : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl renderbuffertarget : GLenum
Resolving variable decl renderbuffer : GLuint
Resolving variable decl weight : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl target : GLenum
Resolving variable decl u1 : GLfloat
Resolving variable decl u2 : GLfloat
Resolving variable decl ustride : GLint
Resolving variable decl uorder : GLint
Resolving variable decl v1 : GLfloat
Resolving variable decl v2 : GLfloat
Resolving variable decl vstride : GLint
Resolving variable decl vorder : GLint
Resolving variable decl points : GLfloat*
Resolving variable decl stage : GLenum
Resolving variable decl portion : GLenum
Resolving variable decl abOutput : GLenum
Resolving variable decl cdOutput : GLenum
Resolving variable decl sumOutput : GLenum
Resolving variable decl scale : GLenum
Resolving variable decl bias : GLenum
Resolving variable decl abDotProduct : GLboolean
Resolving variable decl cdDotProduct : GLboolean
Resolving variable decl muxSum : GLboolean
Resolving variable decl n : GLsizei
Resolving variable decl textures : GLuint*
Resolving variable decl stage : GLenum
Resolving variable decl portion : GLenum
Resolving variable decl variable : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl code : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl buffer : GLuint
Resolving variable decl size : GLsizeiptr
Resolving variable decl data : Void*
Resolving variable decl usage : GLenum
Resolving variable decl target : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl first : GLint
Resolving variable decl count : GLsizei
Resolving variable decl primcount : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl buffer : GLuint
Resolving variable decl _func : GLenum
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl target : GLenum
Resolving variable decl reset : GLboolean
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl values : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl rc : GLuint
Resolving variable decl r : GLubyte
Resolving variable decl g : GLubyte
Resolving variable decl b : GLubyte
Resolving variable decl a : GLubyte
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl stream : GLenum
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl id : GLuint
Resolving variable decl type : GLenum
Resolving variable decl addr : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLintptr
Resolving variable decl size : GLsizeiptr
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl matrixMode : GLenum
Resolving variable decl target : GLenum
Resolving variable decl start : GLsizei
Resolving variable decl count : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl data : Void*
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl target : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl lod : GLint
Resolving variable decl img : Void*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl n : GLclampf
Resolving variable decl f : GLclampf
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint*
Resolving variable decl size : GLint
Resolving variable decl weights : GLint*
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl renderbuffer : GLuint
Resolving variable decl coverageSamples : GLsizei
Resolving variable decl colorSamples : GLsizei
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl s : GLshort
Resolving variable decl t : GLshort
Resolving variable decl array : GLenum
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl v : GLdouble*
Resolving variable decl renderbuffer : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl matrixMode : GLenum
Resolving variable decl m : GLfloat*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl w : GLint
Resolving variable decl n : GLsizei
Resolving variable decl textures : GLuint*
Resolving variable decl priorities : GLclampf*
Resolving variable decl target : GLenum
Resolving variable decl lod : GLint
Resolving variable decl img : GLvoid*
Resolving variable decl code : GLuint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLfloat*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl texture : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : GLvoid*
Resolving variable decl v : GLdouble*
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl n : GLsizei
Resolving variable decl points : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLint*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint64EXT*
Resolving variable decl zNear : GLdouble
Resolving variable decl zFar : GLdouble
Resolving variable decl red : GLshort
Resolving variable decl green : GLshort
Resolving variable decl blue : GLshort
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl m : GLfloat*
Resolving variable decl array : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl buffers : GLuint*
Resolving variable decl srcX0 : GLint
Resolving variable decl srcY0 : GLint
Resolving variable decl srcX1 : GLint
Resolving variable decl srcY1 : GLint
Resolving variable decl dstX0 : GLint
Resolving variable decl dstY0 : GLint
Resolving variable decl dstX1 : GLint
Resolving variable decl dstY1 : GLint
Resolving variable decl mask : GLbitfield
Resolving variable decl filter : GLenum
Resolving variable decl n : GLsizei
Resolving variable decl fences : GLuint*
Resolving variable decl n : GLsizei
Resolving variable decl type : GLenum
Resolving variable decl lists : GLvoid*
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLhalf*
Resolving variable decl mode : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl variable : GLenum
Resolving variable decl input : GLenum
Resolving variable decl mapping : GLenum
Resolving variable decl componentUsage : GLenum
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl id : GLuint
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLint*
Resolving variable decl type : GLenum
Resolving variable decl stride : GLint
Resolving variable decl pointer : GLvoid**
Resolving variable decl ptrstride : GLint
Resolving variable decl pname : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLuint
Resolving variable decl weight : GLhalf
Resolving variable decl target : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl p : GLfloat*
Resolving variable decl red : GLclampf
Resolving variable decl green : GLclampf
Resolving variable decl blue : GLclampf
Resolving variable decl alpha : GLclampf
Resolving variable decl v : GLubyte*
Resolving variable decl program : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl value : GLint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl image : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl index : GLuint
Resolving variable decl x : GLshort
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLuint*
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLint
Resolving variable decl pointer : GLvoid**
Resolving variable decl ptrstride : GLint
Resolving variable decl rc : GLuint*
Resolving variable decl c : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl w : GLint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl v : GLint*
Resolving variable decl left : GLdouble
Resolving variable decl right : GLdouble
Resolving variable decl bottom : GLdouble
Resolving variable decl top : GLdouble
Resolving variable decl zNear : GLdouble
Resolving variable decl zFar : GLdouble
Resolving variable decl id : GLuint
Resolving variable decl addr : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl start : GLsizei
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl left : GLdouble
Resolving variable decl right : GLdouble
Resolving variable decl bottom : GLdouble
Resolving variable decl top : GLdouble
Resolving variable decl zNear : GLdouble
Resolving variable decl zFar : GLdouble
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLfloat
Resolving variable decl arg3 : GLint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl mode : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl nx : GLbyte
Resolving variable decl ny : GLbyte
Resolving variable decl nz : GLbyte
Resolving variable decl v : GLint*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLenum
Resolving variable decl nx : GLdouble
Resolving variable decl ny : GLdouble
Resolving variable decl nz : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLdouble*
Resolving variable decl v : GLhalf*
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl list : GLuint
Resolving variable decl range : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl s : GLint
Resolving variable decl programObj : GLhandleARB
Resolving variable decl location : GLint
Resolving variable decl params : GLfloat*
Resolving variable decl factor : GLint
Resolving variable decl variable : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl red : GLubyte
Resolving variable decl green : GLubyte
Resolving variable decl blue : GLubyte
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl nx : GLint
Resolving variable decl ny : GLint
Resolving variable decl nz : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : Void**
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl fence : GLuint
Resolving variable decl target : GLenum
Resolving variable decl size : GLsizeiptrARB
Resolving variable decl data : GLvoid*
Resolving variable decl usage : GLenum
Resolving variable decl r : GLfloat
Resolving variable decl g : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl a : GLfloat
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLint*
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl p : GLfloat
Resolving variable decl q : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl g : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl a : GLfloat
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl program : GLuint
Resolving variable decl name : GLchar*
Resolving variable decl op : GLenum
Resolving variable decl res : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg3 : GLuint
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLfloat*
Resolving variable decl id : GLuint
Resolving variable decl len : GLsizei
Resolving variable decl name : GLubyte*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl v : GLhalf*
Resolving variable decl program : GLuint
Resolving variable decl index : GLuint
Resolving variable decl name : GLchar*
Resolving variable decl arg0 : GLuint
Resolving variable decl mode : GLenum
Resolving variable decl start : GLuint
Resolving variable decl end : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl mode : GLenum
Resolving variable decl count : GLsizei
Resolving variable decl type : GLenum
Resolving variable decl indices : Void*
Resolving variable decl primcount : GLsizei
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLint
Resolving variable decl pointer : GLvoid**
Resolving variable decl ptrstride : GLint
Resolving variable decl p : GLfloat*
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl pointer : Void**
Resolving variable decl type : GLenum
Resolving variable decl stride : GLint
Resolving variable decl pointer : GLvoid**
Resolving variable decl ptrstride : GLint
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl nx : GLshort
Resolving variable decl ny : GLshort
Resolving variable decl nz : GLshort
Resolving variable decl stream : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl renderbuffers : GLuint*
Resolving variable decl program : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl query : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl video_slot : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint64EXT*
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl renderbuffer : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl string : Void*
Resolving variable decl video_slot : GLuint
Resolving variable decl minPresentTime : GLuint64EXT
Resolving variable decl beginPresentTimeId : GLuint
Resolving variable decl presentDurationId : GLuint
Resolving variable decl type : GLenum
Resolving variable decl target0 : GLenum
Resolving variable decl fill0 : GLuint
Resolving variable decl key0 : GLuint
Resolving variable decl target1 : GLenum
Resolving variable decl fill1 : GLuint
Resolving variable decl key1 : GLuint
Resolving variable decl map : GLenum
Resolving variable decl mapsize : GLsizei
Resolving variable decl values : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl cap : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl v2 : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl filter : GLenum
Resolving variable decl n : GLsizei
Resolving variable decl weights : GLfloat*
Resolving variable decl buffer : GLuint
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl w : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLvoid**
Resolving variable decl v : GLfloat*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl stage : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl face : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLubyte*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl v2 : GLint
Resolving variable decl c : GLshort*
Resolving variable decl markerp : GLuint*
Resolving variable decl dst : GLuint
Resolving variable decl value : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl value : GLclampf
Resolving variable decl invert : GLboolean
Resolving variable decl target : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl r : GLdouble
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v : GLshort*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl mode : GLenum
Resolving variable decl start : GLuint
Resolving variable decl end : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl type : GLenum
Resolving variable decl indices : GLvoid*
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl value : GLenum
Resolving variable decl index : GLuint
Resolving variable decl data : GLboolean*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl w : GLint
Resolving variable decl target : GLenum
Resolving variable decl offset : GLintptr
Resolving variable decl length : GLsizeiptr
Resolving variable decl access : GLbitfield
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v1 : GLdouble*
Resolving variable decl v2 : GLdouble*
Resolving variable decl u : GLfloat*
Resolving variable decl tc : GLfloat*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl program : GLuint
Resolving variable decl index : GLuint
Resolving variable decl bufSize : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl size : GLsizei*
Resolving variable decl type : GLenum*
Resolving variable decl name : Char*
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl w : GLshort
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl rc : GLuint
Resolving variable decl r : GLfloat
Resolving variable decl g : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl a : GLfloat
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl matrixMode : GLenum
Resolving variable decl m : GLdouble*
Resolving variable decl size : GLint
Resolving variable decl weights : GLushort*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl arg0 : GLint
Resolving variable decl arg1 : GLuint
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl fence : GLuint
Resolving variable decl target : GLenum
Resolving variable decl framebuffer : GLuint
Resolving variable decl i : GLint
Resolving variable decl op : GLenum
Resolving variable decl dst : GLuint
Resolving variable decl dstMask : GLuint
Resolving variable decl dstMod : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg1Rep : GLuint
Resolving variable decl arg1Mod : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg2Rep : GLuint
Resolving variable decl arg2Mod : GLuint
Resolving variable decl c : GLfloat*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl reset : GLboolean
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl values : Void*
Resolving variable decl c : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl table : GLvoid*
Resolving variable decl size : GLint
Resolving variable decl weights : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl target : GLenum
Resolving variable decl id : GLuint
Resolving variable decl stream : GLenum
Resolving variable decl v : GLint*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl w : GLint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl count : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl range : GLuint
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl start : GLsizei
Resolving variable decl count : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl data : GLvoid*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl dst : GLuint
Resolving variable decl interp : GLuint
Resolving variable decl swizzle : GLenum
Resolving variable decl target : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl u1 : GLdouble
Resolving variable decl u2 : GLdouble
Resolving variable decl stride : GLint
Resolving variable decl order : GLint
Resolving variable decl points : GLdouble*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLint*
Resolving variable decl face : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl v : GLdouble*
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl tc : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl target : GLenum
Resolving variable decl u1 : GLfloat
Resolving variable decl u2 : GLfloat
Resolving variable decl stride : GLint
Resolving variable decl order : GLint
Resolving variable decl points : GLfloat*
Resolving variable decl mode : GLenum
Resolving variable decl count : GLsizei
Resolving variable decl type : GLenum
Resolving variable decl indices : GLvoid*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl bufs : GLenum*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLintptr
Resolving variable decl target : GLenum
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl framebuffer : GLuint
Resolving variable decl v : GLint*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLboolean
Resolving variable decl arg2 : GLboolean
Resolving variable decl arg3 : GLboolean
Resolving variable decl arg4 : GLboolean
Resolving variable decl target : GLenum
Resolving variable decl buffer : GLuint
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLfloat*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl sfactorRGB : GLenum
Resolving variable decl dfactorRGB : GLenum
Resolving variable decl sfactorAlpha : GLenum
Resolving variable decl dfactorAlpha : GLenum
Resolving variable decl face : GLenum
Resolving variable decl sfail : GLenum
Resolving variable decl dpfail : GLenum
Resolving variable decl dppass : GLenum
Resolving variable decl target : GLenum
Resolving variable decl s : GLint
Resolving variable decl framebuffer : GLuint
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl count : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl target : GLenum
Resolving variable decl size : GLsizeiptr
Resolving variable decl data : GLvoid*
Resolving variable decl usage : GLenum
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl target : GLenum
Resolving variable decl n : GLsizei
Resolving variable decl points : GLfloat*
Resolving variable decl s : GLhalf
Resolving variable decl t : GLhalf
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLdouble*
Resolving variable decl x : GLhalf
Resolving variable decl y : GLhalf
Resolving variable decl z : GLhalf
Resolving variable decl w : GLhalf
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint*
Resolving variable decl v : GLhalf*
Resolving variable decl target : GLenum
Resolving variable decl s : GLint
Resolving variable decl t : GLint
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl layer : GLint
Resolving variable decl id : GLuint
Resolving variable decl len : GLsizei
Resolving variable decl name : GLubyte*
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl matrixMode : GLenum
Resolving variable decl m : GLfloat*
Resolving variable decl p : GLshort*
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl v : GLshort*
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl index : GLuint
Resolving variable decl x : GLuint
Resolving variable decl y : GLuint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl s : GLshort
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl c : GLubyte*
Resolving variable decl v : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLuint*
Resolving variable decl size : GLint
Resolving variable decl indices : GLuint*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint64EXT*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLint*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl rc : GLuint
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl mode : GLenum
Resolving variable decl i1 : GLint
Resolving variable decl i2 : GLint
Resolving variable decl zmin : GLclampd
Resolving variable decl zmax : GLclampd
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl mode : GLenum
Resolving variable decl i1 : GLint
Resolving variable decl i2 : GLint
Resolving variable decl j1 : GLint
Resolving variable decl j2 : GLint
Resolving variable decl index : GLuint
Resolving variable decl v : GLbyte*
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl index : GLuint
Resolving variable decl v : GLhalf*
Resolving variable decl index : GLuint
Resolving variable decl v : GLint*
Resolving variable decl id : GLuint
Resolving variable decl len : GLsizei
Resolving variable decl name : GLubyte*
Resolving variable decl params : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLint*
Resolving variable decl mode : GLenum
Resolving variable decl marker : GLuint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLuint
Resolving variable decl v1 : GLuint
Resolving variable decl v2 : GLuint
Resolving variable decl mode : GLenum
Resolving variable decl first : GLint*
Resolving variable decl count : GLsizei*
Resolving variable decl primcount : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLint*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl reset : GLboolean
Resolving variable decl format : GLenum
Resolving variable decl types : GLenum
Resolving variable decl values : GLvoid*
Resolving variable decl v : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl mode : GLenum
Resolving variable decl id : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl arg0 : GLdouble
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLint*
Resolving variable decl rc : GLuint*
Resolving variable decl n : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl matrixMode : GLenum
Resolving variable decl m : GLfloat*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl image : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl map : GLenum
Resolving variable decl values : GLushort*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl renderbuffertarget : GLenum
Resolving variable decl renderbuffer : GLuint
Resolving variable decl program : GLuint
Resolving variable decl index : GLuint
Resolving variable decl maxLength : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl size : GLint*
Resolving variable decl type : GLenum*
Resolving variable decl name : GLchar*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLintptr
Resolving variable decl size : GLsizeiptr
Resolving variable decl data : Void*
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl samples : GLsizei
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl list : GLuint
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl pointer : Void**
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl w : GLfloat
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLshort*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl p : GLdouble*
Resolving variable decl buffer : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl renderbuffer : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl i : GLint
Resolving variable decl factor : GLubyte
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLuint*
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl program : GLuint
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLint*
Resolving variable decl arg0 : GLint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg3 : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl n : GLsizei
Resolving variable decl textures : GLuint*
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLuint*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLenum
Resolving variable decl target : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl op : GLenum
Resolving variable decl res : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl unit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl value : GLenum
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLdouble
Resolving variable decl fence : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl format : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl containerObj : GLhandleARB
Resolving variable decl maxCount : GLsizei
Resolving variable decl count : GLsizei*
Resolving variable decl obj : GLhandleARB*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl buffer : GLuint
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLuint*
Resolving variable decl shader : GLuint
Resolving variable decl target : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl value : GLclampf
Resolving variable decl invert : GLboolean
Resolving variable decl texunit : GLenum
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat*
Resolving variable decl op : GLenum
Resolving variable decl res : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl p : GLint*
Resolving variable decl framebuffer : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint*
Resolving variable decl coord : GLdouble*
Resolving variable decl v : GLshort*
Resolving variable decl target : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl id : GLuint
Resolving variable decl addr : GLubyte*
Resolving variable decl light : GLenum
Resolving variable decl value : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl v : GLint*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl framebuffer : GLuint
Resolving variable decl attachment : GLenum
Resolving variable decl renderbuffertarget : GLenum
Resolving variable decl renderbuffer : GLuint
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLuint
Resolving variable decl id : GLuint
Resolving variable decl value : GLenum
Resolving variable decl data : GLint*
Resolving variable decl v : GLshort*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl n : GLsizei
Resolving variable decl arrays : GLuint*
Resolving variable decl v : GLint*
Resolving variable decl v : GLshort*
Resolving variable decl type : GLenum
Resolving variable decl pointer : Void*
Resolving variable decl index : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl value : GLclampf
Resolving variable decl invert : GLboolean
Resolving variable decl _func : GLenum
Resolving variable decl ref : GLfloat
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl size : GLsizei
Resolving variable decl type : GLenum
Resolving variable decl buffer : GLfloat*
Resolving variable decl v : GLint*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl l : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl n : GLfloat
Resolving variable decl f : GLfloat
Resolving variable decl arg0 : GLint
Resolving variable decl arg1 : GLsizei
Resolving variable decl arg2 : GLuint*
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl target : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl count : GLsizei
Resolving variable decl pointer : GLboolean*
Resolving variable decl s : GLint
Resolving variable decl target : GLenum
Resolving variable decl lfunc : GLenum
Resolving variable decl hfunc : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLvoid**
Resolving variable decl stream : GLenum
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl v : GLhalf*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLfloat
Resolving variable decl v1 : GLfloat
Resolving variable decl stream : GLenum
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl range : GLsizei
Resolving variable decl v : GLfloat*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLint*
Resolving variable decl id : GLuint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLuint
Resolving variable decl size : GLint
Resolving variable decl weights : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl buffer : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl target : GLenum
Resolving variable decl length : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl red : GLfloat
Resolving variable decl green : GLfloat
Resolving variable decl blue : GLfloat
Resolving variable decl alpha : GLfloat
Resolving variable decl framebuffer : GLuint
Resolving variable decl attachment : GLenum
Resolving variable decl textarget : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl v : GLfloat*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLuint
Resolving variable decl target : GLenum
Resolving variable decl v : GLhalf*
Resolving variable decl matrixMode : GLenum
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl border : GLint
Resolving variable decl u : GLdouble
Resolving variable decl v : GLdouble
Resolving variable decl v : GLshort*
Resolving variable decl size : GLint
Resolving variable decl indices : GLushort*
Resolving variable decl index : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLuint*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl v : GLuint*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl u : GLfloat
Resolving variable decl v : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl map : GLenum
Resolving variable decl mapsize : GLsizei
Resolving variable decl values : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl red : GLfloat
Resolving variable decl green : GLfloat
Resolving variable decl blue : GLfloat
Resolving variable decl v : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl location : GLint
Resolving variable decl v0 : GLuint
Resolving variable decl v1 : GLuint
Resolving variable decl v2 : GLuint
Resolving variable decl v3 : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl framebuffers : GLuint*
Resolving variable decl v : GLint*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl index : GLuint
Resolving variable decl v : GLbyte*
Resolving variable decl n : GLsizei
Resolving variable decl arrays : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl buffer : GLuint
Resolving variable decl offset : GLintptr
Resolving variable decl program : GLuint
Resolving variable decl v : GLhalf*
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl matrixMode : GLenum
Resolving variable decl l : GLdouble
Resolving variable decl r : GLdouble
Resolving variable decl b : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl n : GLdouble
Resolving variable decl f : GLdouble
Resolving variable decl tc : GLfloat*
Resolving variable decl c : GLfloat*
Resolving variable decl v : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLubyte
Resolving variable decl y : GLubyte
Resolving variable decl z : GLubyte
Resolving variable decl w : GLubyte
Resolving variable decl op : GLenum
Resolving variable decl dst : GLuint
Resolving variable decl dstMod : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg1Rep : GLuint
Resolving variable decl arg1Mod : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl buffers : GLuint*
Resolving variable decl v : GLdouble*
Resolving variable decl index : GLuint
Resolving variable decl v : GLdouble*
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl location : GLint
Resolving variable decl v0 : GLuint
Resolving variable decl v1 : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl op : GLenum
Resolving variable decl dst : GLuint
Resolving variable decl dstMask : GLuint
Resolving variable decl dstMod : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg1Rep : GLuint
Resolving variable decl arg1Mod : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl index : GLuint
Resolving variable decl n : GLsizei
Resolving variable decl v : GLfloat*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl l : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl n : GLfloat
Resolving variable decl f : GLfloat
Resolving variable decl texture : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl mask : GLuint
Resolving variable decl unit : GLenum
Resolving variable decl value : GLenum
Resolving variable decl programObj : GLhandleARB
Resolving variable decl index : GLuint
Resolving variable decl maxLength : GLsizei
Resolving variable decl length : GLsizei*
Resolving variable decl size : GLint*
Resolving variable decl type : GLenum*
Resolving variable decl name : GLcharARB*
Resolving variable decl points : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl primitiveMode : GLenum
Resolving variable decl mask : GLbitfield
Resolving variable decl red : GLhalf
Resolving variable decl green : GLhalf
Resolving variable decl blue : GLhalf
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLuint*
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl face : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl p : GLshort*
Resolving variable decl mode : GLenum
Resolving variable decl start : GLint
Resolving variable decl count : GLsizei
Resolving variable decl primcount : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl tlow : GLclampf
Resolving variable decl thigh : GLclampf
Resolving variable decl target : GLenum
Resolving variable decl offset : GLintptrARB
Resolving variable decl size : GLsizeiptrARB
Resolving variable decl data : GLvoid*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl obj : GLhandleARB
Resolving variable decl pattern : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl id : GLuint
Resolving variable decl id : GLuint
Resolving variable decl addr : GLdouble*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl v0 : GLint
Resolving variable decl v1 : GLint
Resolving variable decl plane : GLenum
Resolving variable decl equation : GLdouble*
Resolving variable decl xfactor : GLfloat
Resolving variable decl yfactor : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl stream : GLenum
Resolving variable decl v : GLdouble*
Resolving variable decl arg0 : GLenum
Resolving variable decl factor : GLint
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl dst : GLuint
Resolving variable decl coord : GLuint
Resolving variable decl swizzle : GLenum
Resolving variable decl fog : GLhalf*
Resolving variable decl target : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl matrixMode : GLenum
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl query : GLenum
Resolving variable decl v : GLint*
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl m : GLdouble*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : Void*
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl transpose : GLboolean
Resolving variable decl value : GLfloat*
Resolving variable decl matrixMode : GLenum
Resolving variable decl m : GLdouble*
Resolving variable decl m : GLfloat*
Resolving variable decl x : GLhalf
Resolving variable decl y : GLhalf
Resolving variable decl z : GLhalf
Resolving variable decl s : GLhalf
Resolving variable decl matrixMode : GLenum
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl programObj : GLhandleARB
Resolving variable decl location : GLint
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint*
Resolving variable decl mode : GLenum
Resolving variable decl count : GLsizei*
Resolving variable decl type : GLenum
Resolving variable decl indices : GLvoid**
Resolving variable decl primcount : GLsizei
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLvoid**
Resolving variable decl target : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl z : GLshort
Resolving variable decl w : GLshort
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLuint
Resolving variable decl arg2 : GLuint
Resolving variable decl arg3 : GLuint
Resolving variable decl v : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLint
Resolving variable decl arg2 : GLuint*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl w : GLint
Resolving variable decl coord : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLdouble*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl face : GLenum
Resolving variable decl mode : GLenum
Resolving variable decl target : GLenum
Resolving variable decl v : GLint*
Resolving variable decl v : GLbyte*
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl type : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl program : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl value : GLint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl texture : GLuint
Resolving variable decl red : GLubyte
Resolving variable decl green : GLubyte
Resolving variable decl blue : GLubyte
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl factor : GLbyte
Resolving variable decl target : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl v : GLbyte*
Resolving variable decl value : GLenum
Resolving variable decl index : GLuint
Resolving variable decl data : GLint*
Resolving variable decl light : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl v1 : GLint*
Resolving variable decl v2 : GLint*
Resolving variable decl id : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl program : GLubyte*
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl n : GLsizei
Resolving variable decl programs : GLuint*
Resolving variable decl target : GLenum
Resolving variable decl framebuffer : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl v : GLfloat*
Resolving variable decl index : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLuint*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLuint*
Resolving variable decl red : GLhalf
Resolving variable decl green : GLhalf
Resolving variable decl blue : GLhalf
Resolving variable decl alpha : GLhalf
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl mode : GLenum
Resolving variable decl texture : GLenum
Resolving variable decl srcX0 : GLint
Resolving variable decl srcY0 : GLint
Resolving variable decl srcX1 : GLint
Resolving variable decl srcY1 : GLint
Resolving variable decl dstX0 : GLint
Resolving variable decl dstY0 : GLint
Resolving variable decl dstX1 : GLint
Resolving variable decl dstY1 : GLint
Resolving variable decl mask : GLbitfield
Resolving variable decl filter : GLenum
Resolving variable decl red : GLuint
Resolving variable decl green : GLuint
Resolving variable decl blue : GLuint
Resolving variable decl index : GLuint
Resolving variable decl v : GLfloat*
Resolving variable decl sfactor : GLenum
Resolving variable decl dfactor : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl target : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl count : GLint
Resolving variable decl index : GLuint
Resolving variable decl mask : GLbitfield
Resolving variable decl target : GLenum
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLenum
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl border : GLint
Resolving variable decl fence : GLuint
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl program : GLuint
Resolving variable decl location : GLint
Resolving variable decl count : GLsizei
Resolving variable decl value : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl renderbuffers : GLuint*
Resolving variable decl size : GLint
Resolving variable decl weights : GLdouble*
Resolving variable decl v : GLhalf*
Resolving variable decl arg0 : GLenum
Resolving variable decl arg1 : GLenum
Resolving variable decl arg2 : GLint*
Resolving variable decl target : GLenum
Resolving variable decl clamp : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl n : GLsizei
Resolving variable decl ids : GLuint*
Resolving variable decl red : GLint
Resolving variable decl green : GLint
Resolving variable decl blue : GLint
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl internalformat : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl border : GLint
Resolving variable decl format : GLenum
Resolving variable decl type : GLenum
Resolving variable decl pixels : Void*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl res : GLuint
Resolving variable decl src : GLuint
Resolving variable decl num : GLuint
Resolving variable decl target : GLenum
Resolving variable decl attachment : GLenum
Resolving variable decl texture : GLuint
Resolving variable decl level : GLint
Resolving variable decl face : GLenum
Resolving variable decl target : GLenum
Resolving variable decl v : GLint*
Resolving variable decl arg0 : GLuint
Resolving variable decl arg1 : GLchar*
Resolving variable decl v : GLubyte*
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl width : GLsizei
Resolving variable decl texunit : GLenum
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLuint
Resolving variable decl y : GLuint
Resolving variable decl z : GLuint
Resolving variable decl w : GLuint
Resolving variable decl target : GLenum
Resolving variable decl v : GLshort*
Resolving variable decl size : GLint
Resolving variable decl indices : GLubyte*
Resolving variable decl index : GLuint
Resolving variable decl x : GLdouble
Resolving variable decl y : GLdouble
Resolving variable decl z : GLdouble
Resolving variable decl w : GLdouble
Resolving variable decl matrixMode : GLenum
Resolving variable decl m : GLdouble*
Resolving variable decl stream : GLenum
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl index : GLuint
Resolving variable decl v : GLshort*
Resolving variable decl v : GLhalf*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLfloat*
Resolving variable decl size : GLint
Resolving variable decl type : GLenum
Resolving variable decl stride : GLsizei
Resolving variable decl pointer : GLvoid*
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLfloat*
Resolving variable decl x1 : GLdouble
Resolving variable decl y1 : GLdouble
Resolving variable decl x2 : GLdouble
Resolving variable decl y2 : GLdouble
Resolving variable decl rc : GLuint
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl rc : GLuint
Resolving variable decl s : GLfloat
Resolving variable decl t : GLfloat
Resolving variable decl r : GLfloat
Resolving variable decl g : GLfloat
Resolving variable decl b : GLfloat
Resolving variable decl a : GLfloat
Resolving variable decl nx : GLfloat
Resolving variable decl ny : GLfloat
Resolving variable decl nz : GLfloat
Resolving variable decl x : GLfloat
Resolving variable decl y : GLfloat
Resolving variable decl z : GLfloat
Resolving variable decl red : GLushort
Resolving variable decl green : GLushort
Resolving variable decl blue : GLushort
Resolving variable decl v : GLint*
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl target : GLenum
Resolving variable decl v : GLhalf*
Resolving variable decl index : GLuint
Resolving variable decl x : GLfloat
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl format : GLenum
Resolving variable decl len : GLsizei
Resolving variable decl string : Void*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl params : GLdouble*
Resolving variable decl x1 : GLfloat
Resolving variable decl y1 : GLfloat
Resolving variable decl x2 : GLfloat
Resolving variable decl y2 : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl target : GLenum
Resolving variable decl pname : GLenum
Resolving variable decl params : GLint*
Resolving variable decl matrixMode : GLenum
Resolving variable decl l : GLdouble
Resolving variable decl r : GLdouble
Resolving variable decl b : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl n : GLdouble
Resolving variable decl f : GLdouble
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl x : GLuint
Resolving variable decl y : GLuint
Resolving variable decl z : GLuint
Resolving variable decl w : GLuint
Resolving variable decl mode : GLenum
Resolving variable decl count : GLsizei
Resolving variable decl type : GLenum
Resolving variable decl indices : GLvoid*
Resolving variable decl primcount : GLsizei
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl x : GLshort
Resolving variable decl y : GLshort
Resolving variable decl x1 : GLint
Resolving variable decl y1 : GLint
Resolving variable decl x2 : GLint
Resolving variable decl y2 : GLint
Resolving variable decl index : GLuint
Resolving variable decl x : GLint
Resolving variable decl y : GLint
Resolving variable decl z : GLint
Resolving variable decl target : GLenum
Resolving variable decl level : GLint
Resolving variable decl xoffset : GLint
Resolving variable decl yoffset : GLint
Resolving variable decl zoffset : GLint
Resolving variable decl width : GLsizei
Resolving variable decl height : GLsizei
Resolving variable decl depth : GLsizei
Resolving variable decl format : GLenum
Resolving variable decl imageSize : GLsizei
Resolving variable decl data : Void*
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl type : GLenum
Resolving variable decl ustride : GLsizei
Resolving variable decl vstride : GLsizei
Resolving variable decl packed : GLboolean
Resolving variable decl points : Void*
Resolving variable decl program : GLuint
Resolving variable decl target : GLenum
Resolving variable decl index : GLuint
Resolving variable decl count : GLsizei
Resolving variable decl params : GLuint*
Resolving variable decl array : GLenum
Resolving variable decl target : GLenum
Resolving variable decl s : GLdouble
Resolving variable decl t : GLdouble
Resolving variable decl r : GLdouble
Resolving variable decl q : GLdouble
Resolving variable decl index : GLuint
Resolving variable decl v : GLint*
Resolving variable decl pname : GLenum
Resolving variable decl param : GLfloat
Resolving variable decl p : GLfloat*
Resolving variable decl n : GLsizei
Resolving variable decl renderbuffers : GLuint*
Resolving variable decl program : GLuint
Resolving variable decl name : GLchar*
Resolving variable decl target : GLenum
Resolving variable decl renderbuffer : GLuint
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module glew finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/system
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl Int
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module lang/system finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/stdio
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl stdout : FStream
Resolving variable decl stderr : FStream
Resolving variable decl stdin : FStream
====== Resolving type decl CoverDecl FILE
====== Resolving type decl ClassDecl FILEClass
====== Resolving type decl ClassDecl FILEClass
====== Resolving type decl CoverDecl FStream
====== Resolving type decl ClassDecl FStreamClass
Resolving variable decl c : Char
fread(c&, 1, 1, this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fread(c&, 1, 1, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fread(c&, 1, 1, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl chunk : <unknown type> = 128
Resolving variable decl length : <unknown type> = chunk
Resolving variable decl pos : <unknown type> = 0
Resolving variable decl str : <unknown type> = gc_malloc(length) as String
gc_malloc(length) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
gc_malloc(length) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
gc_malloc(length) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
str : String = gc_malloc(length) as String (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
fgets(str, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
fgets(str, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fgets(str, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
str last() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
str last() != CharLiteral (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
Resolving variable decl tmp : <unknown type> = gc_realloc(str, length) as String
gc_realloc(str, length) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
gc_realloc(str, length) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
gc_realloc(str, length) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
tmp : String = gc_realloc(str, length) as String (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") looping because not resolved!'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") throw() looping because not resolved!'
fgets(str as Char* + pos, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
fgets(str as Char* + pos, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fgets(str as Char* + pos, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
feof(this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
feof(this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
feof(this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
feof(this) == 0 (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl chr : Char
fputc(chr, this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
fputc(chr, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fputc(chr, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl str : String
fputs(str, this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
fputs(str, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fputs(str, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl str : Char*
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
fwrite(str + offset, 1, length, this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fwrite(str + offset, 1, length, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fwrite(str + offset, 1, length, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
write~precise: func (str : Char*, offset : SizeT, length : SizeT) -> SizeT (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
====== Resolving type decl ClassDecl FStreamClass
Resolving variable decl c : Char
fread(c&, 1, 1, this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fread(c&, 1, 1, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fread(c&, 1, 1, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl chunk : Int = 128
Resolving variable decl length : Int = chunk
Resolving variable decl pos : Int = 0
Resolving variable decl str : String = gc_malloc(length) as String
gc_malloc(length) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
gc_malloc(length) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
gc_malloc(length) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
str : String = gc_malloc(length) as String (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
fgets(str, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fgets(str, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
str last() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
str last() != CharLiteral (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
Resolving variable decl tmp : String = gc_realloc(str, length) as String
gc_realloc(str, length) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
gc_realloc(str, length) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
gc_realloc(str, length) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
tmp : String = gc_realloc(str, length) as String (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") looping because not resolved!'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") throw() looping because not resolved!'
fgets(str as Char* + pos, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fgets(str as Char* + pos, chunk, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
feof(this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
feof(this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
feof(this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
feof(this) == 0 (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl chr : Char
fputc(chr, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fputc(chr, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl str : String
fputs(str, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fputs(str, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl str : Char*
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
fwrite(str + offset, 1, length, this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fwrite(str + offset, 1, length, this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fwrite(str + offset, 1, length, this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
write~precise: func (str : Char*, offset : SizeT, length : SizeT) -> SizeT (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl str : String
printf("%s\n", str) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
printf("%s\n", str) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
printf("%s\n", str) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
printf("\n") (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
printf("\n") (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
printf("\n") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl String
Resolving variable decl String
Resolving variable decl String
Resolving variable decl Int
Resolving variable decl String
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl String
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl String
Resolving variable decl Int
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl nmemb : SizeT
Resolving variable decl stream : FStream
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl nmemb : SizeT
Resolving variable decl stream : FStream
Resolving variable decl stream : FStream
Resolving variable decl String
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl stream : FStream
Resolving variable decl Char
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl format : String
Resolving variable decl stream : FStream
Resolving variable decl format : String
Resolving variable decl str : String
Resolving variable decl format : String
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl stream : FStream
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl str : String
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl str : String
Resolving variable decl length : SizeT
Resolving variable decl stream : FStream
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/vararg
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl CoverDecl VaList
====== Resolving type decl ClassDecl VaListClass
     - type va_list still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl VaListClass
Resolving variable decl VaList
Resolving variable decl VaList
Resolving variable decl VaList
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module lang/vararg finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/memory
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl size : SizeT
Resolving variable decl size : SizeT
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl nmemb : SizeT
Resolving variable decl size : SizeT
gc_malloc(nmemb * size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl Pointer
Resolving variable decl Int
Resolving variable decl SizeT
Resolving variable decl Pointer
Resolving variable decl Pointer
Resolving variable decl SizeT
Resolving variable decl Pointer
Resolving variable decl Pointer
Resolving variable decl SizeT
Resolving variable decl Pointer
Resolving variable decl Pointer
Resolving variable decl SizeT
Resolving variable decl Pointer
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Object
Resolving variable decl class : Class
====== Resolving type decl ClassDecl ObjectClass
Resolving variable decl T : Class
class inheritsFrom(T) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
class inheritsFrom(T) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
class inheritsFrom(T) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
instanceOf: func (T : Class) -> Bool (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
====== Resolving type decl ClassDecl ObjectClass
Resolving variable decl T : Class
Object.class inheritsFrom(T) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Object.class inheritsFrom(T) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
Object.class inheritsFrom(T) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
instanceOf: func (T : Class) -> Bool (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
====== Resolving type decl ClassDecl Class
Resolving variable decl instanceSize : SizeT
Resolving variable decl size : SizeT
Resolving variable decl name : String
Resolving variable decl super : Class
====== Resolving type decl ClassDecl ClassClass
Resolving variable decl object : <unknown type> = gc_malloc(instanceSize) as Object
gc_malloc(instanceSize) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl T : Class
super inheritsFrom(T) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
====== Resolving type decl ClassDecl ClassClass
Resolving variable decl object : Object = gc_malloc(instanceSize) as Object
Resolving variable decl T : Class
====== Resolving type decl ClassDecl None
====== Resolving type decl ClassDecl NoneClass
Resolving variable decl this : <unknown type> = None alloc() as None
None alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl NoneClass
Resolving variable decl this : None = None alloc() as None
====== Resolving type decl CoverDecl Void
====== Resolving type decl ClassDecl VoidClass
     - type void still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl VoidClass
====== Resolving type decl CoverDecl Pointer
====== Resolving type decl ClassDecl PointerClass
"%p" format(this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toString: func  -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
     - type void still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl PointerClass
"%p" format(this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toString: func  -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
====== Resolving type decl CoverDecl Char
====== Resolving type decl ClassDecl CharClass
this isAlpha() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this isDigit() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this isAlpha() || this isDigit() (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this isAlpha() (who is null? true, false, true, false)'
isAlphaNumeric: func  -> Bool (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
this isLower() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this isUpper() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this isLower() || this isUpper() (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this isLower() (who is null? true, false, true, false)'
isAlpha: func  -> Bool (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
this isDigit() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this isPrintable() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this isPrintable() && this != CharLiteral (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this isPrintable() (who is null? true, false, false, false)'
isGraph: func  -> Bool (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
this isPrintable() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this isAlphaNumeric() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this isDigit() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
String new(this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
String new(this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
String new(this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
toString: func  -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
printf("%c", this) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
printf("%c\n", this) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
     - type char still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl CharClass
this isAlpha() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this isDigit() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this isLower() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this isUpper() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this isPrintable() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
String new(this) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
String new(this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
String new(this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
toString: func  -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
====== Resolving type decl CoverDecl SChar
====== Resolving type decl ClassDecl SCharClass
     - type signed char still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl SCharClass
====== Resolving type decl CoverDecl UChar
====== Resolving type decl ClassDecl UCharClass
     - type unsigned char still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl UCharClass
====== Resolving type decl CoverDecl WChar
====== Resolving type decl ClassDecl WCharClass
     - type wchar_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl WCharClass
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl length : SizeT
Resolving variable decl result : <unknown type> = gc_malloc(length + 1) as This
gc_malloc(length + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
result[length] = CharLiteral (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = result[length] (who is null? false, true, false, false)'
Resolving variable decl c : Char
Resolving variable decl result : <unknown type> = This new(1)
This new(1) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
result[0] = c (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = result[0] (who is null? false, true, false, false)'
Resolving variable decl other : This
Resolving variable decl start : SizeT
Resolving variable decl length : SizeT
Resolving variable decl i : SizeT
i : SizeT (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
Resolving variable decl other : This
Resolving variable decl start : SizeT
other length() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
compare(other, start, other length()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
compare(other, start, other length()) (of type FunctionCall) wants to wholeAgain() because 'compare(other, start, other length()) looping because not resolved!'
compare~implicitLength: func (other : String, start : SizeT) -> Bool (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl other : This
other length() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
compare(other, 0, other length()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
compare(other, 0, other length()) (of type FunctionCall) wants to wholeAgain() because 'compare(other, 0, other length()) looping because not resolved!'
compare~whole: func (other : String) -> Bool (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl other : String
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
other length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl i : SizeT
i : SizeT (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
other length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl s : This
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
s length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl i : SizeT
i : SizeT (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
s length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl c : Char
Resolving variable decl s : This
Resolving variable decl l1 : <unknown type> = this length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl l2 : <unknown type> = s length()
s length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl offset : SizeT = (l1 - l2)
Resolving variable decl i : SizeT
i : SizeT (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
Resolving variable decl c : Char
Resolving variable decl start : Int
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
Resolving variable decl c : Char
this indexOf(c, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl s : This
Resolving variable decl start : Int
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl slength : <unknown type> = s length()
s length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
this compare(s, i, slength) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl s : This
this indexOf(s, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl c : Char
this indexOf(c) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl s : This
this indexOf(s) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
this trim(CharLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this trim(CharLiteral) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this trim(CharLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return this trim(CharLiteral) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl c : Char
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl start : <unknown type> = 0
Resolving variable decl end : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this substring(start, end) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this substring(start, end) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this substring(start, end) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return this substring(start, end) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl s : This
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl start : <unknown type> = 0
s contains(this[start]) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
s contains(this[start]) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl end : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
s contains(this[end - 1]) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
s contains(this[end - 1]) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this substring(start, end) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this substring(start, end) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this substring(start, end) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return this substring(start, end) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
return this[0] (of type Return) wants to wholeAgain() because 'Need info about the expr type'
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this lastIndex() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
return this[this lastIndex()] (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl c : Char
Resolving variable decl i : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl start : SizeT
Resolving variable decl len : SizeT = this length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
printf("String.substring~tillEnd: out of bounds: length = %zd, start = %zd\n", len, start) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Exception new(This, "substring") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "substring") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "substring") looping because not resolved!'
Exception new(This, "substring") throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "substring") throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "substring") throw() looping because not resolved!'
Resolving variable decl diff : SizeT = (len - start)
Resolving variable decl sub : <unknown type> = This new(diff)
This new(diff) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
memcpy(sub, (this as Char*) + start, diff) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
sub[diff] = CharLiteral (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = sub[diff] (who is null? false, true, false, false)'
Resolving variable decl start : SizeT
Resolving variable decl end : SizeT
Resolving variable decl len : SizeT = this length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
"String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) looping because not resolved!'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) throw() looping because not resolved!'
Resolving variable decl diff : SizeT = (end - start)
Resolving variable decl sub : <unknown type> = This new(diff)
This new(diff) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
sub[diff] = 0 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = sub[diff] (who is null? false, true, false, false)'
memcpy(sub, (this as Char*) + start, diff) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl len : <unknown type> = this length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl result : <unknown type> = This new(len + 1)
This new(len + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl i : SizeT
i : SizeT (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
result[i] = this[(len - 1) - i] (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = result[i] (who is null? false, true, false, true)'
result[len] = 0 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = result[len] (who is null? false, true, false, false)'
printf("%s", this) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
fflush(stdout) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("%s\n", this) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl copy : <unknown type> = This new(length)
This new(length) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
memcpy(copy, this, length + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl count : Int
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl result : <unknown type> = This new(length * count) as Char*
This new(length * count) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
memcpy(result + (i * length), this, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl other : This
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl rlength : <unknown type> = other length()
other length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl copy : <unknown type> = This new(length + rlength) as Char*
This new(length + rlength) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
memcpy(copy, this, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(copy + length, other, rlength + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl other : Char
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl copy : <unknown type> = This new(length + 1) as Char*
This new(length + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
memcpy(copy, this, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl other : This
other append(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl other : Char
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl copy : <unknown type> = This new(length + 1) as Char*
This new(length + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
memcpy(copy + 1, this, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl copy : <unknown type> = This new(length) as Char*
This new(length) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
this[i] as Char toLower() (of type FunctionCall) wants to wholeAgain() because 'because of return type Char'
Resolving variable decl length : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl copy : <unknown type> = This new(length) as Char*
This new(length) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
this[i] as Char toUpper() (of type FunctionCall) wants to wholeAgain() because 'because of return type Char'
Resolving variable decl index : SizeT
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
"Accessing a String out of bounds index = %d, length = %d!" format(index, this length()) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) looping because not resolved!'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) throw() looping because not resolved!'
Resolving variable decl list : VaList
va_start(list, this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl length : <unknown type> = vsnprintf(NullLiteral, 0, this, list)
vsnprintf(NullLiteral, 0, this, list) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl output : <unknown type> = This new(length)
This new(length) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
va_end(list) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
va_start(list, this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
vsnprintf(output, length + 1, this, list) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
va_end(list) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
StringIterator<Char> new(this) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringIterator<Char> new(this) (of type FunctionCall) wants to wholeAgain() because 'StringIterator<Char> new(this) looping because not resolved!'
iterator: func  -> StringIterator<Char> (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
====== Resolving type decl ClassDecl StringClass
Resolving variable decl length : SizeT
Resolving variable decl result : String = gc_malloc(length + 1) as String
Resolving variable decl c : Char
Resolving variable decl result : String = This new(1)
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl length : SizeT
Resolving variable decl i : SizeT
Resolving variable decl other : String
Resolving variable decl start : SizeT
other length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this compare(other, start, other length()) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl other : String
other length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this compare(other, 0, other length()) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl other : String
Resolving variable decl i : SizeT
Resolving variable decl s : String
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl l1 : SizeT = this length()
Resolving variable decl l2 : SizeT = s length()
Resolving variable decl offset : SizeT = (l1 - l2)
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl i : Int
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl slength : SizeT = s length()
Resolving variable decl i : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
this trim(CharLiteral) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl c : Char
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
this substring(start, end) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl s : String
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
this substring(start, end) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl c : Char
Resolving variable decl i : SizeT = this length()
Resolving variable decl start : SizeT
Resolving variable decl len : SizeT = this length()
Exception new(This, "substring") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "substring") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "substring") looping because not resolved!'
Exception new(This, "substring") throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "substring") throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "substring") throw() looping because not resolved!'
Resolving variable decl diff : SizeT = (len - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl start : SizeT
Resolving variable decl end : SizeT
Resolving variable decl len : SizeT = this length()
"String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) looping because not resolved!'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) throw() looping because not resolved!'
Resolving variable decl diff : SizeT = (end - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl len : SizeT = this length()
Resolving variable decl result : String = This new(len + 1)
Resolving variable decl i : SizeT
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : String = This new(length)
Resolving variable decl count : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl result : Char* = This new(length * count) as Char*
Resolving variable decl i : Int
Resolving variable decl other : String
Resolving variable decl length : SizeT = this length()
Resolving variable decl rlength : SizeT = other length()
Resolving variable decl copy : Char* = This new(length + rlength) as Char*
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl other : String
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl index : SizeT
"Accessing a String out of bounds index = %d, length = %d!" format(index, this length()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) looping because not resolved!'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) throw() looping because not resolved!'
Resolving variable decl list : VaList
Resolving variable decl length : Int = vsnprintf(NullLiteral, 0, this, list)
Resolving variable decl output : String = This new(length)
StringIterator<Char> new(this) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringIterator<Char> new(this) (of type FunctionCall) wants to wholeAgain() because 'StringIterator<Char> new(this) looping because not resolved!'
iterator: func  -> StringIterator<Char> (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
====== Resolving type decl InterfaceDecl Comparable
====== Resolving type decl ClassDecl ComparableClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl Comparable__reference
Resolving variable decl impl : ComparableClass
Resolving variable decl obj : Object
====== Resolving type decl ClassDecl Comparable__referenceClass
====== Resolving type decl ClassDecl ComparableClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl LLong
====== Resolving type decl ClassDecl LLongClass
"%lld" format(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
"%llx" format(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl range : Range
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl InterfaceImpl LLong__impl__Comparable
====== Resolving type decl ClassDecl LLong__impl__ComparableClass
====== Resolving type decl ClassDecl LLong__impl__ComparableClass
     - type signed long long still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl LLongClass
Resolving variable decl range : Range
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl Long
====== Resolving type decl ClassDecl LongClass
     - type signed long still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl LongClass
====== Resolving type decl CoverDecl Short
====== Resolving type decl ClassDecl ShortClass
     - type signed short still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl ShortClass
====== Resolving type decl CoverDecl Int
====== Resolving type decl ClassDecl IntClass
Resolving variable decl other : T
Resolving variable decl T : Class
     - type signed int still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl IntClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl ULLong
====== Resolving type decl ClassDecl ULLongClass
"%llu" format(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl range : Range
     - type unsigned long long still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl ULLongClass
Resolving variable decl range : Range
====== Resolving type decl CoverDecl ULong
====== Resolving type decl ClassDecl ULongClass
     - type unsigned long still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl ULongClass
====== Resolving type decl CoverDecl UInt
====== Resolving type decl ClassDecl UIntClass
     - type unsigned int still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl UIntClass
====== Resolving type decl CoverDecl UShort
====== Resolving type decl ClassDecl UShortClass
     - type unsigned short still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl UShortClass
====== Resolving type decl CoverDecl Int8
====== Resolving type decl ClassDecl Int8Class
     - type int8_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl Int8Class
====== Resolving type decl CoverDecl Int16
====== Resolving type decl ClassDecl Int16Class
     - type int16_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl Int16Class
====== Resolving type decl CoverDecl Int32
====== Resolving type decl ClassDecl Int32Class
     - type int32_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl Int32Class
====== Resolving type decl CoverDecl Int64
====== Resolving type decl ClassDecl Int64Class
     - type int64_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl Int64Class
====== Resolving type decl CoverDecl UInt8
====== Resolving type decl ClassDecl UInt8Class
     - type uint8_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl UInt8Class
====== Resolving type decl CoverDecl UInt16
====== Resolving type decl ClassDecl UInt16Class
     - type uint16_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl UInt16Class
====== Resolving type decl CoverDecl UInt32
====== Resolving type decl ClassDecl UInt32Class
     - type uint32_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl UInt32Class
====== Resolving type decl CoverDecl UInt64
====== Resolving type decl ClassDecl UInt64Class
     - type uint64_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl UInt64Class
====== Resolving type decl CoverDecl Octet
====== Resolving type decl ClassDecl OctetClass
     - type uint8_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl OctetClass
====== Resolving type decl CoverDecl SizeT
====== Resolving type decl ClassDecl SizeTClass
     - type size_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl SizeTClass
====== Resolving type decl CoverDecl Bool
====== Resolving type decl ClassDecl BoolClass
     - type bool still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl BoolClass
====== Resolving type decl CoverDecl LDouble
====== Resolving type decl ClassDecl LDoubleClass
Resolving variable decl str : String = gc_malloc(64)
gc_malloc(64) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
sprintf(str, "%.2Lf", this) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
     - type long double still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl LDoubleClass
Resolving variable decl str : String = gc_malloc(64)
====== Resolving type decl CoverDecl Double
====== Resolving type decl ClassDecl DoubleClass
     - type double still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl DoubleClass
====== Resolving type decl CoverDecl Float
====== Resolving type decl ClassDecl FloatClass
     - type float still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl FloatClass
====== Resolving type decl CoverDecl Range
Resolving variable decl min : Int
Resolving variable decl max : Int
====== Resolving type decl ClassDecl RangeClass
Resolving variable decl this : This
====== Resolving type decl ClassDecl RangeClass
Resolving variable decl this : Range
====== Resolving type decl ClassDecl Iterator
Resolving variable decl T : Class
Resolving variable decl T : Class
====== Resolving type decl ClassDecl IteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = Iterator alloc() as Iterator
Iterator alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl IteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterator = Iterator alloc() as Iterator
====== Resolving type decl ClassDecl Iterable
Resolving variable decl T : Class
Resolving variable decl T : Class
====== Resolving type decl ClassDecl IterableClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = Iterable alloc() as Iterable
Iterable alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl IterableClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterable = Iterable alloc() as Iterable
====== Resolving type decl ClassDecl StringIterator
Resolving variable decl T : Class
Resolving variable decl i : <unknown type> = 0
Resolving variable decl str : String
====== Resolving type decl ClassDecl StringIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = StringIterator alloc() as StringIterator
StringIterator alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(str) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=str (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
str length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl c : <unknown type> = str[i]
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For next: func , response of body = LOOP
Response of fDecl next: func  = LOOP
-- ClassDecl StringIteratorClass, meta of ClassDecl StringIterator, isn't resolved, looping.
response of tDecl ClassDecl StringIterator = LOOP
====== Resolving type decl ClassDecl StringIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringIterator = StringIterator alloc() as StringIterator
Resolving variable decl c : Char = str[i]
Resolving variable decl returnVal2 : <unknown type> = c
returnArg1 = returnVal2 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For prev: func , response of body = LOOP
Response of fDecl prev: func  = LOOP
response of tDecl ClassDecl StringIteratorClass = LOOP
====== Resolving type decl ClassDecl Exception
Resolving variable decl origin : Class
Resolving variable decl msg : String
====== Resolving type decl ClassDecl ExceptionClass
Resolving variable decl this : <unknown type> = Exception alloc() as Exception
Exception alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(origin, msg) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=origin (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=msg (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
Resolving variable decl this : <unknown type> = Exception alloc() as Exception
Exception alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(msg) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=msg (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
fflush(stdout) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl x : <unknown type> = 0
Resolving variable decl max : Int = 1024
Resolving variable decl buffer : <unknown type> = gc_malloc(max) as String
gc_malloc(max) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
snprintf(buffer, max, "[%s in %s]: %s\n", Class.name, Class.name, msg) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
snprintf(buffer, max, "[%s]: %s\n", Class.name, msg) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
this getMessage() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
fprintf(stderr, "%s", this getMessage()) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
this getMessage() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
printf("%s", this getMessage()) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
this print() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this crash() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl ExceptionClass
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl x : Int = 0
Resolving variable decl max : Int = 1024
Resolving variable decl buffer : String = gc_malloc(max) as String
Resolving variable decl str1 : String
Resolving variable decl str2 : String
str1 equals(str2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl str1 : String
Resolving variable decl str2 : String
str1 equals(str2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl str : String
Resolving variable decl count : Int
str times(count) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : String
Resolving variable decl right : String
left append(right) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : LLong
Resolving variable decl right : String
left toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
left toString() + right (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_LLong_String__String: func (left : LLong, right : String) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl left : String
Resolving variable decl right : LLong
right toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
left + right toString() (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_LLong__String: func (left : String, right : LLong) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl left : Int
Resolving variable decl right : String
left toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
left toString() + right (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_Int_String__String: func (left : Int, right : String) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl left : String
Resolving variable decl right : Int
right toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
left + right toString() (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Int__String: func (left : String, right : Int) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl left : Bool
Resolving variable decl right : String
left toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
left toString() + right (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_Bool_String__String: func (left : Bool, right : String) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl left : String
Resolving variable decl right : Bool
right toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
left + right toString() (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Bool__String: func (left : String, right : Bool) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl left : Double
Resolving variable decl right : String
left toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
left toString() + right (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_Double_String__String: func (left : Double, right : String) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl left : String
Resolving variable decl right : Double
right toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
left + right toString() (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Double__String: func (left : String, right : Double) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl left : String
Resolving variable decl right : Char
left append(right) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : Char
Resolving variable decl right : String
right prepend(left) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/math
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Int
Resolving variable decl Double
Resolving variable decl Float
Resolving variable decl LDouble
Resolving variable decl Double
Resolving variable decl Float
Resolving variable decl LDouble
Resolving variable decl Double
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module lang/math finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module sdl/Sdl
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl SDL_INIT_TIMER : Int
Resolving variable decl SDL_INIT_AUDIO : Int
Resolving variable decl SDL_INIT_VIDEO : Int
Resolving variable decl SDL_INIT_CDROM : Int
Resolving variable decl SDL_INIT_JOYSTICK : Int
Resolving variable decl SDL_INIT_NOPARACHUTE : Int
Resolving variable decl SDL_INIT_EVENTTHREAD : Int
Resolving variable decl SDL_INIT_EVERYTHING : Int
Resolving variable decl SDL_SWSURFACE : Int
Resolving variable decl SDL_HWSURFACE : Int
Resolving variable decl SDL_ASYNCBLIT : Int
Resolving variable decl SDL_ANYFORMAT : Int
Resolving variable decl SDL_HWPALETTE : Int
Resolving variable decl SDL_DOUBLEBUF : Int
Resolving variable decl SDL_FULLSCREEN : Int
Resolving variable decl SDL_OPENGL : Int
Resolving variable decl SDL_OPENGLBLIT : Int
Resolving variable decl SDL_RESIZABLE : Int
Resolving variable decl SDL_NOFRAME : Int
Resolving variable decl SDL_GL_DOUBLEBUFFER : Int
Resolving variable decl SDL_HWACCEL : Int
Resolving variable decl SDL_SRCCOLORKEY : Int
Resolving variable decl SDL_RLEACCELOK : Int
Resolving variable decl SDL_RLEACCEL : Int
Resolving variable decl SDL_SRCALPHA : Int
Resolving variable decl SDL_PREALLOC : Int
Resolving variable decl SDL_GL_ALPHA_SIZE : Int
Resolving variable decl SDL_GL_RED_SIZE : Int
Resolving variable decl SDL_GL_GREEN_SIZE : Int
Resolving variable decl SDL_GL_BLUE_SIZE : Int
Resolving variable decl SDL_GL_DEPTH_SIZE : Int
Resolving variable decl SDL_GL_DOUBLEBUFFER : Int
Resolving variable decl SDL_QUIT : Int
Resolving variable decl SDL_KEYDOWN : Int
Resolving variable decl SDL_KEYUP : Int
Resolving variable decl SDL_ENABLE : Int
Resolving variable decl SDL_DISABLE : Int
Resolving variable decl SDL_GRAB_ON : Int
====== Resolving type decl CoverDecl Surface
Resolving variable decl w : Int
Resolving variable decl h : Int
Resolving variable decl pixels : Int
====== Resolving type decl ClassDecl SurfaceClass
     - type SDL_Surface still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl SurfaceClass
====== Resolving type decl CoverDecl VideoInfo
Resolving variable decl hw_available : Int
Resolving variable decl blit_hw : Int
====== Resolving type decl ClassDecl VideoInfoClass
     - type SDL_VideoInfo still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl VideoInfoClass
====== Resolving type decl CoverDecl SDL
====== Resolving type decl ClassDecl SDLClass
Resolving variable decl UInt32
Resolving variable decl UInt32
Resolving variable decl UInt32
Resolving variable decl UInt32
Resolving variable decl String
Resolving variable decl String
Resolving variable decl Void*
Resolving variable decl String
Resolving variable decl Void*
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Surface*
Resolving variable decl String
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int*
Resolving variable decl Int*
Resolving variable decl Int*
Resolving variable decl UInt32
Resolving variable decl enable : Int
====== Resolving type decl ClassDecl SDLClass
Resolving variable decl UInt32
Resolving variable decl UInt32
Resolving variable decl UInt32
Resolving variable decl UInt32
Resolving variable decl String
Resolving variable decl String
Resolving variable decl Void*
Resolving variable decl String
Resolving variable decl Void*
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Surface*
Resolving variable decl String
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int*
Resolving variable decl Int*
Resolving variable decl Int*
Resolving variable decl UInt32
Resolving variable decl enable : Int
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module sdl/Sdl finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module sdl/Video
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl CoverDecl SDLVideo
====== Resolving type decl ClassDecl SDLVideoClass
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl UInt32
Resolving variable decl String
Resolving variable decl String
====== Resolving type decl ClassDecl SDLVideoClass
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl UInt32
Resolving variable decl String
Resolving variable decl String
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module sdl/Video finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module sdl/Event
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl SDLK_UNKNOWN : Int = 0
Resolving variable decl SDLK_FIRST : Int = 0
Resolving variable decl SDLK_BACKSPACE : Int = 8
Resolving variable decl SDLK_TAB : Int = 9
Resolving variable decl SDLK_CLEAR : Int = 12
Resolving variable decl SDLK_RETURN : Int = 13
Resolving variable decl SDLK_PAUSE : Int = 19
Resolving variable decl SDLK_ESCAPE : Int = 27
Resolving variable decl SDLK_SPACE : Int = 32
Resolving variable decl SDLK_EXCLAIM : Int = 33
Resolving variable decl SDLK_QUOTEDBL : Int = 34
Resolving variable decl SDLK_HASH : Int = 35
Resolving variable decl SDLK_DOLLAR : Int = 36
Resolving variable decl SDLK_AMPERSAND : Int = 38
Resolving variable decl SDLK_QUOTE : Int = 39
Resolving variable decl SDLK_LEFTPAREN : Int = 40
Resolving variable decl SDLK_RIGHTPAREN : Int = 41
Resolving variable decl SDLK_ASTERISK : Int = 42
Resolving variable decl SDLK_PLUS : Int = 43
Resolving variable decl SDLK_COMMA : Int = 44
Resolving variable decl SDLK_MINUS : Int = 45
Resolving variable decl SDLK_PERIOD : Int = 46
Resolving variable decl SDLK_SLASH : Int = 47
Resolving variable decl SDLK_0 : Int = 48
Resolving variable decl SDLK_1 : Int = 49
Resolving variable decl SDLK_2 : Int = 50
Resolving variable decl SDLK_3 : Int = 51
Resolving variable decl SDLK_4 : Int = 52
Resolving variable decl SDLK_5 : Int = 53
Resolving variable decl SDLK_6 : Int = 54
Resolving variable decl SDLK_7 : Int = 55
Resolving variable decl SDLK_8 : Int = 56
Resolving variable decl SDLK_9 : Int = 57
Resolving variable decl SDLK_COLON : Int = 58
Resolving variable decl SDLK_SEMICOLON : Int = 59
Resolving variable decl SDLK_LESS : Int = 60
Resolving variable decl SDLK_EQUALS : Int = 61
Resolving variable decl SDLK_GREATER : Int = 62
Resolving variable decl SDLK_QUESTION : Int = 63
Resolving variable decl SDLK_AT : Int = 64
Resolving variable decl SDLK_LEFTBRACKET : Int = 91
Resolving variable decl SDLK_BACKSLASH : Int = 92
Resolving variable decl SDLK_RIGHTBRACKET : Int = 93
Resolving variable decl SDLK_CARET : Int = 94
Resolving variable decl SDLK_UNDERSCORE : Int = 95
Resolving variable decl SDLK_BACKQUOTE : Int = 96
Resolving variable decl SDLK_a : Int = 97
Resolving variable decl SDLK_b : Int = 98
Resolving variable decl SDLK_c : Int = 99
Resolving variable decl SDLK_d : Int = 100
Resolving variable decl SDLK_e : Int = 101
Resolving variable decl SDLK_f : Int = 102
Resolving variable decl SDLK_g : Int = 103
Resolving variable decl SDLK_h : Int = 104
Resolving variable decl SDLK_i : Int = 105
Resolving variable decl SDLK_j : Int = 106
Resolving variable decl SDLK_k : Int = 107
Resolving variable decl SDLK_l : Int = 108
Resolving variable decl SDLK_m : Int = 109
Resolving variable decl SDLK_n : Int = 110
Resolving variable decl SDLK_o : Int = 111
Resolving variable decl SDLK_p : Int = 112
Resolving variable decl SDLK_q : Int = 113
Resolving variable decl SDLK_r : Int = 114
Resolving variable decl SDLK_s : Int = 115
Resolving variable decl SDLK_t : Int = 116
Resolving variable decl SDLK_u : Int = 117
Resolving variable decl SDLK_v : Int = 118
Resolving variable decl SDLK_w : Int = 119
Resolving variable decl SDLK_x : Int = 120
Resolving variable decl SDLK_y : Int = 121
Resolving variable decl SDLK_z : Int = 122
Resolving variable decl SDLK_DELETE : Int = 127
Resolving variable decl SDLK_WORLD_0 : Int = 160
Resolving variable decl SDLK_WORLD_1 : Int = 161
Resolving variable decl SDLK_WORLD_2 : Int = 162
Resolving variable decl SDLK_WORLD_3 : Int = 163
Resolving variable decl SDLK_WORLD_4 : Int = 164
Resolving variable decl SDLK_WORLD_5 : Int = 165
Resolving variable decl SDLK_WORLD_6 : Int = 166
Resolving variable decl SDLK_WORLD_7 : Int = 167
Resolving variable decl SDLK_WORLD_8 : Int = 168
Resolving variable decl SDLK_WORLD_9 : Int = 169
Resolving variable decl SDLK_WORLD_10 : Int = 170
Resolving variable decl SDLK_WORLD_11 : Int = 171
Resolving variable decl SDLK_WORLD_12 : Int = 172
Resolving variable decl SDLK_WORLD_13 : Int = 173
Resolving variable decl SDLK_WORLD_14 : Int = 174
Resolving variable decl SDLK_WORLD_15 : Int = 175
Resolving variable decl SDLK_WORLD_16 : Int = 176
Resolving variable decl SDLK_WORLD_17 : Int = 177
Resolving variable decl SDLK_WORLD_18 : Int = 178
Resolving variable decl SDLK_WORLD_19 : Int = 179
Resolving variable decl SDLK_WORLD_20 : Int = 180
Resolving variable decl SDLK_WORLD_21 : Int = 181
Resolving variable decl SDLK_WORLD_22 : Int = 182
Resolving variable decl SDLK_WORLD_23 : Int = 183
Resolving variable decl SDLK_WORLD_24 : Int = 184
Resolving variable decl SDLK_WORLD_25 : Int = 185
Resolving variable decl SDLK_WORLD_26 : Int = 186
Resolving variable decl SDLK_WORLD_27 : Int = 187
Resolving variable decl SDLK_WORLD_28 : Int = 188
Resolving variable decl SDLK_WORLD_29 : Int = 189
Resolving variable decl SDLK_WORLD_30 : Int = 190
Resolving variable decl SDLK_WORLD_31 : Int = 191
Resolving variable decl SDLK_WORLD_32 : Int = 192
Resolving variable decl SDLK_WORLD_33 : Int = 193
Resolving variable decl SDLK_WORLD_34 : Int = 194
Resolving variable decl SDLK_WORLD_35 : Int = 195
Resolving variable decl SDLK_WORLD_36 : Int = 196
Resolving variable decl SDLK_WORLD_37 : Int = 197
Resolving variable decl SDLK_WORLD_38 : Int = 198
Resolving variable decl SDLK_WORLD_39 : Int = 199
Resolving variable decl SDLK_WORLD_40 : Int = 200
Resolving variable decl SDLK_WORLD_41 : Int = 201
Resolving variable decl SDLK_WORLD_42 : Int = 202
Resolving variable decl SDLK_WORLD_43 : Int = 203
Resolving variable decl SDLK_WORLD_44 : Int = 204
Resolving variable decl SDLK_WORLD_45 : Int = 205
Resolving variable decl SDLK_WORLD_46 : Int = 206
Resolving variable decl SDLK_WORLD_47 : Int = 207
Resolving variable decl SDLK_WORLD_48 : Int = 208
Resolving variable decl SDLK_WORLD_49 : Int = 209
Resolving variable decl SDLK_WORLD_50 : Int = 210
Resolving variable decl SDLK_WORLD_51 : Int = 211
Resolving variable decl SDLK_WORLD_52 : Int = 212
Resolving variable decl SDLK_WORLD_53 : Int = 213
Resolving variable decl SDLK_WORLD_54 : Int = 214
Resolving variable decl SDLK_WORLD_55 : Int = 215
Resolving variable decl SDLK_WORLD_56 : Int = 216
Resolving variable decl SDLK_WORLD_57 : Int = 217
Resolving variable decl SDLK_WORLD_58 : Int = 218
Resolving variable decl SDLK_WORLD_59 : Int = 219
Resolving variable decl SDLK_WORLD_60 : Int = 220
Resolving variable decl SDLK_WORLD_61 : Int = 221
Resolving variable decl SDLK_WORLD_62 : Int = 222
Resolving variable decl SDLK_WORLD_63 : Int = 223
Resolving variable decl SDLK_WORLD_64 : Int = 224
Resolving variable decl SDLK_WORLD_65 : Int = 225
Resolving variable decl SDLK_WORLD_66 : Int = 226
Resolving variable decl SDLK_WORLD_67 : Int = 227
Resolving variable decl SDLK_WORLD_68 : Int = 228
Resolving variable decl SDLK_WORLD_69 : Int = 229
Resolving variable decl SDLK_WORLD_70 : Int = 230
Resolving variable decl SDLK_WORLD_71 : Int = 231
Resolving variable decl SDLK_WORLD_72 : Int = 232
Resolving variable decl SDLK_WORLD_73 : Int = 233
Resolving variable decl SDLK_WORLD_74 : Int = 234
Resolving variable decl SDLK_WORLD_75 : Int = 235
Resolving variable decl SDLK_WORLD_76 : Int = 236
Resolving variable decl SDLK_WORLD_77 : Int = 237
Resolving variable decl SDLK_WORLD_78 : Int = 238
Resolving variable decl SDLK_WORLD_79 : Int = 239
Resolving variable decl SDLK_WORLD_80 : Int = 240
Resolving variable decl SDLK_WORLD_81 : Int = 241
Resolving variable decl SDLK_WORLD_82 : Int = 242
Resolving variable decl SDLK_WORLD_83 : Int = 243
Resolving variable decl SDLK_WORLD_84 : Int = 244
Resolving variable decl SDLK_WORLD_85 : Int = 245
Resolving variable decl SDLK_WORLD_86 : Int = 246
Resolving variable decl SDLK_WORLD_87 : Int = 247
Resolving variable decl SDLK_WORLD_88 : Int = 248
Resolving variable decl SDLK_WORLD_89 : Int = 249
Resolving variable decl SDLK_WORLD_90 : Int = 250
Resolving variable decl SDLK_WORLD_91 : Int = 251
Resolving variable decl SDLK_WORLD_92 : Int = 252
Resolving variable decl SDLK_WORLD_93 : Int = 253
Resolving variable decl SDLK_WORLD_94 : Int = 254
Resolving variable decl SDLK_WORLD_95 : Int = 255
Resolving variable decl SDLK_KP0 : Int = 256
Resolving variable decl SDLK_KP1 : Int = 257
Resolving variable decl SDLK_KP2 : Int = 258
Resolving variable decl SDLK_KP3 : Int = 259
Resolving variable decl SDLK_KP4 : Int = 260
Resolving variable decl SDLK_KP5 : Int = 261
Resolving variable decl SDLK_KP6 : Int = 262
Resolving variable decl SDLK_KP7 : Int = 263
Resolving variable decl SDLK_KP8 : Int = 264
Resolving variable decl SDLK_KP9 : Int = 265
Resolving variable decl SDLK_KP_PERIOD : Int = 266
Resolving variable decl SDLK_KP_DIVIDE : Int = 267
Resolving variable decl SDLK_KP_MULTIPLY : Int = 268
Resolving variable decl SDLK_KP_MINUS : Int = 269
Resolving variable decl SDLK_KP_PLUS : Int = 270
Resolving variable decl SDLK_KP_ENTER : Int = 271
Resolving variable decl SDLK_KP_EQUALS : Int = 272
Resolving variable decl SDLK_UP : Int = 273
Resolving variable decl SDLK_DOWN : Int = 274
Resolving variable decl SDLK_RIGHT : Int = 275
Resolving variable decl SDLK_LEFT : Int = 276
Resolving variable decl SDLK_INSERT : Int = 277
Resolving variable decl SDLK_HOME : Int = 278
Resolving variable decl SDLK_END : Int = 279
Resolving variable decl SDLK_PAGEUP : Int = 280
Resolving variable decl SDLK_PAGEDOWN : Int = 281
Resolving variable decl SDLK_F1 : Int = 282
Resolving variable decl SDLK_F2 : Int = 283
Resolving variable decl SDLK_F3 : Int = 284
Resolving variable decl SDLK_F4 : Int = 285
Resolving variable decl SDLK_F5 : Int = 286
Resolving variable decl SDLK_F6 : Int = 287
Resolving variable decl SDLK_F7 : Int = 288
Resolving variable decl SDLK_F8 : Int = 289
Resolving variable decl SDLK_F9 : Int = 290
Resolving variable decl SDLK_F10 : Int = 291
Resolving variable decl SDLK_F11 : Int = 292
Resolving variable decl SDLK_F12 : Int = 293
Resolving variable decl SDLK_F13 : Int = 294
Resolving variable decl SDLK_F14 : Int = 295
Resolving variable decl SDLK_F15 : Int = 296
Resolving variable decl SDLK_NUMLOCK : Int = 300
Resolving variable decl SDLK_CAPSLOCK : Int = 301
Resolving variable decl SDLK_SCROLLOCK : Int = 302
Resolving variable decl SDLK_RSHIFT : Int = 303
Resolving variable decl SDLK_LSHIFT : Int = 304
Resolving variable decl SDLK_RCTRL : Int = 305
Resolving variable decl SDLK_LCTRL : Int = 306
Resolving variable decl SDLK_RALT : Int = 307
Resolving variable decl SDLK_LALT : Int = 308
Resolving variable decl SDLK_RMETA : Int = 309
Resolving variable decl SDLK_LMETA : Int = 310
Resolving variable decl SDLK_LSUPER : Int = 311
Resolving variable decl SDLK_RSUPER : Int = 312
Resolving variable decl SDLK_MODE : Int = 313
Resolving variable decl SDLK_COMPOSE : Int = 314
Resolving variable decl SDLK_HELP : Int = 315
Resolving variable decl SDLK_PRINT : Int = 316
Resolving variable decl SDLK_SYSREQ : Int = 317
Resolving variable decl SDLK_BREAK : Int = 318
Resolving variable decl SDLK_MENU : Int = 319
Resolving variable decl SDLK_POWER : Int = 320
Resolving variable decl SDLK_EURO : Int = 321
Resolving variable decl SDLK_UNDO : Int = 322
Resolving variable decl SDL_VIDEOEXPOSE : Int
Resolving variable decl SDL_MOUSEBUTTONUP : Int
Resolving variable decl SDL_MOUSEBUTTONDOWN : Int
Resolving variable decl SDL_BUTTON_WHEELUP : Int
Resolving variable decl SDL_BUTTON_RIGHT : Int
Resolving variable decl SDL_BUTTON_LEFT : Int
Resolving variable decl SDL_BUTTON_WHEELDOWN : Int
Resolving variable decl SDL_MOUSEMOTION : Int
Resolving variable decl SDL_ACTIVEEVENT : Int
Resolving variable decl SDL_VIDEORESIZE : Int
Resolving variable decl KMOD_LCTRL : Int
Resolving variable decl KMOD_RCTRL : Int
Resolving variable decl KMOD_SHIFT : Int
Resolving variable decl KMOD_LSHIFT : Int
Resolving variable decl KMOD_RSHIFT : Int
====== Resolving type decl CoverDecl Motion
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl xrel : Int
Resolving variable decl yrel : Int
====== Resolving type decl ClassDecl MotionClass
     - type SDL_MouseMotionEvent still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl MotionClass
====== Resolving type decl CoverDecl Keysym
Resolving variable decl sym : Int
Resolving variable decl unicode : Int
====== Resolving type decl ClassDecl KeysymClass
     - type SDL_keysym still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl KeysymClass
====== Resolving type decl CoverDecl Button
Resolving variable decl button : Int
====== Resolving type decl ClassDecl ButtonClass
     - type SDL_MouseButtonEvent still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl ButtonClass
====== Resolving type decl CoverDecl Active
Resolving variable decl gain : UInt8
====== Resolving type decl ClassDecl ActiveClass
     - type SDL_ActiveEvent still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl ActiveClass
====== Resolving type decl CoverDecl Key
Resolving variable decl keysym : Keysym
====== Resolving type decl ClassDecl KeyClass
     - type SDL_KeyboardEvent still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl KeyClass
====== Resolving type decl CoverDecl Resize
Resolving variable decl w : Int
Resolving variable decl h : Int
====== Resolving type decl ClassDecl ResizeClass
     - type SDL_ResizeEvent still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl ResizeClass
====== Resolving type decl CoverDecl Event
Resolving variable decl type : Int
Resolving variable decl key : Key
Resolving variable decl motion : Motion
Resolving variable decl active : Active
Resolving variable decl resize : Resize
Resolving variable decl button : Button
====== Resolving type decl ClassDecl EventClass
     - type SDL_Event still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl EventClass
====== Resolving type decl CoverDecl SDLEvent
====== Resolving type decl ClassDecl SDLEventClass
Resolving variable decl Event*
Resolving variable decl Event*
====== Resolving type decl ClassDecl SDLEventClass
Resolving variable decl Event*
Resolving variable decl Event*
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module sdl/Event finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module ITask
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl ITask
Resolving variable decl canKill : Bool
Resolving variable decl priority : Long
====== Resolving type decl ClassDecl ITaskClass
Resolving variable decl this : <unknown type> = ITask alloc() as ITask
ITask alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ITask alloc() (of type FunctionCall) wants to wholeAgain() because 'ITask alloc() looping because not resolved!'
this : ITask = ITask alloc() as ITask (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl ITaskClass
Resolving variable decl this : ITask = ITask alloc() as ITask
ITask alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ITask alloc() (of type FunctionCall) wants to wholeAgain() because 'ITask alloc() looping because not resolved!'
this : ITask = ITask alloc() as ITask (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module Listener
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Listener
====== Resolving type decl ClassDecl ListenerClass
Resolving variable decl this : <unknown type> = Listener alloc() as Listener
Listener alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl event : Event
====== Resolving type decl ClassDecl ListenerClass
Resolving variable decl this : Listener = Listener alloc() as Listener
Resolving variable decl event : Event
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CLog
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl LOG_APP : <unknown type> = 1
Resolving variable decl LOG_CLIENT : <unknown type> = 2
Resolving variable decl LOG_SERVER : <unknown type> = 4
Resolving variable decl LOG_USER : <unknown type> = 8
Resolving variable decl MAX_LOG_STRINGS : <unknown type> = 256
====== Resolving type decl ClassDecl CLog
Resolving variable decl appLog : FileWriter
Resolving variable decl clientLog : FileWriter
Resolving variable decl serverLog : FileWriter
====== Resolving type decl ClassDecl CLogClass
Resolving variable decl instance : This = NullLiteral
This new() (of type FunctionCall) wants to wholeAgain() because 'because of return type CLog'
Resolving variable decl this : <unknown type> = CLog alloc() as CLog
CLog alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this start() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
FileWriter new("applog.txt") (of type FunctionCall) wants to wholeAgain() because 'because of return type FileWriter'
FileWriter new("applog.txt") (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FileWriter new("applog.txt") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
FileWriter new("clntlog.txt") (of type FunctionCall) wants to wholeAgain() because 'because of return type FileWriter'
FileWriter new("clntlog.txt") (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FileWriter new("clntlog.txt") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
FileWriter new("srvrlog.txt") (of type FunctionCall) wants to wholeAgain() because 'because of return type FileWriter'
FileWriter new("srvrlog.txt") (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FileWriter new("srvrlog.txt") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl target : Int
Resolving variable decl msg : String
appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
clientLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
clientLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
clientLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
serverLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
serverLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
serverLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
printf("writing server log\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl target : Int
Resolving variable decl msgID : ULong
====== Resolving type decl ClassDecl CLogClass
Resolving variable decl instance : CLog = NullLiteral
Resolving variable decl this : CLog = CLog alloc() as CLog
this start() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
FileWriter new("applog.txt") (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FileWriter new("applog.txt") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
FileWriter new("clntlog.txt") (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FileWriter new("clntlog.txt") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
FileWriter new("srvrlog.txt") (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FileWriter new("srvrlog.txt") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl target : Int
Resolving variable decl msg : String
CLog.appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CLog.appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
CLog.clientLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CLog.clientLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
CLog.serverLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CLog.serverLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
CLog.appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CLog.appLog write(msg) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl target : Int
Resolving variable decl msgID : ULong
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/FileWriter
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl FileWriter
Resolving variable decl file : FStream
====== Resolving type decl ClassDecl FileWriterClass
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl this : <unknown type> = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init(fileObject, append) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
fileObject getPath() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
init(fileObject getPath(), append) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
init(fileObject getPath(), append) (of type FunctionCall) wants to wholeAgain() because 'init(fileObject getPath(), append) looping because not resolved!'
Resolving variable decl fileObject : File
Resolving variable decl this : <unknown type> = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init(fileObject) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileObject : File
this init(fileObject, false) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl this : <unknown type> = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init(fileName, append) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
Resolving variable decl append : Bool
fopen(fileName, append ? "a" : "w") (of type FunctionCall) wants to wholeAgain() because 'because of return type FStream'
"File not found: " + fileName (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) looping because not resolved!'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) throw() looping because not resolved!'
Resolving variable decl fileName : String
Resolving variable decl this : <unknown type> = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init(fileName) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
this init(fileName, false) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
Resolving variable decl this : <unknown type> = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init(fileName) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
this init(fileName, false) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl chars : String
Resolving variable decl length : SizeT
file write(chars, 0, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl chr : Char
file write(chr) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
fclose(file) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl fmt : String
Resolving variable decl ap : VaList
va_start(ap, fmt) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
fprintf(file, fmt, ap) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
va_end(ap) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fmt : String
Resolving variable decl args : VaList
vfprintf(file, fmt, args) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
====== Resolving type decl ClassDecl FileWriterClass
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
fileObject getPath() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
init(fileObject getPath(), append) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
init(fileObject getPath(), append) (of type FunctionCall) wants to wholeAgain() because 'init(fileObject getPath(), append) looping because not resolved!'
Resolving variable decl fileObject : File
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
Resolving variable decl fileName : String
Resolving variable decl append : Bool
__OP_ADD_String_String__String("File not found: ", fileName) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
Resolving variable decl fileName : String
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'FileWriter alloc() looping because not resolved!'
this : FileWriter = FileWriter alloc() as FileWriter (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
Resolving variable decl fileName : String
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl fmt : String
Resolving variable decl ap : VaList
Resolving variable decl fmt : String
Resolving variable decl args : VaList
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/Writer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Writer
====== Resolving type decl ClassDecl WriterClass
Resolving variable decl this : <unknown type> = Writer alloc() as Writer
Writer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chars : String
chars length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this write(chars, chars length()) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
====== Resolving type decl ClassDecl WriterClass
Resolving variable decl this : Writer = Writer alloc() as Writer
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chars : String
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/File
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl File
Resolving variable decl path : String
====== Resolving type decl ClassDecl FileClass
Resolving variable decl MAX_PATH_LENGTH : <unknown type> = 16383
Resolving variable decl separator : Char = CharLiteral
Resolving variable decl pathDelimiter : Char = CharLiteral
FileUnix new(path) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileUnix new(path) (of type FunctionCall) wants to wholeAgain() because 'FileUnix new(path) looping because not resolved!'
return FileUnix new(path) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
FileWin32 new(path) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWin32 new(path) (of type FunctionCall) wants to wholeAgain() because 'FileWin32 new(path) looping because not resolved!'
return FileWin32 new(path) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Exception new(This, "Unsupported platform!\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Unsupported platform!\n") throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl parent : File
File.path + FileClass.separator (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Char__String(File.path, FileClass.separator) + path (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Char__String(File.path, FileClass.separator) + path (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Char__String(File.path, FileClass.separator) (who is null? true, false, false, false)'
new(__OP_ADD_String_Char__String(File.path, FileClass.separator) + path) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
new(__OP_ADD_String_Char__String(File.path, FileClass.separator) + path) (of type FunctionCall) wants to wholeAgain() because 'new(__OP_ADD_String_Char__String(File.path, FileClass.separator) + path) looping because not resolved!'
return new(__OP_ADD_String_Char__String(File.path, FileClass.separator) + path) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl parent : String
parent + FileClass.separator (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Char__String(parent, FileClass.separator) + path (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Char__String(parent, FileClass.separator) + path (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Char__String(parent, FileClass.separator) (who is null? true, false, false, false)'
new(__OP_ADD_String_Char__String(parent, FileClass.separator) + path) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
new(__OP_ADD_String_Char__String(parent, FileClass.separator) + path) (of type FunctionCall) wants to wholeAgain() because 'new(__OP_ADD_String_Char__String(parent, FileClass.separator) + path) looping because not resolved!'
return new(__OP_ADD_String_Char__String(parent, FileClass.separator) + path) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
fopen(path, "r") (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fopen(path, "r") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl trimmed : <unknown type> = path trim(separator)
path trim(FileClass.separator) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl idx : <unknown type> = trimmed lastIndexOf(separator)
trimmed lastIndexOf(FileClass.separator) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
trimmed substring(idx + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl pName : <unknown type> = parentName()
this parentName() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
pName : <unknown type> = this parentName() (of type VariableDecl) wants to wholeAgain() because 'must determine type of pName : <unknown type> = this parentName()
'
File new(pName) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
File new(pName) (of type FunctionCall) wants to wholeAgain() because 'File new(pName) looping because not resolved!'
return File new(pName) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl idx : <unknown type> = path lastIndexOf(separator)
path lastIndexOf(FileClass.separator) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
path substring(0, idx) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this mkdir(493) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this mkdir(493) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this mkdir(493) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
mkdir: func  -> Int (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl mode : Int32
this mkdirs(493) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this mkdirs(493) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this mkdirs(493) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl mode : Int32
Resolving variable decl parent : <unknown type> = parent()
this parent() (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
parent : File = this parent() (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
parent mkdirs() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this mkdir() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
this getAbsolutePath() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
File new(this getAbsolutePath()) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
_remove(File.path) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
_remove(File.path) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
_remove(File.path) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
remove: func  -> Int (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl dstFile : This
dstFile parent() (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
dstFile parent() mkdirs() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl src : <unknown type> = FileReader new(this)
FileReader new(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type FileReader'
FileReader new(this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FileReader new(this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl dst : <unknown type> = FileWriter new(dstFile)
FileWriter new(dstFile) (of type FunctionCall) wants to wholeAgain() because 'because of return type FileWriter'
Resolving variable decl max : <unknown type> = 8192
Resolving variable decl buffer : Char[max]
src hasNext() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl num : <unknown type> = src read(buffer, 0, max)
src read(buffer, 0, max) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
src read(buffer, 0, max) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
src read(buffer, 0, max) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
num : <unknown type> = src read(buffer, 0, max) (of type VariableDecl) wants to wholeAgain() because 'must determine type of num : <unknown type> = src read(buffer, 0, max)
'
dst write(buffer, num) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
dst write(buffer, num) (of type FunctionCall) wants to wholeAgain() because 'dst write(buffer, num) looping because not resolved!'
dst close() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
src close() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl name : String
File.path + FileClass.separator (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Char__String(File.path, FileClass.separator) + name (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Char__String(File.path, FileClass.separator) + name (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Char__String(File.path, FileClass.separator) (who is null? true, false, false, false)'
new(__OP_ADD_String_Char__String(File.path, FileClass.separator) + name) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
new(__OP_ADD_String_Char__String(File.path, FileClass.separator) + name) (of type FunctionCall) wants to wholeAgain() because 'new(__OP_ADD_String_Char__String(File.path, FileClass.separator) + name) looping because not resolved!'
getChild: func (name : String) -> File (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl ret : <unknown type> = String new(MAX_PATH_LENGTH + 1)
String new(FileClass.MAX_PATH_LENGTH + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
_getcwd(ret, FileClass.MAX_PATH_LENGTH) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
_getcwd(ret, FileClass.MAX_PATH_LENGTH) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
_getcwd(ret, FileClass.MAX_PATH_LENGTH) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
====== Resolving type decl ClassDecl FileClass
Resolving variable decl MAX_PATH_LENGTH : Int = 16383
Resolving variable decl separator : Char = CharLiteral
Resolving variable decl pathDelimiter : Char = CharLiteral
FileUnix new(path) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileUnix new(path) (of type FunctionCall) wants to wholeAgain() because 'FileUnix new(path) looping because not resolved!'
return FileUnix new(path) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
FileWin32 new(path) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileWin32 new(path) (of type FunctionCall) wants to wholeAgain() because 'FileWin32 new(path) looping because not resolved!'
return FileWin32 new(path) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl parent : File
__OP_ADD_String_Char__String(File.path, FileClass.separator) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Char__String(File.path, FileClass.separator) + path (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), path)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), path)) (of type FunctionCall) wants to wholeAgain() because 'new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), path)) looping because not resolved!'
return new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), path)) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl parent : String
__OP_ADD_String_Char__String(parent, FileClass.separator) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Char__String(parent, FileClass.separator) + path (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(parent, FileClass.separator), path)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(parent, FileClass.separator), path)) (of type FunctionCall) wants to wholeAgain() because 'new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(parent, FileClass.separator), path)) looping because not resolved!'
return new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(parent, FileClass.separator), path)) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
fopen(File.path, "r") (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fopen(File.path, "r") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl trimmed : String = path trim(FileClass.separator)
Resolving variable decl idx : Int = trimmed lastIndexOf(FileClass.separator)
Resolving variable decl pName : <unknown type> = this parentName()
this parentName() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
File new(pName) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
Resolving variable decl idx : Int = path lastIndexOf(FileClass.separator)
this mkdir(493) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl mode : Int32
this mkdirs(493) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
_remove(File.path) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
_remove(File.path) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
_remove(File.path) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
remove: func  -> Int (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl dstFile : File
Resolving variable decl src : FileReader = FileReader new(this)
FileReader new(this) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FileReader new(this) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl dst : FileWriter = FileWriter new(dstFile)
Resolving variable decl max : Int = 8192
Resolving variable decl buffer : Char[max]
src hasNext() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl num : <unknown type> = src read(buffer, 0, max)
src read(buffer, 0, max) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
src read(buffer, 0, max) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
src read(buffer, 0, max) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
num : <unknown type> = src read(buffer, 0, max) (of type VariableDecl) wants to wholeAgain() because 'must determine type of num : <unknown type> = src read(buffer, 0, max)
'
dst write(buffer, num) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
dst write(buffer, num) (of type FunctionCall) wants to wholeAgain() because 'dst write(buffer, num) looping because not resolved!'
Resolving variable decl name : String
__OP_ADD_String_Char__String(File.path, FileClass.separator) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Char__String(File.path, FileClass.separator) + name (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), name)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), name)) (of type FunctionCall) wants to wholeAgain() because 'new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), name)) looping because not resolved!'
getChild: func (name : String) -> File (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl ret : String = String new(FileClass.MAX_PATH_LENGTH + 1)
_getcwd(ret, FileClass.MAX_PATH_LENGTH) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
_getcwd(ret, FileClass.MAX_PATH_LENGTH) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
_getcwd(ret, FileClass.MAX_PATH_LENGTH) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/ArrayList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl ArrayList
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
Resolving variable decl T : Class
Resolving variable decl data : T*
Resolving variable decl capacity : Int
Resolving variable decl size : Int = 0
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'ArrayList alloc() looping because not resolved!'
this : ArrayList = ArrayList alloc() as ArrayList (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
     - access to this->T still not resolved, looping (ref = (nil))
ArrayList.T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve ArrayList.T'
ArrayList.T = T (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
init(10) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
init(10) (of type FunctionCall) wants to wholeAgain() because 'init(10) looping because not resolved!'
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'ArrayList alloc() looping because not resolved!'
this : ArrayList = ArrayList alloc() as ArrayList (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
     - access to this->T still not resolved, looping (ref = (nil))
ArrayList.T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve ArrayList.T'
ArrayList.T = T (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(capacity) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=capacity (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
capacity * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
capacity * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = capacity (who is null? false, false, true, false)'
gc_malloc(capacity * size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'ArrayList alloc() looping because not resolved!'
this : ArrayList = ArrayList alloc() as ArrayList (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
     - access to this->T still not resolved, looping (ref = (nil))
ArrayList.T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve ArrayList.T'
ArrayList.T = T (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(data, size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=size (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? false, false, true, false)'
gc_malloc(size * size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? false, false, true, false)'
memcpy(ArrayList.data, data, size * size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl element : T
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
data[size * size] = element (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl index : Int
Resolving variable decl element : T
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
data + (size) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
data + (size) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = data (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? true, false, false, false)'
memmove(dst, src, size * size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
memmove(dst, src, size * size) (of type FunctionCall) wants to wholeAgain() because 'memmove(dst, src, size * size) looping because not resolved!'
data[0 * size] = element (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
this add(element) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * (index + 1) (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * (index + 1) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? true, false, false, false)'
data + (size * (index + 1)) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
data + (size * (index + 1)) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = data (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * index (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * index (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? true, false, false, false)'
data + (size * index) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
data + (size * index) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = data (who is null? false, false, true, false)'
Resolving variable decl bsize : <unknown type> = (size - index) * size
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
(size - index) * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
(size - index) * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = (size - index) (who is null? false, false, true, false)'
memmove(dst, src, bsize) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
data[index * size] = element (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl index : Int
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For get: func (index : Int), response of body = LOOP
Response of fDecl get: func (index : Int) = LOOP
-- ClassDecl ArrayListClass, meta of ClassDecl ArrayList, isn't resolved, looping.
response of tDecl ClassDecl ArrayList = LOOP
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'ArrayList alloc() looping because not resolved!'
this : ArrayList = ArrayList alloc() as ArrayList (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
     - access to this->T still not resolved, looping (ref = (nil))
ArrayList.T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve ArrayList.T'
ArrayList.T = T (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
this init(10) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'ArrayList alloc() looping because not resolved!'
this : ArrayList = ArrayList alloc() as ArrayList (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
     - access to this->T still not resolved, looping (ref = (nil))
ArrayList.T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve ArrayList.T'
ArrayList.T = T (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
capacity * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
capacity * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = capacity (who is null? false, false, true, false)'
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'ArrayList alloc() looping because not resolved!'
this : ArrayList = ArrayList alloc() as ArrayList (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
     - access to this->T still not resolved, looping (ref = (nil))
ArrayList.T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve ArrayList.T'
ArrayList.T = T (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? false, false, true, false)'
Resolving variable decl element : T
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
ArrayList.size * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
ArrayList.size * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = ArrayList.size (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
memcpy(ArrayList.data[ArrayList.size * size]&, element, size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
memcpy(ArrayList.data[ArrayList.size * size]&, element, size) (of type FunctionCall) wants to wholeAgain() because 'memcpy(ArrayList.data[ArrayList.size * size]&, element, size) looping because not resolved!'
Resolving variable decl index : Int
Resolving variable decl element : T
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
ArrayList.data + (size) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
ArrayList.data + (size) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = ArrayList.data (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * ArrayList.size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * ArrayList.size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? true, false, false, false)'
memmove(dst, src, size * ArrayList.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
memmove(dst, src, size * ArrayList.size) (of type FunctionCall) wants to wholeAgain() because 'memmove(dst, src, size * ArrayList.size) looping because not resolved!'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
0 * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
0 * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = 0 (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
memcpy(ArrayList.data[0 * size]&, element, size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
memcpy(ArrayList.data[0 * size]&, element, size) (of type FunctionCall) wants to wholeAgain() because 'memcpy(ArrayList.data[0 * size]&, element, size) looping because not resolved!'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * (index + 1) (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * (index + 1) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? true, false, false, false)'
ArrayList.data + (size * (index + 1)) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
ArrayList.data + (size * (index + 1)) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = ArrayList.data (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size * index (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
size * index (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? true, false, false, false)'
ArrayList.data + (size * index) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
ArrayList.data + (size * index) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = ArrayList.data (who is null? false, false, true, false)'
Resolving variable decl bsize : Int = (size - index) * size
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
(ArrayList.size - index) * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
(ArrayList.size - index) * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = (ArrayList.size - index) (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
index * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
index * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = index (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
memcpy(ArrayList.data[index * size]&, element, size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
memcpy(ArrayList.data[index * size]&, element, size) (of type FunctionCall) wants to wholeAgain() because 'memcpy(ArrayList.data[index * size]&, element, size) looping because not resolved!'
Resolving variable decl index : Int
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl returnVal6 : <unknown type> = data[index]
returnVal6 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal6 = ArrayList.data[index * size] (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg5 = returnVal6 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl element : T
Resolving variable decl index : <unknown type> = -1
Resolving variable decl candidate : T
candidate : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
candidate = data[index * size] (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
memcmp(candidate, element, size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
memcmp(candidate, element, size) (of type FunctionCall) wants to wholeAgain() because 'memcmp(candidate, element, size) looping because not resolved!'
memcmp(candidate, element, size) == 0 (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl element : T
Resolving variable decl index : <unknown type> = size
Resolving variable decl candidate : T
candidate : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
candidate = data[index * size] (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
memcmp(candidate, element, size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
memcmp(candidate, element, size) (of type FunctionCall) wants to wholeAgain() because 'memcmp(candidate, element, size) looping because not resolved!'
memcmp(candidate, element, size) == 0 (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl index : Int
Resolving variable decl element : <unknown type> = data[index]
element : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
element = ArrayList.data[index * size] (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
index * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
index * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = index (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
(index + 1) * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
(index + 1) * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = (index + 1) (who is null? false, false, true, false)'
     - access to T still not resolved, looping (ref = (nil))
T (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve T'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
(size - index) * size (of type BinaryOp) wants to wholeAgain() because 'score of operator *(str : String, count : Int) == -1 !!'
(size - index) * size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = (size - index) (who is null? false, false, true, false)'
memmove(data + (index * size), data + ((index + 1) * size), (size - index) * size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For removeAt: func (index : Int), response of body = LOOP
Response of fDecl removeAt: func (index : Int) = LOOP
response of tDecl ClassDecl ArrayListClass = LOOP
====== Resolving type decl ClassDecl ArrayListIterator
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl index : <unknown type> = 0
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = ArrayListIterator alloc() as ArrayListIterator
ArrayListIterator alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(list) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=list (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
list size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl element : <unknown type> = list get(index)
	$$$$ resolving returnType T for list get(index)
list get(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
element : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
element = ArrayListIterator.list get(ArrayListIterator.index) (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For next: func , response of body = LOOP
Response of fDecl next: func  = LOOP
-- ClassDecl ArrayListIteratorClass, meta of ClassDecl ArrayListIterator, isn't resolved, looping.
response of tDecl ClassDecl ArrayListIterator = LOOP
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
ArrayListIterator.list size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl element : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal10 : <unknown type> = element
returnVal10 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal10 = element (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg9 = returnVal10 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl element : <unknown type> = list get(index)
	$$$$ resolving returnType T for list get(index)
list get(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
element : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
element = ArrayListIterator.list get(ArrayListIterator.index) (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For prev: func , response of body = LOOP
Response of fDecl prev: func  = LOOP
response of tDecl ClassDecl ArrayListIteratorClass = LOOP
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
	$$$$ resolving returnType T for list get(i)
list get(i) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
list set(i, element) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
list set(i, element) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
list set(i, element) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
list add(element) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
list remove(element) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
list remove(element) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
list remove(element) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_SUB_ASS_ArrayList_T__Bool: func (list : ArrayList<T>, element : T) -> Bool (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl data : T*
Resolving variable decl size : SizeT
Resolving variable decl T : Class
ArrayList<T> new(data, size) (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<T*>'
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/List
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl List
Resolving variable decl T : Class
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = List alloc() as List
List alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
this addAll(0, list) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this addAll(0, list) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this addAll(0, list) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T
element : T (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
list iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type Iterator<T>'
iter13 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter13 next()
iter13 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
for (element in list) (of type Foreach) wants to wholeAgain() because 'Can't turn into a while =)'
Resolving variable decl index : <unknown type> = 0
Resolving variable decl iter : <unknown type> = list iterator()
list iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type Iterator<T>'
	$$$$ resolving returnType T for iter next()
iter next() (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
iter hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter next()
iter next() (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
iter next() (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
this add((comma expr)) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this add(genArg15&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl genArg15 : T = (comma expr)
genArg15 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
genArg15 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl size : <unknown type> = size()
this size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
size : <unknown type> = this size() (of type VariableDecl) wants to wholeAgain() because 'must determine type of size : <unknown type> = this size()
'
size - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = size (who is null? true, false, false, false)'
removeAt(size - 1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
removeAt(size - 1) (of type FunctionCall) wants to wholeAgain() because 'removeAt(size - 1) looping because not resolved!'
Resolving variable decl element : T
this indexOf(element) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this indexOf(element) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this indexOf(element) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
this indexOf(element) != -1 (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : <unknown type> = indexOf(oldie)
this indexOf(oldie) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this indexOf(oldie) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this indexOf(oldie) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
idx : <unknown type> = this indexOf(oldie) (of type VariableDecl) wants to wholeAgain() because 'must determine type of idx : <unknown type> = this indexOf(oldie)
'
idx == -1 (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
set(idx, kiddo) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
set(idx, kiddo) (of type FunctionCall) wants to wholeAgain() because 'set(idx, kiddo) looping because not resolved!'
Resolving variable decl index : Int
Resolving variable decl element : T
this size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this size() == 0 (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
	$$$$ resolving returnType T for this get(0)
this get(0) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
this get(0) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
return (comma expr) (of type Return) wants to wholeAgain() because 'expr type is unresolved'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For first: func , response of body = LOOP
Response of fDecl first: func  = LOOP
-- ClassDecl ListClass, meta of ClassDecl List, isn't resolved, looping.
response of tDecl ClassDecl List = LOOP
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T
element : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
list iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type Iterator<T>'
iter19 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter19 next()
iter19 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
for (element in list) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T
genCall14 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl genArg15 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(genArg15, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl size : <unknown type> = this size()
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
	$$$$ resolving returnType T for this removeAt(size - 1)
this removeAt(size - 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl element : T
this indexOf(element) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : <unknown type> = this indexOf(oldie)
this indexOf(oldie) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
	$$$$ resolving returnType T for this set(idx, kiddo)
this set(idx, kiddo) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl index : Int
Resolving variable decl element : T
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T
genCall16 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl returnVal18 : <unknown type> = (comma expr)
returnVal18 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal18 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg17 = returnVal18 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
this lastIndex() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
get(this lastIndex()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
get(this lastIndex()) (of type FunctionCall) wants to wholeAgain() because 'get(this lastIndex()) looping because not resolved!'
return get(this lastIndex()) (of type Return) wants to wholeAgain() because 'expr type is unresolved'
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl i : <unknown type> = 0
Resolving variable decl j : <unknown type> = size() - 1
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
	$$$$ resolving returnType T for this get(i)
this get(i) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
this get(i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for this set(j, (comma expr))
this set(j, (comma expr)) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
this set(j, genArg21&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
this set(j, genArg21&) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for this set(i, (comma expr))
this set(i, (comma expr)) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
this set(i, genArg23&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl genArg21 : T = (comma expr)
genArg21 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
genArg21 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl genCall22 : T
genCall22 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl genArg23 : T = (comma expr)
genArg23 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
genArg23 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl arr : T* = gc_malloc(size() * size)
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
gc_malloc(this size() * Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
this[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
this[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
arr[i] = (this, i) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl str : String
List.T inheritsFrom(String) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
"You cannot use `String join` with %s instances." format(Class.name) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new("You cannot use `String join` with %s instances." format(Class.name)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new("You cannot use `String join` with %s instances." format(Class.name)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl result : <unknown type> = Buffer new()
Buffer new() (of type FunctionCall) wants to wholeAgain() because 'because of return type Buffer'
Resolving variable decl first : <unknown type> = true
Resolving variable decl item : String
item : String (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
this iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type Iterator<T>'
iter24 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter24 next()
iter24 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
for (item in this) (of type Foreach) wants to wholeAgain() because 'Can't turn into a while =)'
result toString() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
join~string: func (str : String) -> String (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl chr : Char
String new(chr) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this join(String new(chr)) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
	$$$$ resolving returnType T for list get(i)
list get(i) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
	$$$$ resolving returnType T for list set(i, element)
list set(i, element) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
list add(element) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
list remove(element) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/Buffer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Buffer
Resolving variable decl size : SizeT
Resolving variable decl capacity : SizeT
Resolving variable decl data : String
====== Resolving type decl ClassDecl BufferClass
Resolving variable decl this : <unknown type> = Buffer alloc() as Buffer
Buffer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
init(128) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
init(128) (of type FunctionCall) wants to wholeAgain() because 'init(128) looping because not resolved!'
Resolving variable decl this : <unknown type> = Buffer alloc() as Buffer
Buffer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(capacity) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=capacity (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
gc_malloc(capacity) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl this : <unknown type> = Buffer alloc() as Buffer
Buffer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(data) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
data clone() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
data length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
data length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl str : String
Resolving variable decl length : <unknown type> = str length()
str length() (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
this append(str, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this append(str, length) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this append(str, length) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl str : String
Resolving variable decl length : SizeT
this checkLength(size + length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this checkLength(size + length) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkLength(size + length) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
memcpy(data as Char* + size, str, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl chr : Char
this checkLength(size + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this checkLength(size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkLength(size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl str : String
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
Exception new(This, "Buffer overflow! Offset is larger than buffer size.") (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Buffer overflow! Offset is larger than buffer size.") throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Exception new(This, "Buffer overflow! Offset + Length is larger than buffer size.") (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Buffer overflow! Offset + Length is larger than buffer size.") throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(str as Char*, data as Char* + offset, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl offset : Int
Exception new(This, "Buffer overflow! Offset is larger than buffer size.") (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Buffer overflow! Offset is larger than buffer size.") throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl min : SizeT
Resolving variable decl newCapa : <unknown type> = min * 1.200000 + 10
Resolving variable decl tmp : <unknown type> = gc_realloc(data, newCapa)
gc_realloc(data, newCapa) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Exception new(This, "Couldn't allocate enough memory for Buffer to grow to capacity " + newCapa) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Couldn't allocate enough memory for Buffer to grow to capacity " + newCapa) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl newCapa : <unknown type> = size + 1
Resolving variable decl tmp : <unknown type> = gc_realloc(data as Char*, newCapa)
gc_realloc(data as Char*, newCapa) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Exception new(This, "Not enough memory to reallocate string in buffer for toString() call") (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Not enough memory to reallocate string in buffer for toString() call") throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl BufferClass
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
this init(128) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl str : String
Resolving variable decl length : SizeT = str length()
Resolving variable decl str : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
Resolving variable decl offset : Int
Resolving variable decl min : SizeT
Resolving variable decl newCapa : SizeT = min * 1.200000 + 10
Resolving variable decl tmp : Pointer = gc_realloc(data, newCapa)
Resolving variable decl newCapa : SizeT = size + 1
Resolving variable decl tmp : Pointer = gc_realloc(data as Char*, newCapa)
====== Resolving type decl ClassDecl BufferWriter
Resolving variable decl buffer : Buffer
====== Resolving type decl ClassDecl BufferWriterClass
Resolving variable decl this : <unknown type> = BufferWriter alloc() as BufferWriter
BufferWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Buffer new() (of type FunctionCall) wants to wholeAgain() because 'because of return type Buffer'
Resolving variable decl this : <unknown type> = BufferWriter alloc() as BufferWriter
BufferWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(buffer) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=buffer (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
Resolving variable decl chr : Char
buffer append(chr) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl chars : String
Resolving variable decl length : SizeT
buffer append(chars, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl BufferWriterClass
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
====== Resolving type decl ClassDecl BufferReader
Resolving variable decl buffer : Buffer
====== Resolving type decl ClassDecl BufferReaderClass
Resolving variable decl this : <unknown type> = BufferReader alloc() as BufferReader
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'BufferReader alloc() looping because not resolved!'
this : BufferReader = BufferReader alloc() as BufferReader (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Buffer new() (of type FunctionCall) wants to wholeAgain() because 'because of return type Buffer'
Resolving variable decl this : <unknown type> = BufferReader alloc() as BufferReader
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'BufferReader alloc() looping because not resolved!'
this : BufferReader = BufferReader alloc() as BufferReader (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
this init(buffer) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=buffer (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
buffer get(chars, offset, count) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl c : <unknown type> = buffer get(marker)
buffer get(marker) (of type FunctionCall) wants to wholeAgain() because 'because of return type Char'
buffer get(marker) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
marker += 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = marker (who is null? false, true, false, false)'
Resolving variable decl offset : Int
marker -= offset (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = marker (who is null? false, true, false, false)'
marker = 0 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = marker (who is null? false, true, false, false)'
return marker (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl marker : Long
BufferReader.marker = marker (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = BufferReader.marker (who is null? false, true, false, false)'
====== Resolving type decl ClassDecl BufferReaderClass
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'BufferReader alloc() looping because not resolved!'
this : BufferReader = BufferReader alloc() as BufferReader (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'BufferReader alloc() looping because not resolved!'
this : BufferReader = BufferReader alloc() as BufferReader (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
__defaults__() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
__defaults__() (of type FunctionCall) wants to wholeAgain() because '__defaults__() looping because not resolved!'
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl c : Char = buffer get(marker)
BufferReader.buffer get(BufferReader.marker) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
BufferReader.marker += 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = BufferReader.marker (who is null? false, true, false, false)'
Resolving variable decl offset : Int
BufferReader.marker -= offset (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = BufferReader.marker (who is null? false, true, false, false)'
BufferReader.marker = 0 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = BufferReader.marker (who is null? false, true, false, false)'
return BufferReader.marker (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl marker : Long
BufferReader.marker = marker (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = BufferReader.marker (who is null? false, true, false, false)'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/Reader
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Reader
Resolving variable decl marker : Long
====== Resolving type decl ClassDecl ReaderClass
Resolving variable decl this : <unknown type> = Reader alloc() as Reader
Reader alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl offset : Int
Resolving variable decl marker : Long
Resolving variable decl offset : Int
this rewind(-offset) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
this read() (of type FunctionCall) wants to wholeAgain() because 'because of return type Char'
====== Resolving type decl ClassDecl ReaderClass
Resolving variable decl this : Reader = Reader alloc() as Reader
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl offset : Int
Resolving variable decl marker : Long
Resolving variable decl offset : Int
Resolving variable decl i : Int
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/FileReader
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl SEEK_CUR : Int
Resolving variable decl SEEK_SET : Int
Resolving variable decl SEEK_END : Int
====== Resolving type decl ClassDecl FileReader
Resolving variable decl file : FILE*
====== Resolving type decl ClassDecl FileReaderClass
Resolving variable decl fileObject : File
Resolving variable decl this : <unknown type> = FileReader alloc() as FileReader
FileReader alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(fileObject) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileObject : File
fileObject getPath() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this init(fileObject getPath()) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(fileObject getPath()) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this init(fileObject getPath()) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl fileName : String
Resolving variable decl this : <unknown type> = FileReader alloc() as FileReader
FileReader alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(fileName) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
fopen(fileName, "r") (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fopen(fileName, "r") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
file = fopen(fileName, "r") (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
"File not found: " + fileName (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) looping because not resolved!'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) throw() looping because not resolved!'
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
fread(chars as Char* + offset, 1, count, file) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fread(chars as Char* + offset, 1, count, file) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fread(chars as Char* + offset, 1, count, file) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
read: func (chars : String, offset : Int, count : Int) -> SizeT (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl value : Char
fread(value&, 1, 1, file) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fread(value&, 1, 1, file) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fread(value&, 1, 1, file) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl sb : <unknown type> = Buffer new(40)
Buffer new(40) (of type FunctionCall) wants to wholeAgain() because 'because of return type Buffer'
this hasNext() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl c : <unknown type> = read()
this read() (of type FunctionCall) wants to wholeAgain() because 'because of return type Char'
sb append(c) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
sb toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
feof(file) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
feof(file) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return !feof(file) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl offset : Int
fseek(file, -offset, SEEK_CUR) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fseek(file, -offset, SEEK_CUR) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fseek(file, -offset, SEEK_CUR) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
ftell(file) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
ftell(file) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
marker = ftell(file) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl marker : Long
fseek(file, marker, SEEK_SET) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fseek(file, marker, SEEK_SET) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fseek(file, marker, SEEK_SET) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
fclose(file) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
====== Resolving type decl ClassDecl FileReaderClass
Resolving variable decl fileObject : File
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileName : String
fopen(fileName, "r") (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fopen(fileName, "r") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
FileReader.file = fopen(fileName, "r") (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
__OP_ADD_String_String__String("File not found: ", fileName) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, __OP_ADD_String_String__String("File not found: ", fileName)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
fread(chars as Char* + offset, 1, count, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fread(chars as Char* + offset, 1, count, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fread(chars as Char* + offset, 1, count, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
read: func (chars : String, offset : Int, count : Int) -> SizeT (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl value : Char
fread(value&, 1, 1, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fread(value&, 1, 1, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fread(value&, 1, 1, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl sb : Buffer = Buffer new(40)
this hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl c : Char = this read()
feof(FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
feof(FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return !feof(FileReader.file) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl offset : Int
fseek(FileReader.file, -offset, SEEK_CUR) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fseek(FileReader.file, -offset, SEEK_CUR) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fseek(FileReader.file, -offset, SEEK_CUR) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
ftell(FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
ftell(FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
FileReader.marker = ftell(FileReader.file) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl marker : Long
fseek(FileReader.file, marker, SEEK_SET) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
fseek(FileReader.file, marker, SEEK_SET) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
fseek(FileReader.file, marker, SEEK_SET) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl filename : Char*
Resolving variable decl mode : Char*
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl count : SizeT
Resolving variable decl stream : FILE*
Resolving variable decl stream : FILE*
Resolving variable decl stream : FILE*
Resolving variable decl offset : Long
Resolving variable decl origin : Int
Resolving variable decl stream : FILE*
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/native/FileWin32
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl FILE_ATTRIBUTE_DIRECTORY : Long
Resolving variable decl FILE_ATTRIBUTE_REPARSE_POINT : Long
Resolving variable decl FILE_ATTRIBUTE_NORMAL : Long
====== Resolving type decl CoverDecl FindData
Resolving variable decl attr : Long
Resolving variable decl fileSizeLow : Long
Resolving variable decl fileSizeHigh : Long
Resolving variable decl creationTime : FileTime
Resolving variable decl lastAccessTime : FileTime
Resolving variable decl lastWriteTime : FileTime
Resolving variable decl fileName : String
====== Resolving type decl ClassDecl FindDataClass
     - type WIN32_FIND_DATA still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl FindDataClass
====== Resolving type decl ClassDecl FileWin32
====== Resolving type decl ClassDecl FileWin32Class
Resolving variable decl this : <unknown type> = FileWin32 alloc() as FileWin32
FileWin32 alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(path) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=path (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
GetFileAttributes(path) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
GetFileAttributes(path) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
GetFileAttributes(path) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
2147483647 != GetFileAttributes(path) (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : <unknown type> = findFirst(ffdPtr)
this findFirst(ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this findFirst(ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
hFind : <unknown type> = this findFirst(ffdPtr) (of type VariableDecl) wants to wholeAgain() because 'must determine type of hFind : <unknown type> = this findFirst(ffdPtr)
'
hFind == INVALID_HANDLE_VALUE (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
"[findSingle] Got invalid handle for file %s" format(path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new("[findSingle] Got invalid handle for file %s" format(path)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new("[findSingle] Got invalid handle for file %s" format(path)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
FindClose(hFind) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FindClose(hFind) (of type FunctionCall) wants to wholeAgain() because 'FindClose(hFind) looping because not resolved!'
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : <unknown type> = FindFirstFile(path, ffdPtr)
FindFirstFile(path, ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
FindFirstFile(path, ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindFirstFile(path, ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
hFind : <unknown type> = FindFirstFile(path, ffdPtr) (of type VariableDecl) wants to wholeAgain() because 'must determine type of hFind : <unknown type> = FindFirstFile(path, ffdPtr)
'
hFind == INVALID_HANDLE_VALUE (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
"[findFirst] Got invalid handle for file %s" format(path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new("[findFirst] Got invalid handle for file %s" format(path)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new("[findFirst] Got invalid handle for file %s" format(path)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
return hFind (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl ffd : FindData
this findSingle(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl ffd : FindData
this findSingle(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl ffd : FindData
this findSingle(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl ffd : FindData
this findSingle(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl mode : Int32
this isRelative() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this getAbsoluteFile() (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
this getAbsoluteFile() mkdir() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl parent : <unknown type> = parent()
this parent() (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
parent exists() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
parent mkdir() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
CreateDirectory(path, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CreateDirectory(path, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CreateDirectory(path, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl ffd : FindData
this findSingle(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
toTimestamp(FindData.lastAccessTime) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toTimestamp(FindData.lastAccessTime) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
toTimestamp(FindData.lastAccessTime) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return toTimestamp(FindData.lastAccessTime) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl ffd : FindData
this findSingle(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
toTimestamp(FindData.lastWriteTime) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toTimestamp(FindData.lastWriteTime) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
toTimestamp(FindData.lastWriteTime) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return toTimestamp(FindData.lastWriteTime) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl ffd : FindData
this findSingle(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
toTimestamp(FindData.creationTime) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toTimestamp(FindData.creationTime) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
toTimestamp(FindData.creationTime) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return toTimestamp(FindData.creationTime) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
path startsWith(".") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
path startsWith("\\\\") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this isRelative() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this getCwd() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this getCwd() + FileWin32Class.separator (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Char__String(this getCwd(), FileWin32Class.separator) + path (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Char__String(this getCwd(), FileWin32Class.separator) + path (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Char__String(this getCwd(), FileWin32Class.separator) (who is null? true, false, false, false)'
return __OP_ADD_String_Char__String(this getCwd(), FileWin32Class.separator) + path (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl result : <unknown type> = ArrayList<String> new()
ArrayList<String> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<String>'
Resolving variable decl ffd : FindData
Resolving variable decl hFile : <unknown type> = FindFirstFile(path + "\\*", ffd&)
path + "\\*" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&) looping because not resolved!'
hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&)
'
Resolving variable decl running : <unknown type> = (hFile != INVALID_HANDLE_VALUE)
hFile != INVALID_HANDLE_VALUE (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
FindData.fileName != "." (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
FindData.fileName != ".." (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_NE_String_String__Bool(FindData.fileName, ".") && __OP_NE_String_String__Bool(FindData.fileName, "..") (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_NE_String_String__Bool(FindData.fileName, ".") (who is null? true, false, true, false)'
path + CharLiteral (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Char__String(path, CharLiteral) (who is null? true, false, false, false)'
result add(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
result add(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName) (of type FunctionCall) wants to wholeAgain() because 'result add(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName) looping because not resolved!'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'FindNextFile(hFile, ffd&) looping because not resolved!'
running = FindNextFile(hFile, ffd&) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl result : <unknown type> = ArrayList<This> new()
ArrayList<This> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<FileWin32>'
Resolving variable decl ffd : FindData
Resolving variable decl hFile : <unknown type> = FindFirstFile(path + "\\*", ffd&)
path + "\\*" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&) looping because not resolved!'
hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&)
'
Resolving variable decl running : <unknown type> = (hFile != INVALID_HANDLE_VALUE)
hFile != INVALID_HANDLE_VALUE (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
FindData.fileName != "." (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
FindData.fileName != ".." (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_NE_String_String__Bool(FindData.fileName, ".") && __OP_NE_String_String__Bool(FindData.fileName, "..") (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_NE_String_String__Bool(FindData.fileName, ".") (who is null? true, false, true, false)'
path + CharLiteral (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Char__String(path, CharLiteral) (who is null? true, false, false, false)'
File new(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
File new(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName) (of type FunctionCall) wants to wholeAgain() because 'File new(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName) looping because not resolved!'
result add(File new(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
result add(File new(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName)) (of type FunctionCall) wants to wholeAgain() because 'result add(File new(__OP_ADD_String_Char__String(path, CharLiteral) + FindData.fileName)) looping because not resolved!'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'FindNextFile(hFile, ffd&) looping because not resolved!'
running = FindNextFile(hFile, ffd&) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
====== Resolving type decl ClassDecl FileWin32Class
Resolving variable decl this : FileWin32 = FileWin32 alloc() as FileWin32
GetFileAttributes(FileWin32.path) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
GetFileAttributes(FileWin32.path) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
GetFileAttributes(FileWin32.path) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
2147483647 != GetFileAttributes(FileWin32.path) (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : <unknown type> = this findFirst(ffdPtr)
this findFirst(ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'because of return type Handle'
FindClose(hFind) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
FindClose(hFind) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindClose(hFind) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : <unknown type> = FindFirstFile(path, ffdPtr)
FindFirstFile(FileWin32.path, ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
FindFirstFile(FileWin32.path, ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindFirstFile(FileWin32.path, ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
hFind : <unknown type> = FindFirstFile(FileWin32.path, ffdPtr) (of type VariableDecl) wants to wholeAgain() because 'must determine type of hFind : <unknown type> = FindFirstFile(FileWin32.path, ffdPtr)
'
hFind == INVALID_HANDLE_VALUE (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
return hFind (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl mode : Int32
this isRelative() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl parent : File = this parent()
CreateDirectory(FileWin32.path, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CreateDirectory(FileWin32.path, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CreateDirectory(FileWin32.path, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl ffd : FindData
toTimestamp(FindData.lastAccessTime) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toTimestamp(FindData.lastAccessTime) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
toTimestamp(FindData.lastAccessTime) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return toTimestamp(FindData.lastAccessTime) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl ffd : FindData
toTimestamp(FindData.lastWriteTime) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toTimestamp(FindData.lastWriteTime) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
toTimestamp(FindData.lastWriteTime) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return toTimestamp(FindData.lastWriteTime) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl ffd : FindData
toTimestamp(FindData.creationTime) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
toTimestamp(FindData.creationTime) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
toTimestamp(FindData.creationTime) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return toTimestamp(FindData.creationTime) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
__OP_ADD_String_Char__String(this getCwd(), FileWin32Class.separator) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Char__String(this getCwd(), FileWin32Class.separator) + FileWin32.path (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
return __OP_ADD_String_String__String(__OP_ADD_String_Char__String(this getCwd(), FileWin32Class.separator), FileWin32.path) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&)
__OP_ADD_String_String__String(FileWin32.path, "\\*") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
'
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
hFile != INVALID_HANDLE_VALUE (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
__OP_NE_String_String__Bool(FindData.fileName, ".") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
__OP_NE_String_String__Bool(FindData.fileName, "..") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
__OP_ADD_String_Char__String(FileWin32.path, CharLiteral) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Char__String(FileWin32.path, CharLiteral) + FindData.fileName (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
result add(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
result add(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)) (of type FunctionCall) wants to wholeAgain() because 'result add(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)) looping because not resolved!'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'FindNextFile(hFile, ffd&) looping because not resolved!'
running = FindNextFile(hFile, ffd&) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl result : ArrayList<FileWin32> = ArrayList<This> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(path, "\\*"), ffd&)
__OP_ADD_String_String__String(FileWin32.path, "\\*") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
'
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
hFile != INVALID_HANDLE_VALUE (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
__OP_NE_String_String__Bool(FindData.fileName, ".") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
__OP_NE_String_String__Bool(FindData.fileName, "..") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
__OP_ADD_String_Char__String(FileWin32.path, CharLiteral) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Char__String(FileWin32.path, CharLiteral) + FindData.fileName (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)) (of type FunctionCall) wants to wholeAgain() because 'File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)) looping because not resolved!'
result add(File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName))) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
result add(File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName))) (of type FunctionCall) wants to wholeAgain() because 'result add(File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName))) looping because not resolved!'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'FindNextFile(hFile, ffd&) looping because not resolved!'
running = FindNextFile(hFile, ffd&) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
FindClose(ffd&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl String
Resolving variable decl FindData*
Resolving variable decl Handle
Resolving variable decl FindData*
Resolving variable decl Handle
Resolving variable decl String
Resolving variable decl String
Resolving variable decl Pointer
Resolving variable decl path : String
printf("Win32: should remove file %s\n", path) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module native/win32/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl INVALID_HANDLE_VALUE : Handle
====== Resolving type decl CoverDecl Handle
====== Resolving type decl ClassDecl HandleClass
     - type HANDLE still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl HandleClass
====== Resolving type decl CoverDecl LargeInteger
Resolving variable decl lowPart : Long
Resolving variable decl highPart : Long
Resolving variable decl quadPart : LLong
====== Resolving type decl ClassDecl LargeIntegerClass
     - type LARGE_INTEGER still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl LargeIntegerClass
====== Resolving type decl CoverDecl ULargeInteger
Resolving variable decl lowPart : Long
Resolving variable decl highPart : Long
Resolving variable decl quadPart : LLong
====== Resolving type decl ClassDecl ULargeIntegerClass
     - type ULARGE_INTEGER still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl ULargeIntegerClass
====== Resolving type decl CoverDecl FileTime
Resolving variable decl lowDateTime : Long
Resolving variable decl highDateTime : Long
====== Resolving type decl ClassDecl FileTimeClass
     - type FILETIME still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl FileTimeClass
Resolving variable decl lowPart : Long
Resolving variable decl highPart : Long
Resolving variable decl li : LargeInteger
Resolving variable decl lowPart : Long
Resolving variable decl highPart : Long
Resolving variable decl li : ULargeInteger
Resolving variable decl fileTime : FileTime
Resolving variable decl date : LargeInteger
Resolving variable decl adjust : LargeInteger
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module native/win32/types finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/native/FileUnix
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl S_IRWXU : Long
Resolving variable decl S_IRWXG : Long
Resolving variable decl S_IRWXO : Long
====== Resolving type decl CoverDecl ModeT
====== Resolving type decl ClassDecl ModeTClass
     - type mode_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl ModeTClass
====== Resolving type decl CoverDecl FileStat
Resolving variable decl st_mode : ModeT
Resolving variable decl st_size : SizeT
Resolving variable decl st_atime : TimeT
Resolving variable decl st_mtime : TimeT
Resolving variable decl st_ctime : TimeT
====== Resolving type decl ClassDecl FileStatClass
     - type struct stat still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl FileStatClass
====== Resolving type decl ClassDecl FileUnix
====== Resolving type decl ClassDecl FileUnixClass
Resolving variable decl this : <unknown type> = FileUnix alloc() as FileUnix
FileUnix alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(path) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=path (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
S_ISDIR(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
return S_ISDIR(FileStat.st_mode) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
S_ISREG(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
return S_ISREG(FileStat.st_mode) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
S_ISLNK(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
return S_ISLNK(FileStat.st_mode) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
path startsWith(".") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
path startsWith("/") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl actualPath : <unknown type> = String new(MAX_PATH_LENGTH + 1)
String new(FileUnixClass.MAX_PATH_LENGTH + 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
realpath(path, actualPath) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
realpath(path, actualPath) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
realpath(path, actualPath) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return realpath(path, actualPath) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl actualPath : <unknown type> = getAbsolutePath()
this getAbsolutePath() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
path equals(actualPath) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
File new(actualPath) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
this isDir() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
"Trying to get the children of the non-directory '" + path (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!") looping because not resolved!'
Resolving variable decl dir : <unknown type> = opendir(path)
opendir(path) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
opendir(path) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
opendir(path) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
dir : <unknown type> = opendir(path) (of type VariableDecl) wants to wholeAgain() because 'must determine type of dir : <unknown type> = opendir(path)
'
"Couldn't open directory '" + path (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String("Couldn't open directory '", path) (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!") looping because not resolved!'
Resolving variable decl result : <unknown type> = ArrayList<String> new()
ArrayList<String> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<String>'
Resolving variable decl entry : <unknown type> = readdir(dir)
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'readdir(dir) looping because not resolved!'
entry : <unknown type> = readdir(dir) (of type VariableDecl) wants to wholeAgain() because 'must determine type of entry : <unknown type> = readdir(dir)
'
entry != NullLiteral (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name equals(".") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name equals(".") (of type FunctionCall) wants to wholeAgain() because 'name equals(".") looping because not resolved!'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name equals("..") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name equals("..") (of type FunctionCall) wants to wholeAgain() because 'name equals("..") looping because not resolved!'
!name equals(".") && !name equals("..") (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = !name equals(".") (who is null? true, false, true, false)'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name clone() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name clone() (of type FunctionCall) wants to wholeAgain() because 'name clone() looping because not resolved!'
result add(name clone()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
result add(name clone()) (of type FunctionCall) wants to wholeAgain() because 'result add(name clone()) looping because not resolved!'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'readdir(dir) looping because not resolved!'
entry = readdir(dir) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'closedir(dir) looping because not resolved!'
this isDir() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
"Trying to get the children of the non-directory '" + path (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("Trying to get the children of the non-directory '", path) + "'!") looping because not resolved!'
Resolving variable decl dir : <unknown type> = opendir(path)
opendir(path) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
opendir(path) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
opendir(path) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
dir : <unknown type> = opendir(path) (of type VariableDecl) wants to wholeAgain() because 'must determine type of dir : <unknown type> = opendir(path)
'
"Couldn't open directory '" + path (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String("Couldn't open directory '", path) (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("Couldn't open directory '", path) + "' for reading!") looping because not resolved!'
Resolving variable decl result : <unknown type> = ArrayList<This> new()
ArrayList<This> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<FileUnix>'
Resolving variable decl entry : <unknown type> = readdir(dir)
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'readdir(dir) looping because not resolved!'
entry : <unknown type> = readdir(dir) (of type VariableDecl) wants to wholeAgain() because 'must determine type of entry : <unknown type> = readdir(dir)
'
entry != NullLiteral (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name equals(".") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name equals(".") (of type FunctionCall) wants to wholeAgain() because 'name equals(".") looping because not resolved!'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name equals("..") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name equals("..") (of type FunctionCall) wants to wholeAgain() because 'name equals("..") looping because not resolved!'
!name equals(".") && !name equals("..") (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = !name equals(".") (who is null? true, false, true, false)'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name clone() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name clone() (of type FunctionCall) wants to wholeAgain() because 'name clone() looping because not resolved!'
File new(this, name clone()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
File new(this, name clone()) (of type FunctionCall) wants to wholeAgain() because 'File new(this, name clone()) looping because not resolved!'
result add(File new(this, name clone())) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
result add(File new(this, name clone())) (of type FunctionCall) wants to wholeAgain() because 'result add(File new(this, name clone())) looping because not resolved!'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'readdir(dir) looping because not resolved!'
entry = readdir(dir) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'closedir(dir) looping because not resolved!'
Resolving variable decl mode : Int32
_mkdir(path, mode) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
_mkdir(path, mode) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
_mkdir(path, mode) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
mkdir~withMode: func (mode : Int32) -> Int (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
====== Resolving type decl ClassDecl FileUnixClass
Resolving variable decl this : FileUnix = FileUnix alloc() as FileUnix
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
S_ISDIR(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
return S_ISDIR(FileStat.st_mode) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
S_ISREG(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
return S_ISREG(FileStat.st_mode) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
S_ISLNK(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
return S_ISLNK(FileStat.st_mode) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl actualPath : String = String new(FileUnixClass.MAX_PATH_LENGTH + 1)
realpath(FileUnix.path, actualPath) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
realpath(FileUnix.path, actualPath) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
realpath(FileUnix.path, actualPath) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return realpath(FileUnix.path, actualPath) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl actualPath : String = this getAbsolutePath()
__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path) + "'!" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!")) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!")) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!")) looping because not resolved!'
Resolving variable decl dir : <unknown type> = opendir(path)
opendir(FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
opendir(FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
opendir(FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
dir : <unknown type> = opendir(FileUnix.path) (of type VariableDecl) wants to wholeAgain() because 'must determine type of dir : <unknown type> = opendir(FileUnix.path)
'
__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path) + "' for reading!" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!")) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!")) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!")) looping because not resolved!'
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl entry : <unknown type> = readdir(dir)
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'readdir(dir) looping because not resolved!'
entry : <unknown type> = readdir(dir) (of type VariableDecl) wants to wholeAgain() because 'must determine type of entry : <unknown type> = readdir(dir)
'
entry != NullLiteral (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name equals(".") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name equals(".") (of type FunctionCall) wants to wholeAgain() because 'name equals(".") looping because not resolved!'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name equals("..") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name equals("..") (of type FunctionCall) wants to wholeAgain() because 'name equals("..") looping because not resolved!'
!name equals(".") && !name equals("..") (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = !name equals(".") (who is null? true, false, true, false)'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name clone() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name clone() (of type FunctionCall) wants to wholeAgain() because 'name clone() looping because not resolved!'
result add(name clone()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
result add(name clone()) (of type FunctionCall) wants to wholeAgain() because 'result add(name clone()) looping because not resolved!'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'readdir(dir) looping because not resolved!'
entry = readdir(dir) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'closedir(dir) looping because not resolved!'
__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path) + "'!" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!")) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!")) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!")) looping because not resolved!'
Resolving variable decl dir : <unknown type> = opendir(path)
opendir(FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
opendir(FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
opendir(FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
dir : <unknown type> = opendir(FileUnix.path) (of type VariableDecl) wants to wholeAgain() because 'must determine type of dir : <unknown type> = opendir(FileUnix.path)
'
__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path) + "' for reading!" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!")) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!")) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!")) looping because not resolved!'
Resolving variable decl result : ArrayList<FileUnix> = ArrayList<This> new()
Resolving variable decl entry : <unknown type> = readdir(dir)
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'readdir(dir) looping because not resolved!'
entry : <unknown type> = readdir(dir) (of type VariableDecl) wants to wholeAgain() because 'must determine type of entry : <unknown type> = readdir(dir)
'
entry != NullLiteral (of type Comparison) wants to wholeAgain() because 'score of operator !=(str1 : String, str2 : String) == -1 !!'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name equals(".") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name equals(".") (of type FunctionCall) wants to wholeAgain() because 'name equals(".") looping because not resolved!'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name equals("..") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name equals("..") (of type FunctionCall) wants to wholeAgain() because 'name equals("..") looping because not resolved!'
!name equals(".") && !name equals("..") (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = !name equals(".") (who is null? true, false, true, false)'
name (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
name clone() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name clone() (of type FunctionCall) wants to wholeAgain() because 'name clone() looping because not resolved!'
File new(this, name clone()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
File new(this, name clone()) (of type FunctionCall) wants to wholeAgain() because 'File new(this, name clone()) looping because not resolved!'
result add(File new(this, name clone())) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
result add(File new(this, name clone())) (of type FunctionCall) wants to wholeAgain() because 'result add(File new(this, name clone())) looping because not resolved!'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'readdir(dir) looping because not resolved!'
entry = readdir(dir) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'closedir(dir) looping because not resolved!'
Resolving variable decl mode : Int32
_mkdir(FileUnix.path, mode) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
_mkdir(FileUnix.path, mode) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
_mkdir(FileUnix.path, mode) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
mkdir~withMode: func (mode : Int32) -> Int (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl path : String
Resolving variable decl resolved : String
Resolving variable decl buf : String
Resolving variable decl size : SizeT
Resolving variable decl String
Resolving variable decl FileStat*
Resolving variable decl String
Resolving variable decl ModeT
Resolving variable decl path : String
Resolving variable decl path : String
remove(path) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module os/Time
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl CoverDecl SystemTime
Resolving variable decl wHour : UShort
Resolving variable decl wMinute : UShort
Resolving variable decl wSecond : UShort
Resolving variable decl wMilliseconds : UShort
====== Resolving type decl ClassDecl SystemTimeClass
     - type SYSTEMTIME still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl SystemTimeClass
====== Resolving type decl CoverDecl TimeT
====== Resolving type decl ClassDecl TimeTClass
     - type time_t still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl TimeTClass
====== Resolving type decl CoverDecl TimeZone
====== Resolving type decl ClassDecl TimeZoneClass
     - type struct timezone still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl TimeZoneClass
====== Resolving type decl CoverDecl TMStruct
Resolving variable decl tm_sec : Int
Resolving variable decl tm_min : Int
Resolving variable decl tm_hour : Int
Resolving variable decl tm_mday : Int
Resolving variable decl tm_mon : Int
Resolving variable decl tm_year : Int
Resolving variable decl tm_wday : Int
Resolving variable decl tm_yday : Int
Resolving variable decl tm_isdst : Int
====== Resolving type decl ClassDecl TMStructClass
     - type struct tm still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl TMStructClass
====== Resolving type decl CoverDecl TimeVal
Resolving variable decl tv_sec : TimeT
Resolving variable decl tv_usec : Int
====== Resolving type decl ClassDecl TimeValClass
     - type struct timeval still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl TimeValClass
====== Resolving type decl ClassDecl Time
====== Resolving type decl ClassDecl TimeClass
Resolving variable decl this : <unknown type> = Time alloc() as Time
Time alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this microsec() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this sec() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl st : SystemTime
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl tv : TimeVal
gettimeofday(tv&, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
gettimeofday(tv&, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl st : SystemTime
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
tt : <unknown type> = time(NullLiteral) (of type VariableDecl) wants to wholeAgain() because 'must determine type of tt : <unknown type> = time(NullLiteral)
'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'localtime(tt&) looping because not resolved!'
val : <unknown type> = localtime(tt&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of val : <unknown type> = localtime(tt&)
'
tm_sec (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
return tm_sec (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl st : SystemTime
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
tt : <unknown type> = time(NullLiteral) (of type VariableDecl) wants to wholeAgain() because 'must determine type of tt : <unknown type> = time(NullLiteral)
'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'localtime(tt&) looping because not resolved!'
val : <unknown type> = localtime(tt&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of val : <unknown type> = localtime(tt&)
'
tm_min (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
return tm_min (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl st : SystemTime
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
tt : <unknown type> = time(NullLiteral) (of type VariableDecl) wants to wholeAgain() because 'must determine type of tt : <unknown type> = time(NullLiteral)
'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'localtime(tt&) looping because not resolved!'
val : <unknown type> = localtime(tt&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of val : <unknown type> = localtime(tt&)
'
tm_hour (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
return tm_hour (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl duration : Float
this sleepMicro(duration * 1000000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this sleepMicro(duration * 1000000) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this sleepMicro(duration * 1000000) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl duration : UInt
this sleepMicro(duration * 1000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this sleepMicro(duration * 1000) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this sleepMicro(duration * 1000) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl duration : UInt
Sleep(duration / 1000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Sleep(duration / 1000) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
Sleep(duration / 1000) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
usleep(duration) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
usleep(duration) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
usleep(duration) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
====== Resolving type decl ClassDecl TimeClass
Resolving variable decl this : Time = Time alloc() as Time
this microsec() (of type FunctionCall) wants to wholeAgain() because 'because of return type UInt'
this sec() (of type FunctionCall) wants to wholeAgain() because 'because of return type UInt'
Resolving variable decl st : SystemTime
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl tv : TimeVal
gettimeofday(tv&, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
gettimeofday(tv&, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl st : SystemTime
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
tt : <unknown type> = time(NullLiteral) (of type VariableDecl) wants to wholeAgain() because 'must determine type of tt : <unknown type> = time(NullLiteral)
'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'localtime(tt&) looping because not resolved!'
val : <unknown type> = localtime(tt&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of val : <unknown type> = localtime(tt&)
'
tm_sec (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
return tm_sec (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl st : SystemTime
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
tt : <unknown type> = time(NullLiteral) (of type VariableDecl) wants to wholeAgain() because 'must determine type of tt : <unknown type> = time(NullLiteral)
'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'localtime(tt&) looping because not resolved!'
val : <unknown type> = localtime(tt&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of val : <unknown type> = localtime(tt&)
'
tm_min (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
return tm_min (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl st : SystemTime
GetLocalTime(st&) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
tt : <unknown type> = time(NullLiteral) (of type VariableDecl) wants to wholeAgain() because 'must determine type of tt : <unknown type> = time(NullLiteral)
'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'localtime(tt&) looping because not resolved!'
val : <unknown type> = localtime(tt&) (of type VariableDecl) wants to wholeAgain() because 'must determine type of val : <unknown type> = localtime(tt&)
'
tm_hour (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
return tm_hour (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl duration : Float
Resolving variable decl duration : UInt
Resolving variable decl duration : UInt
Sleep(duration / 1000) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
Sleep(duration / 1000) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
usleep(duration) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
usleep(duration) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl SystemTime*
Resolving variable decl UInt
Resolving variable decl TimeT*
Resolving variable decl TimeT*
Resolving variable decl TimeVal*
Resolving variable decl TimeZone*
Resolving variable decl UInt
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/native/dirent
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl CoverDecl DirPtr
====== Resolving type decl ClassDecl DirPtrClass
     - type DIR still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl DirPtrClass
====== Resolving type decl CoverDecl DirEnt
Resolving variable decl name : String
====== Resolving type decl ClassDecl DirEntClass
     - type struct dirent still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl DirEntClass
Resolving variable decl DirPtr
Resolving variable decl String
Resolving variable decl DirPtr
Resolving variable decl DirPtr
Resolving variable decl DirEnt*
Resolving variable decl DirEnt**
Resolving variable decl DirPtr
Resolving variable decl DirPtr
Resolving variable decl Long
Resolving variable decl DirPtr
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module io/native/dirent finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CInputTask
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CInputTask
Resolving variable decl keyCount : Int
Resolving variable decl dX : Int
Resolving variable decl dY : Int
Resolving variable decl event : Event
Resolving variable decl listeners : LinkedList<Listener>
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : This = NullLiteral
this new() (of type FunctionCall) wants to wholeAgain() because 'because of return type CInputTask'
Resolving variable decl this : <unknown type> = CInputTask alloc() as CInputTask
CInputTask alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
LinkedList<Listener> new() (of type FunctionCall) wants to wholeAgain() because 'because couldn't properly realTypize return type.'
LinkedList<Listener> new() (of type FunctionCall) wants to wholeAgain() because 'LinkedList<Listener> new() looping because of return type!'
listeners = LinkedList<Listener> new() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
SDLEvent poll(event&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl listener : <unknown type>
listener : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
CInputTask.listeners iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (listener in CInputTask.listeners) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl event : Event
Resolving variable decl listener : Listener
listeners add(listener) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
listeners add(listener) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
listeners add(listener) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl listener : Listener
listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
LinkedList<Listener> new() (of type FunctionCall) wants to wholeAgain() because 'because couldn't properly realTypize return type.'
LinkedList<Listener> new() (of type FunctionCall) wants to wholeAgain() because 'LinkedList<Listener> new() looping because of return type!'
CInputTask.listeners = LinkedList<Listener> new() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl listener : <unknown type>
CInputTask.listeners iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (listener in CInputTask.listeners) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl event : Event
Resolving variable decl listener : Listener
CInputTask.listeners add(listener) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CInputTask.listeners add(listener) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl listener : Listener
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/LinkedList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LinkedList
Resolving variable decl T : Class
Resolving variable decl size : Int = 0
Resolving variable decl first : Node<T>
Resolving variable decl last : Node<T>
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = LinkedList alloc() as LinkedList
LinkedList alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Node<T> new(last, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Node<T> new(last, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'Node<T> new(last, NullLiteral, data) looping because not resolved!'
node = Node<T> new(last, NullLiteral, data) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Node<T>.next = node (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Node<T>.next (who is null? false, true, false, false)'
Node<T> new(NullLiteral, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Node<T> new(NullLiteral, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'Node<T> new(NullLiteral, NullLiteral, data) looping because not resolved!'
node = Node<T> new(NullLiteral, NullLiteral, data) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl index : Int
Resolving variable decl data : T
this lastIndex() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl prevNode : <unknown type> = getNode(index - 1)
this getNode(index - 1) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this getNode(index - 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this getNode(index - 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
prevNode : <unknown type> = this getNode(index - 1) (of type VariableDecl) wants to wholeAgain() because 'must determine type of prevNode : <unknown type> = this getNode(index - 1)
'
Resolving variable decl nextNode : <unknown type> = next
next (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
nextNode : <unknown type> = next (of type VariableDecl) wants to wholeAgain() because 'must determine type of nextNode : <unknown type> = next
'
Resolving variable decl node : <unknown type> = Node<T> new(prevNode, nextNode, data)
Node<T> new(prevNode, nextNode, data) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Node<T> new(prevNode, nextNode, data) (of type FunctionCall) wants to wholeAgain() because 'Node<T> new(prevNode, nextNode, data) looping because not resolved!'
node : <unknown type> = Node<T> new(prevNode, nextNode, data) (of type VariableDecl) wants to wholeAgain() because 'must determine type of node : <unknown type> = Node<T> new(prevNode, nextNode, data)
'
next (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
next = node (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
prev (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
prev = node (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
this size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
index == this size() (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
this add(data) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl node : <unknown type> = Node<T> new(NullLiteral, first, data)
Node<T> new(NullLiteral, first, data) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Node<T> new(NullLiteral, first, data) (of type FunctionCall) wants to wholeAgain() because 'Node<T> new(NullLiteral, first, data) looping because not resolved!'
node : <unknown type> = Node<T> new(NullLiteral, first, data) (of type VariableDecl) wants to wholeAgain() because 'must determine type of node : <unknown type> = Node<T> new(NullLiteral, first, data)
'
Node<T>.prev = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
first = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
first = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
last = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
"Check index: 0 <= " + index (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Check index: 0 <= ", index) (who is null? true, false, false, false)'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() looping because not resolved!'
Resolving variable decl current : <unknown type> = first
Resolving variable decl next : <unknown type> = next
Node<T>.prev = NullLiteral (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Node<T>.prev (who is null? false, true, false, false)'
Resolving variable decl index : Int
this getNode(index) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this getNode(index) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this getNode(index) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
data (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
return data (of type Return) wants to wholeAgain() because 'expr type is unresolved'
Resolving variable decl index : Int
"Check index: 0 <= " + index (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Check index: 0 <= ", index) (who is null? true, false, false, false)'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() looping because not resolved!'
Resolving variable decl i : Int = 0
Resolving variable decl current : <unknown type> = first
Resolving variable decl data : T
Resolving variable decl current : <unknown type> = first
Resolving variable decl i : <unknown type> = 0
Resolving variable decl data : T
Resolving variable decl current : <unknown type> = last
Resolving variable decl i : <unknown type> = size - 1
current = Node<T>.prev (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = current (who is null? false, false, false, true)'
Resolving variable decl index : Int
Resolving variable decl toRemove : <unknown type> = getNode(index)
this getNode(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type Node<T>'
Node<T>.prev = Node<T>.prev (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Node<T>.prev (who is null? false, true, false, true)'
last = Node<T>.prev (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = last (who is null? false, false, false, true)'
     - access to Node<T>.prev->next still not resolved, looping (ref = (nil))
Response of statement [BinaryOp] Node<T>.next = NullLiteral = LOOP
Response of statement [If] if (Node<T>.prev) = LOOP
Response of statement [Else] else = LOOP
Response of statement [If] if (first != NullLiteral && index >= 0 && index < size) = LOOP
))))))) For removeAt: func (index : Int), response of body = LOOP
Response of fDecl removeAt: func (index : Int) = LOOP
-- ClassDecl LinkedListClass, meta of ClassDecl LinkedList, isn't resolved, looping.
response of tDecl ClassDecl LinkedList = LOOP
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Node<T> new(LinkedList.last, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Node<T> new(LinkedList.last, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'Node<T> new(LinkedList.last, NullLiteral, data) looping because not resolved!'
node = Node<T> new(LinkedList.last, NullLiteral, data) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Node<T> new(NullLiteral, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Node<T> new(NullLiteral, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'Node<T> new(NullLiteral, NullLiteral, data) looping because not resolved!'
node = Node<T> new(NullLiteral, NullLiteral, data) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : <unknown type> = this getNode(index - 1)
this getNode(index - 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Node<T>'
Resolving variable decl nextNode : <unknown type> = Node<T>.next
Resolving variable decl node : <unknown type> = Node<T> new(prevNode, nextNode, data)
Node<T> new(prevNode, nextNode, data) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Node<T> new(prevNode, nextNode, data) (of type FunctionCall) wants to wholeAgain() because 'Node<T> new(prevNode, nextNode, data) looping because not resolved!'
node : <unknown type> = Node<T> new(prevNode, nextNode, data) (of type VariableDecl) wants to wholeAgain() because 'must determine type of node : <unknown type> = Node<T> new(prevNode, nextNode, data)
'
Node<T>.next = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Node<T>.prev = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
this size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
index == this size() (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl node : <unknown type> = Node<T> new(NullLiteral, first, data)
Node<T> new(NullLiteral, LinkedList.first, data) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Node<T> new(NullLiteral, LinkedList.first, data) (of type FunctionCall) wants to wholeAgain() because 'Node<T> new(NullLiteral, LinkedList.first, data) looping because not resolved!'
node : <unknown type> = Node<T> new(NullLiteral, LinkedList.first, data) (of type VariableDecl) wants to wholeAgain() because 'must determine type of node : <unknown type> = Node<T> new(NullLiteral, LinkedList.first, data)
'
Node<T>.prev = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
LinkedList.first = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
LinkedList.first = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
LinkedList.last = node (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) looping because not resolved!'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() looping because not resolved!'
Resolving variable decl current : Node<T> = first
Resolving variable decl next : Node<T> = Node<T>.next
Node<T>.prev = NullLiteral (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Node<T>.prev (who is null? false, true, false, false)'
Resolving variable decl index : Int
this getNode(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type Node<T>'
return Node<T>.data (of type Return) wants to wholeAgain() because 'expr type is unresolved'
Resolving variable decl index : Int
__OP_ADD_String_Int__String("Check index: 0 <= ", index) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) looping because not resolved!'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() looping because not resolved!'
Resolving variable decl i : Int = 0
Resolving variable decl current : Node<T> = first
Resolving variable decl data : T
Resolving variable decl current : Node<T> = first
Resolving variable decl i : Int = 0
Resolving variable decl data : T
Resolving variable decl current : Node<T> = last
Resolving variable decl i : Int = size - 1
current = Node<T>.prev (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = current (who is null? false, false, false, true)'
Resolving variable decl index : Int
Resolving variable decl toRemove : Node<T> = this getNode(index)
Node<T>.prev = Node<T>.prev (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Node<T>.prev (who is null? false, true, false, true)'
LinkedList.last = Node<T>.prev (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = LinkedList.last (who is null? false, false, false, true)'
     - access to Node<T>.prev->next still not resolved, looping (ref = (nil))
Response of statement [BinaryOp] Node<T>.next = NullLiteral = LOOP
Response of statement [If] if (Node<T>.prev) = LOOP
Response of statement [Else] else = LOOP
Response of statement [If] if (LinkedList.first != NullLiteral && index >= 0 && index < LinkedList.size) = LOOP
))))))) For removeAt: func (index : Int), response of body = LOOP
Response of fDecl removeAt: func (index : Int) = LOOP
response of tDecl ClassDecl LinkedListClass = LOOP
====== Resolving type decl ClassDecl Node
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl prev : Node<T>
Resolving variable decl next : Node<T>
Resolving variable decl data : T
data : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = Node alloc() as Node
Node alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = Node alloc() as Node
Node alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(prev, next, data) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=prev (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=next (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=data (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
Node.data = data (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
memcpy(Node.data, data, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl LinkedListIterator
Resolving variable decl T : Class
Resolving variable decl current : Node<T>
Resolving variable decl list : LinkedList<T>
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = LinkedListIterator alloc() as LinkedListIterator
LinkedListIterator alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(list) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=list (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
Resolving variable decl prev : <unknown type> = current
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For next: func , response of body = LOOP
Response of fDecl next: func  = LOOP
-- ClassDecl LinkedListIteratorClass, meta of ClassDecl LinkedListIterator, isn't resolved, looping.
response of tDecl ClassDecl LinkedListIterator = LOOP
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = current
Resolving variable decl returnVal26 : <unknown type> = Node<T>.data
returnVal26 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal26 = Node<T>.data (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg25 = returnVal26 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For prev: func , response of body = LOOP
Response of fDecl prev: func  = LOOP
response of tDecl ClassDecl LinkedListIteratorClass = LOOP
Resolving variable decl list : LinkedList<T>
Resolving variable decl index : Int
Resolving variable decl T : Class
	$$$$ resolving returnType T for list get(index)
list get(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
list get(index) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
return (comma expr) (of type Return) wants to wholeAgain() because 'expr type is unresolved'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For __OP_IDX_LinkedList_Int__T: func (list : LinkedList<T>, index : Int), response of body = LOOP
response of oDecl operator [](list : LinkedList<T>, index : Int) = LOOP
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module os/Terminal
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Attr
====== Resolving type decl ClassDecl AttrClass
Resolving variable decl reset : Int = 0
Resolving variable decl bright : Int = 1
Resolving variable decl dim : Int = 2
Resolving variable decl under : Int = 3
Resolving variable decl blink : Int = 5
Resolving variable decl reverse : Int = 7
Resolving variable decl hidden : Int = 8
Resolving variable decl this : <unknown type> = Attr alloc() as Attr
Attr alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl AttrClass
Resolving variable decl reset : Int = 0
Resolving variable decl bright : Int = 1
Resolving variable decl dim : Int = 2
Resolving variable decl under : Int = 3
Resolving variable decl blink : Int = 5
Resolving variable decl reverse : Int = 7
Resolving variable decl hidden : Int = 8
Resolving variable decl this : Attr = Attr alloc() as Attr
====== Resolving type decl ClassDecl Color
====== Resolving type decl ClassDecl ColorClass
Resolving variable decl black : Int = 30
Resolving variable decl red : Int = 31
Resolving variable decl green : Int = 32
Resolving variable decl yellow : Int = 33
Resolving variable decl blue : Int = 34
Resolving variable decl magenta : Int = 35
Resolving variable decl cyan : Int = 36
Resolving variable decl grey : Int = 37
Resolving variable decl white : Int = 38
Resolving variable decl this : <unknown type> = Color alloc() as Color
Color alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl ColorClass
Resolving variable decl black : Int = 30
Resolving variable decl red : Int = 31
Resolving variable decl green : Int = 32
Resolving variable decl yellow : Int = 33
Resolving variable decl blue : Int = 34
Resolving variable decl magenta : Int = 35
Resolving variable decl cyan : Int = 36
Resolving variable decl grey : Int = 37
Resolving variable decl white : Int = 38
Resolving variable decl this : Color = Color alloc() as Color
====== Resolving type decl ClassDecl Terminal
====== Resolving type decl ClassDecl TerminalClass
Resolving variable decl this : <unknown type> = Terminal alloc() as Terminal
Terminal alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl f : Int
Resolving variable decl b : Int
this setFgColor(f) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this setFgColor(f) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this setFgColor(f) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
this setBgColor(b) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this setBgColor(b) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this setBgColor(b) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl c : Int
printf("\033[%dm", c) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl c : Int
printf("\033[%dm", c + 10) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl att : Int
printf("\033[%dm", att) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
this setAttr(AttrClass.reset) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl TerminalClass
Resolving variable decl this : Terminal = Terminal alloc() as Terminal
Resolving variable decl f : Int
Resolving variable decl b : Int
Resolving variable decl c : Int
Resolving variable decl c : Int
Resolving variable decl att : Int
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CGlobalTimer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CGlobalTimer
Resolving variable decl dT : Float
Resolving variable decl lastFrameIndex : ULong
Resolving variable decl thisFrameIndex : ULong
====== Resolving type decl ClassDecl CGlobalTimerClass
Resolving variable decl instance : This = NullLiteral
this new() (of type FunctionCall) wants to wholeAgain() because 'because of return type CGlobalTimer'
Resolving variable decl this : <unknown type> = CGlobalTimer alloc() as CGlobalTimer
CGlobalTimer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL getTicks() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
SDL getTicks() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl event : Event
====== Resolving type decl ClassDecl CGlobalTimerClass
Resolving variable decl instance : CGlobalTimer = NullLiteral
Resolving variable decl this : CGlobalTimer = CGlobalTimer alloc() as CGlobalTimer
Resolving variable decl event : Event
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CKernel
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CKernel
Resolving variable decl taskList : LinkedList<ITask>
Resolving variable decl pausedTaskList : LinkedList<ITask>
====== Resolving type decl ClassDecl CKernelClass
Resolving variable decl instance : This = NullLiteral
this new() (of type FunctionCall) wants to wholeAgain() because 'because of return type CKernel'
printf("Kernel initialized\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl this : <unknown type> = CKernel alloc() as CKernel
CKernel alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
LinkedList<ITask> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedList<ITask>'
LinkedList<ITask> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedList<ITask>'
SDL init(0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl t : ITask
t start() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl pos : <unknown type> = 0
Resolving variable decl task : <unknown type>
task : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
taskList add(pos, t) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("taskList add(%d,%p)\n", pos, t) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
taskList size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
printf("[Execute] size = %d\n", taskList size()) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
taskList size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl task : <unknown type>
task : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl task : <unknown type>
task : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
usleep(30000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl t : ITask
taskList indexOf(t) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
t onSuspend() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
pausedTaskList add(t) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl t : ITask
pausedTaskList indexOf(t) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
t onResume() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl pos : <unknown type> = 0
Resolving variable decl task : <unknown type>
task : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
taskList add(pos, t) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl t : ITask
Resolving variable decl task : <unknown type>
task : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
SDL quit() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl CKernelClass
Resolving variable decl instance : CKernel = NullLiteral
Resolving variable decl this : CKernel = CKernel alloc() as CKernel
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
CKernel.taskList size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.taskList size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl t : ITask
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl t : ITask
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl pos : Int = 0
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl t : ITask
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module LevelEditor
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LevelEditor
Resolving variable decl NONE : <unknown type> = 0
Resolving variable decl GRAB : <unknown type> = 1
Resolving variable decl SCALE : <unknown type> = 2
Resolving variable decl ROTATE : <unknown type> = 3
Resolving variable decl ADDMODEL : <unknown type> = 4
Resolving variable decl currentModelName : Node<String>
Resolving variable decl currentModelType : CProduct
Resolving variable decl grabLock : <unknown type> = Int3 new(0, 0, 0)
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
grabLock : <unknown type> = Int3 new(0, 0, 0) (of type VariableDecl) wants to wholeAgain() because 'must determine type of grabLock : <unknown type> = Int3 new(0, 0, 0)
'
Resolving variable decl rotLock : <unknown type> = Int3 new(0, 0, 0)
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
rotLock : <unknown type> = Int3 new(0, 0, 0) (of type VariableDecl) wants to wholeAgain() because 'must determine type of rotLock : <unknown type> = Int3 new(0, 0, 0)
'
Resolving variable decl sclLock : <unknown type> = Int3 new(0, 0, 0)
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
sclLock : <unknown type> = Int3 new(0, 0, 0) (of type VariableDecl) wants to wholeAgain() because 'must determine type of sclLock : <unknown type> = Int3 new(0, 0, 0)
'
Resolving variable decl camera : FFCamera
Resolving variable decl wire : <unknown type> = false
Resolving variable decl world : <unknown type> = World new()
World new() (of type FunctionCall) wants to wholeAgain() because 'because of return type World'
Resolving variable decl mode : <unknown type> = false
Resolving variable decl editMode : <unknown type> = NONE
Resolving variable decl backupPos : <unknown type> = Double3 new(0, 0, 0)
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'Double3 new(0, 0, 0) looping because not resolved!'
backupPos : <unknown type> = Double3 new(0, 0, 0) (of type VariableDecl) wants to wholeAgain() because 'must determine type of backupPos : <unknown type> = Double3 new(0, 0, 0)
'
====== Resolving type decl ClassDecl LevelEditorClass
Resolving variable decl this : <unknown type> = LevelEditor alloc() as LevelEditor
LevelEditor alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl name : String
printf("Caching %s...\n", name) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CFactory get() loadStatic(MESH, name) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CFactory get() loadStatic(MESH, name) (of type FunctionCall) wants to wholeAgain() because 'CFactory get() loadStatic(MESH, name) looping because not resolved!'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CInputTask'
CInputTask get() regEvent(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/midres-notex-monkey.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/mountains.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/notex-cube.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/basic/mod1.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/basic/mod2.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/basic/mod3.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/head.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/terrain1.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this preLoad("models/gun.s3d") (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Double3 new(5, 5, 5) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Double3 new(5, 5, 5) (of type FunctionCall) wants to wholeAgain() because 'Double3 new(5, 5, 5) looping because not resolved!'
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'FFCamera new(Double3 new(5, 5, 5)) looping because not resolved!'
camera = FFCamera new(Double3 new(5, 5, 5)) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
camera = FFCamera new(Double3 new(5, 5, 5)) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
glViewport(0, 0, 1280, 800) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glMatrixMode(GL_PROJECTION) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLoadIdentity() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
gluPerspective(60, 1280 as Float / 800 as Float, 0.010000, 1000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
gluPerspective(60, 1280 as Float / 800 as Float, 0.010000, 1000) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
gluPerspective(60, 1280 as Float / 800 as Float, 0.010000, 1000) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glMatrixMode(GL_MODELVIEW) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLoadIdentity() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glClearColor(0.000000, 0.000000, 0.000000, 1.000000) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glShadeModel(GL_SMOOTH) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPolygonMode(GL_FRONT_AND_BACK, GL_FILL) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRenderMode(GL_RENDER) (of type FunctionCall) wants to wholeAgain() because 'because of return type GLint'
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glEnable(GL_COLOR_MATERIAL) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glEnable(GL_LIGHTING) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glEnable(GL_LIGHT0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
Resolving variable decl ambientLight : GLfloat[] = [0.200000, 0.200000, 0.200000, 1.000000]
 >> Resolving [0.200000, 0.200000, 0.200000, 1.000000]
Decided for type ArrayList<Float>
[0.200000, 0.200000, 0.200000, 1.000000] (of type ArrayLiteral) wants to wholeAgain() because 'just replaced'
Should add initializer to ambientLight : ArrayList<GLfloat> = ArrayList<Float> new()
ambientLight : ArrayList<GLfloat> = ArrayList<GLfloat> new() (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'ambientLight add(0.200000) looping because not resolved!'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'ambientLight add(0.200000) looping because not resolved!'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'ambientLight add(0.200000) looping because not resolved!'
ambientLight add(1.000000) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
ambientLight add(1.000000) (of type FunctionCall) wants to wholeAgain() because 'ambientLight add(1.000000) looping because not resolved!'
Resolving variable decl diffuseLight : GLfloat[] = [0.800000, 0.800000, 0.800000, 1.000000]
 >> Resolving [0.800000, 0.800000, 0.800000, 1.000000]
Should add initializer to diffuseLight : ArrayList<GLfloat> = [0.800000, 0.800000, 0.800000, 1.000000]
diffuseLight : ArrayList<GLfloat> = ArrayList<GLfloat> new() (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
Resolving variable decl specularLight : GLfloat[] = [0.500000, 0.500000, 0.500000, 1.000000]
 >> Resolving [0.500000, 0.500000, 0.500000, 1.000000]
Should add initializer to specularLight : ArrayList<GLfloat> = [0.500000, 0.500000, 0.500000, 1.000000]
specularLight : ArrayList<GLfloat> = ArrayList<GLfloat> new() (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
Resolving variable decl position : GLfloat[] = [-1.500000, 1.000000, -1.000000, 1.000000]
 >> Resolving [-1.500000, 1.000000, -1.000000, 1.000000]
Should add initializer to position : ArrayList<GLfloat> = [-1.500000, 1.000000, -1.000000, 1.000000]
position : ArrayList<GLfloat> = ArrayList<GLfloat> new() (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glLightfv(GL_LIGHT0, GL_SPECULAR, specularLight) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLightfv(GL_LIGHT0, GL_SPECULAR, specularLight) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glLightfv(GL_LIGHT0, GL_POSITION, position) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLightfv(GL_LIGHT0, GL_POSITION, position) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
SDL showCursor(SDL_ENABLE) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
glClearColor(0, 0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glMatrixMode(GL_MODELVIEW) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLoadIdentity() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
camera update() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
camera look() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
glEnable(GL_DEPTH_TEST) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glDisable(GL_BLEND) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPolygonMode(GL_FRONT_AND_BACK, GL_FILL) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
world render(GL_RENDER) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
world render(GL_RENDER) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
world render(GL_RENDER) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glPushMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
currentModelType render() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
glPopMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
this drawMainAxes() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this drawGridLock() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CInputTask'
CInputTask get() unRegEvent(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl event : Event
Resolving variable decl event : Event
Resolving variable decl mouse : <unknown type> = getMouseVector(x, y)
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y) (of type VariableDecl) wants to wholeAgain() because 'must determine type of mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y)
'
moveObject(mouse) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
moveObject(mouse) (of type FunctionCall) wants to wholeAgain() because 'moveObject(mouse) looping because not resolved!'
Resolving variable decl mouse : Double3
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
x && y (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = x (who is null? true, false, true, false)'
Resolving variable decl t : Double = (z - z) / (z - z)
     - access to World.picked->position still not resolved, looping (ref = (nil))
Response of statement [VariableDecl] t : Double = (z - z) / (z - z) = LOOP
Response of statement [If] if (x && y) = LOOP
))))))) For moveObject: func (mouse : Double3), response of body = LOOP
Response of fDecl moveObject: func (mouse : Double3) = LOOP
-- ClassDecl LevelEditorClass, meta of ClassDecl LevelEditor, isn't resolved, looping.
response of tDecl ClassDecl LevelEditor = LOOP
====== Resolving type decl ClassDecl LevelEditorClass
Resolving variable decl this : LevelEditor = LevelEditor alloc() as LevelEditor
Resolving variable decl name : String
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CFactory get() loadStatic(MESH, name) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CFactory get() loadStatic(MESH, name) (of type FunctionCall) wants to wholeAgain() because 'CFactory get() loadStatic(MESH, name) looping because not resolved!'
Double3 new(5, 5, 5) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Double3 new(5, 5, 5) (of type FunctionCall) wants to wholeAgain() because 'Double3 new(5, 5, 5) looping because not resolved!'
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'FFCamera new(Double3 new(5, 5, 5)) looping because not resolved!'
LevelEditor.camera = FFCamera new(Double3 new(5, 5, 5)) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
LevelEditor.camera = FFCamera new(Double3 new(5, 5, 5)) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
gluPerspective(60, 1280 as Float / 800 as Float, 0.010000, 1000) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
gluPerspective(60, 1280 as Float / 800 as Float, 0.010000, 1000) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl ambientLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
ArrayList<GLfloat> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<GLfloat>'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
ambientLight add(0.200000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
ambientLight add(1.000000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl diffuseLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
ArrayList<GLfloat> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<GLfloat>'
Resolving variable decl specularLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
ArrayList<GLfloat> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<GLfloat>'
Resolving variable decl position : ArrayList<GLfloat> = ArrayList<GLfloat> new()
ArrayList<GLfloat> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<GLfloat>'
LevelEditor.world render(GL_RENDER) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
LevelEditor.world render(GL_RENDER) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl event : Event
Resolving variable decl event : Event
Resolving variable decl mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y)
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y) (of type VariableDecl) wants to wholeAgain() because 'must determine type of mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y)
'
moveObject(mouse) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
moveObject(mouse) (of type FunctionCall) wants to wholeAgain() because 'moveObject(mouse) looping because not resolved!'
Resolving variable decl mouse : Double3
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
x && y (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = x (who is null? true, false, true, false)'
Resolving variable decl t : Double = (z - z) / (z - z)
     - access to World.picked->position still not resolved, looping (ref = (nil))
Response of statement [VariableDecl] t : Double = (z - z) / (z - z) = LOOP
Response of statement [If] if (x && y) = LOOP
))))))) For moveObject: func (mouse : Double3), response of body = LOOP
Response of fDecl moveObject: func (mouse : Double3) = LOOP
response of tDecl ClassDecl LevelEditorClass = LOOP
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module glu/Glu
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl CoverDecl Quadric
====== Resolving type decl ClassDecl QuadricClass
     - type GLUquadric still not resolved, looping (ref = (nil))
====== Resolving type decl ClassDecl QuadricClass
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Quadric
Resolving variable decl Double
Resolving variable decl Int
Resolving variable decl Int
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
Resolving variable decl Double
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module glu/Glu finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CFactory
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CFactory
Resolving variable decl meshes : <unknown type> = HashMap<StaticMesh> new()
HashMap<StaticMesh> new() (of type FunctionCall) wants to wholeAgain() because 'because couldn't properly realTypize return type.'
HashMap<StaticMesh> new() (of type FunctionCall) wants to wholeAgain() because 'HashMap<StaticMesh> new() looping because of return type!'
meshes : <unknown type> = HashMap<StaticMesh> new() (of type VariableDecl) wants to wholeAgain() because 'must determine type of meshes : <unknown type> = HashMap<StaticMesh> new()
'
Resolving variable decl names : <unknown type> = LinkedList<String> new()
LinkedList<String> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedList<String>'
Resolving variable decl id : <unknown type> = 0
====== Resolving type decl ClassDecl CFactoryClass
Resolving variable decl instance : This = NullLiteral
this new() (of type FunctionCall) wants to wholeAgain() because 'because of return type CFactory'
Resolving variable decl this : <unknown type> = CFactory alloc() as CFactory
CFactory alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl productType : Int
Resolving variable decl filename : String
meshes clear() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
meshes clear() (of type FunctionCall) wants to wholeAgain() because 'meshes clear() looping because not resolved!'
====== Resolving type decl ClassDecl CFactoryClass
Resolving variable decl instance : CFactory = NullLiteral
Resolving variable decl this : CFactory = CFactory alloc() as CFactory
Resolving variable decl productType : Int
Resolving variable decl filename : String
CFactory.meshes clear() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CFactory.meshes clear() (of type FunctionCall) wants to wholeAgain() because 'CFactory.meshes clear() looping because not resolved!'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CProduct
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl MESH : <unknown type> = 0
Resolving variable decl TEXTURE : <unknown type> = 1
====== Resolving type decl ClassDecl CProduct
Resolving variable decl filename : String
Resolving variable decl id : Int
====== Resolving type decl ClassDecl CProductClass
Resolving variable decl this : <unknown type> = CProduct alloc() as CProduct
CProduct alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl CProductClass
Resolving variable decl this : CProduct = CProduct alloc() as CProduct
====== Resolving type decl ClassDecl StaticMesh
Resolving variable decl vertices : ArrayList<Float3>
Resolving variable decl normals : ArrayList<Float3>
Resolving variable decl faces : ArrayList<FaceNoTex>
Resolving variable decl dlist : GLuint = 0
====== Resolving type decl ClassDecl StaticMeshClass
Resolving variable decl this : <unknown type> = StaticMesh alloc() as StaticMesh
StaticMesh alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=filename (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl source : <unknown type> = FileReader new(filename)
FileReader new(filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type FileReader'
Resolving variable decl nVertices : Int = 0
Resolving variable decl nNormals : Int = 0
Resolving variable decl nFaces : Int = 0
source read(nVertices&, 0, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(nFaces&, 0, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
printf("%d vertices, %d faces and %d vertex normals\n", nVertices, nFaces, nNormals) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
ArrayList<Float3> new(nVertices) (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<Float3>'
ArrayList<Float3> new(nVertices) (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<Float3>'
ArrayList<VFace> new(nFaces) (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<VFace>'
     - access to Float3->size still not resolved, looping (ref = (nil))
Float3Class.size (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve Float3Class.size'
Float3Class.size * nVertices (of type BinaryOp) wants to wholeAgain() because 'score of operator *(v1 : Double3, n : Double) == -1 !!'
Float3Class.size * nVertices (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Float3Class.size (who is null? true, false, false, false)'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) looping because not resolved!'
     - access to Float3->size still not resolved, looping (ref = (nil))
Float3Class.size (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve Float3Class.size'
Float3Class.size * nVertices (of type BinaryOp) wants to wholeAgain() because 'score of operator *(v1 : Double3, n : Double) == -1 !!'
Float3Class.size * nVertices (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Float3Class.size (who is null? true, false, false, false)'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) looping because not resolved!'
     - access to VFace->size still not resolved, looping (ref = (nil))
VFaceClass.size (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve VFaceClass.size'
VFaceClass.size * nFaces (of type BinaryOp) wants to wholeAgain() because 'score of operator *(v1 : Double3, n : Double) == -1 !!'
VFaceClass.size * nFaces (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = VFaceClass.size (who is null? true, false, false, false)'
source read(ArrayList<FaceNoTex>.data, 0, VFaceClass.size * nFaces) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(ArrayList<FaceNoTex>.data, 0, VFaceClass.size * nFaces) (of type FunctionCall) wants to wholeAgain() because 'source read(ArrayList<FaceNoTex>.data, 0, VFaceClass.size * nFaces) looping because not resolved!'
glGenLists(1) (of type FunctionCall) wants to wholeAgain() because 'because of return type GLuint'
glNewList(dlist, GL_COMPILE) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
this draw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
glEndList() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glBegin(GL_TRIANGLES) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
printf("%d faces\n", ArrayList<FaceNoTex>.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v1 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v1 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v1 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glNormal3f(x, y, z) looping because not resolved!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v1 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v1 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v1 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glVertex3f(x, y, z) looping because not resolved!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v2 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v2 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v2 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glNormal3f(x, y, z) looping because not resolved!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v2 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v2 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v2 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glVertex3f(x, y, z) looping because not resolved!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v3 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v3 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v3 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
normals[v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glNormal3f(x, y, z) looping because not resolved!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v3 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v3 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
faces[i] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
v3 (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
vertices[v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glVertex3f(x, y, z) looping because not resolved!'
glEnd() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glCallList(dlist) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
====== Resolving type decl ClassDecl StaticMeshClass
Resolving variable decl this : StaticMesh = StaticMesh alloc() as StaticMesh
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl nVertices : Int = 0
Resolving variable decl nNormals : Int = 0
Resolving variable decl nFaces : Int = 0
     - access to Float3->size still not resolved, looping (ref = (nil))
Float3Class.size (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve Float3Class.size'
Float3Class.size * nVertices (of type BinaryOp) wants to wholeAgain() because 'score of operator *(v1 : Double3, n : Double) == -1 !!'
Float3Class.size * nVertices (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Float3Class.size (who is null? true, false, false, false)'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) looping because not resolved!'
     - access to Float3->size still not resolved, looping (ref = (nil))
Float3Class.size (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve Float3Class.size'
Float3Class.size * nVertices (of type BinaryOp) wants to wholeAgain() because 'score of operator *(v1 : Double3, n : Double) == -1 !!'
Float3Class.size * nVertices (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = Float3Class.size (who is null? true, false, false, false)'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) looping because not resolved!'
     - access to VFace->size still not resolved, looping (ref = (nil))
VFaceClass.size (of type VariableAccess) wants to wholeAgain() because 'Couldn't resolve VFaceClass.size'
VFaceClass.size * nFaces (of type BinaryOp) wants to wholeAgain() because 'score of operator *(v1 : Double3, n : Double) == -1 !!'
VFaceClass.size * nFaces (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = VFaceClass.size (who is null? true, false, false, false)'
source read(ArrayList<FaceNoTex>.data, 0, VFaceClass.size * nFaces) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(ArrayList<FaceNoTex>.data, 0, VFaceClass.size * nFaces) (of type FunctionCall) wants to wholeAgain() because 'source read(ArrayList<FaceNoTex>.data, 0, VFaceClass.size * nFaces) looping because not resolved!'
Resolving variable decl i : Int
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glNormal3f(x, y, z) looping because not resolved!'
Resolving variable decl genCall37 : FaceNoTex
Resolving variable decl genCall38 : FaceNoTex
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl genCall40 : Float3
Resolving variable decl genCall41 : Float3
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v1] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glVertex3f(x, y, z) looping because not resolved!'
Resolving variable decl genCall43 : FaceNoTex
Resolving variable decl genCall44 : FaceNoTex
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl genCall46 : Float3
Resolving variable decl genCall47 : Float3
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glNormal3f(x, y, z) looping because not resolved!'
Resolving variable decl genCall49 : FaceNoTex
Resolving variable decl genCall50 : FaceNoTex
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl genCall52 : Float3
Resolving variable decl genCall53 : Float3
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v2] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glVertex3f(x, y, z) looping because not resolved!'
Resolving variable decl genCall55 : FaceNoTex
Resolving variable decl genCall56 : FaceNoTex
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl genCall58 : Float3
Resolving variable decl genCall59 : Float3
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.normals[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.normals[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glNormal3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glNormal3f(x, y, z) looping because not resolved!'
Resolving variable decl genCall61 : FaceNoTex
Resolving variable decl genCall62 : FaceNoTex
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3)
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl genCall64 : Float3
Resolving variable decl genCall65 : Float3
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.normals, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glNormal3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.faces, i)
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type FaceNoTex'
__OP_IDX_ArrayList_Int__T(StaticMesh.faces, i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
StaticMesh.vertices[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'because of array dereference type!'
StaticMesh.vertices[FaceNoTex.v3] (of type ArrayAccess) wants to wholeAgain() because 'Just been replaced with an overload'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
glVertex3f(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'glVertex3f(x, y, z) looping because not resolved!'
Resolving variable decl genCall67 : FaceNoTex
Resolving variable decl genCall68 : FaceNoTex
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
	$$$$ resolving returnType T for __OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3)
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl genCall70 : Float3
Resolving variable decl genCall71 : Float3
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
__OP_IDX_ArrayList_Int__T(StaticMesh.vertices, FaceNoTex.v3) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glVertex3f(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
====== Resolving type decl ClassDecl StaticTexture
====== Resolving type decl ClassDecl StaticTextureClass
Resolving variable decl this : <unknown type> = StaticTexture alloc() as StaticTexture
StaticTexture alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl StaticTextureClass
Resolving variable decl this : StaticTexture = StaticTexture alloc() as StaticTexture
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl PI : <unknown type> = 3.140000
====== Resolving type decl ClassDecl Double2
Resolving variable decl x : Double
Resolving variable decl y : Double
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : <unknown type> = Double2 alloc() as Double2
Double2 alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(x, y) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=x (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=y (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double3
Resolving variable decl x : Double
Resolving variable decl y : Double
Resolving variable decl z : Double
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : <unknown type> = Double3 alloc() as Double3
Double3 alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(x, y, z) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=x (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=y (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=z (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
Resolving variable decl v : This
Resolving variable decl this : <unknown type> = Double3 alloc() as Double3
Double3 alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(v) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl v : Double3
Resolving variable decl l : <unknown type> = length()
this length() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
l : <unknown type> = this length() (of type VariableDecl) wants to wholeAgain() because 'must determine type of l : <unknown type> = this length()
'
x /= l (of type BinaryOp) wants to wholeAgain() because 'score of operator /(a : Float3, d : Float) == -1 !!'
x /= l (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = x (who is null? false, false, true, false)'
y /= l (of type BinaryOp) wants to wholeAgain() because 'score of operator /(a : Float3, d : Float) == -1 !!'
y /= l (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = y (who is null? false, false, true, false)'
z /= l (of type BinaryOp) wants to wholeAgain() because 'score of operator /(a : Float3, d : Float) == -1 !!'
z /= l (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = z (who is null? false, false, true, false)'
sqrt(x * x + y * y + z * z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double'
"(" + x (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Double__String("(", x) + "|" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String("(", x) + "|" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String("(", x) (who is null? true, false, false, false)'
__OP_ADD_String_Double__String("(", x) + "|" + y (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String("(", x) + "|" + y (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String("(", x) + "|" (who is null? true, false, false, false)'
__OP_ADD_String_Double__String("(", x) + "|" + y + "|" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String("(", x) + "|" + y + "|" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String("(", x) + "|" + y (who is null? true, false, false, false)'
__OP_ADD_String_Double__String("(", x) + "|" + y + "|" + z (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String("(", x) + "|" + y + "|" + z (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String("(", x) + "|" + y + "|" (who is null? true, false, false, false)'
__OP_ADD_String_Double__String("(", x) + "|" + y + "|" + z + ")" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String("(", x) + "|" + y + "|" + z + ")" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String("(", x) + "|" + y + "|" + z (who is null? true, false, false, false)'
return __OP_ADD_String_Double__String("(", x) + "|" + y + "|" + z + ")" (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : <unknown type> = this length()
this length() (of type FunctionCall) wants to wholeAgain() because 'because of return type Double'
__OP_ADD_String_Double__String("(", Double3.x) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Double__String("(", Double3.x) + "|" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") (who is null? true, false, false, false)'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y (who is null? true, false, false, false)'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" + Double3.z (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" + Double3.z (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" (who is null? true, false, false, false)'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" + Double3.z + ")" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" + Double3.z + ")" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" + Double3.z (who is null? true, false, false, false)'
return __OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y + "|" + Double3.z + ")" (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl CoverDecl Float2
Resolving variable decl x : Float
Resolving variable decl y : Float
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : This
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl CoverDecl Float3
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : This
Resolving variable decl f : This
This new(Float3.x, Float3.y, Float3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl CoverDecl Float4
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : This
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl CoverDecl Octet3
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : This
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl CoverDecl Octet4
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : This
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl CoverDecl Int3
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : This
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl CoverDecl Int2
Resolving variable decl x : Int
Resolving variable decl y : Int
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : This
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl CoverDecl VFace
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl CoverDecl Face
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl CoverDecl FaceNoTex
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceNoTexClass
====== Resolving type decl ClassDecl FaceNoTexClass
Resolving variable decl v1 : Double3
Resolving variable decl n : Double
Double3 new(Double3.x * n, Double3.y * n, Double3.z * n) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Double3 new(Double3.x + Double3.x, Double3.y + Double3.y, Double3.z + Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Double3 new(Double3.x - Double3.x, Double3.y - Double3.y, Double3.z - Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Double3 new(Double3.y * Double3.z - Double3.z * Double3.y, Double3.z * Double3.x - Double3.x * Double3.z, Double3.x * Double3.y - Double3.y * Double3.x) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Double3 new(Double3.x * Double3.x, Double3.y * Double3.y, Double3.z * Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl v1 : Double3
Resolving variable decl vals : Double*
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Float3 new(Float3.x + Float3.x, Float3.y + Float3.y, Float3.z + Float3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
Resolving variable decl a : Float3
Resolving variable decl d : Float
Float3 new(Float3.x / d, Float3.y / d, Float3.z / d) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
Resolving variable decl i3 : Int3
Resolving variable decl vals : Int*
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/HashMap
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl HashEntry
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl key : String
Resolving variable decl value : T
value : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = HashEntry alloc() as HashEntry
HashEntry alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(key, value) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=key (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
HashEntry.value = value (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
memcpy(HashEntry.value, value, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl HashMap
Resolving variable decl T : Class
Resolving variable decl size : UInt
Resolving variable decl capacity : UInt
Resolving variable decl buckets : ArrayList<T>*
Resolving variable decl keys : ArrayList<String>
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = HashMap alloc() as HashMap
HashMap alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
init(100) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
init(100) (of type FunctionCall) wants to wholeAgain() because 'init(100) looping because not resolved!'
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = HashMap alloc() as HashMap
HashMap alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(capacity) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=capacity (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
gc_malloc(capacity * PointerClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
"Out of memory: failed to allocate " + (capacity * PointerClass.size) + " bytes\n" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n")) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n")) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n")) looping because not resolved!'
Exception new(This, __OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n")) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n")) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n")) throw() looping because not resolved!'
Resolving variable decl i : UInt
i : UInt (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
ArrayList<T> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<T>'
ArrayList<String> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<String>'
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : <unknown type> = size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : <unknown type> = keyTagazok as Octet*
Resolving variable decl k : <unknown type> = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = ac_X31_hash(key) % capacity
this ac_X31_hash(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type UInt'
Resolving variable decl iter : <unknown type> = buckets[hash] iterator()
buckets[hash] iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
iter : <unknown type> = buckets[hash] iterator() (of type VariableDecl) wants to wholeAgain() because 'must determine type of iter : <unknown type> = buckets[hash] iterator()
'
iter hasNext() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
iter hasNext() (of type FunctionCall) wants to wholeAgain() because 'iter hasNext() looping because not resolved!'
iter next() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
iter next() (of type FunctionCall) wants to wholeAgain() because 'iter next() looping because not resolved!'
entry = iter next() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
HashEntry<T>.key equals(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : <unknown type> = getEntry(key)
this getEntry(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type HashEntry<T>'
HashEntry<T>.value = value (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
keys add(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this ac_X31_hash(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type UInt'
HashEntry<T> new(key, value) (of type FunctionCall) wants to wholeAgain() because 'because of return type HashEntry<T>'
buckets[hash] add(entry) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl v1 : Int = capacity / 0.700000
Resolving variable decl v2 : Int = capacity * 2
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl key : String
Resolving variable decl value : T
this put(key, value) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl key : String
Resolving variable decl entry : <unknown type> = getEntry(key)
this getEntry(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type HashEntry<T>'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
Response of statement [If] if (entry) = LOOP
))))))) For get: func (key : String), response of body = LOOP
Response of fDecl get: func (key : String) = LOOP
-- ClassDecl HashMapClass, meta of ClassDecl HashMap, isn't resolved, looping.
response of tDecl ClassDecl HashMap = LOOP
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
this init(100) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
__OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n")) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, __OP_ADD_String_String__String("Out of memory: failed to allocate " + (capacity * PointerClass.size), " bytes\n")) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % capacity
Resolving variable decl iter : <unknown type> = buckets[hash] iterator()
HashMap.buckets[hash] iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
iter : <unknown type> = HashMap.buckets[hash] iterator() (of type VariableDecl) wants to wholeAgain() because 'must determine type of iter : <unknown type> = HashMap.buckets[hash] iterator()
'
iter hasNext() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
iter hasNext() (of type FunctionCall) wants to wholeAgain() because 'iter hasNext() looping because not resolved!'
iter next() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
iter next() (of type FunctionCall) wants to wholeAgain() because 'iter next() looping because not resolved!'
entry = iter next() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
memcpy(HashEntry<T>.value, value, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl v1 : Int = capacity / 0.700000
Resolving variable decl v2 : Int = capacity * 2
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : <unknown type> = HashEntry<T>.value
returnVal73 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal73 = HashEntry<T>.value (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg72 = returnVal73 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For get: func (key : String), response of body = LOOP
Response of fDecl get: func (key : String) = LOOP
response of tDecl ClassDecl HashMapClass = LOOP
====== Resolving type decl ClassDecl HashMapValueIterator
Resolving variable decl T : Class
Resolving variable decl map : HashMap<T>
Resolving variable decl index : <unknown type> = 0
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = HashMapValueIterator alloc() as HashMapValueIterator
HashMapValueIterator alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(map) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=map (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
HashMap<T>.keys size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl key : <unknown type> = keys get(index)
	$$$$ resolving returnType T for HashMap<T>.keys get(index)
HashMap<T>.keys get(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
key = HashMap<T>.keys get(HashMapValueIterator.index) (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
	$$$$ resolving returnType T for map get(key)
map get(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
map get(key) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
return (comma expr) (of type Return) wants to wholeAgain() because 'expr type is unresolved'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For next: func , response of body = LOOP
Response of fDecl next: func  = LOOP
-- ClassDecl HashMapValueIteratorClass, meta of ClassDecl HashMapValueIterator, isn't resolved, looping.
response of tDecl ClassDecl HashMapValueIterator = LOOP
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
HashMap<T>.keys size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl key : String
Resolving variable decl genCall75 : T
genCall75 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl returnVal77 : <unknown type> = (comma expr)
returnVal77 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal77 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg76 = returnVal77 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl key : <unknown type> = keys get(index)
	$$$$ resolving returnType T for HashMap<T>.keys get(index)
HashMap<T>.keys get(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
key = HashMap<T>.keys get(HashMapValueIterator.index) (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
	$$$$ resolving returnType T for map get(key)
map get(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
map get(key) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
return (comma expr) (of type Return) wants to wholeAgain() because 'expr type is unresolved'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For prev: func , response of body = LOOP
Response of fDecl prev: func  = LOOP
response of tDecl ClassDecl HashMapValueIteratorClass = LOOP
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl T : Class
	$$$$ resolving returnType T for map get(key)
map get(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl T : Class
map put(key, value) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module FFCamera
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl FFCamera
Resolving variable decl speed : Double
Resolving variable decl sensivity : Double
Resolving variable decl phi : Double
Resolving variable decl theta : Double
Resolving variable decl forward : <unknown type> = Double3 new(0, 0, 0)
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl left : <unknown type> = Double3 new(0, 0, 0)
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl kforward : <unknown type> = false
Resolving variable decl kbackward : <unknown type> = false
Resolving variable decl kstrafe_left : <unknown type> = false
Resolving variable decl kstrafe_right : <unknown type> = false
Resolving variable decl keyconf : <unknown type> = HashMap<Int> new()
HashMap<Int> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type HashMap<Int>'
Resolving variable decl keystates : <unknown type> = HashMap<Bool> new()
HashMap<Bool> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type HashMap<Bool>'
Resolving variable decl enabled : <unknown type> = true
====== Resolving type decl ClassDecl FFCameraClass
.position (of type DotArg) wants to wholeAgain() because 'Hasn't resolved type yet :x'
Resolving variable decl this : <unknown type> = FFCamera alloc() as FFCamera
FFCamera alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FFCamera alloc() (of type FunctionCall) wants to wholeAgain() because 'FFCamera alloc() looping because not resolved!'
this : FFCamera = FFCamera alloc() as FFCamera (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(position) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this init(position) (of type FunctionCall) wants to wholeAgain() because 'this init(position) looping because not resolved!'
.position (of type DotArg) wants to wholeAgain() because 'Hasn't resolved type yet :x'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
FFCamera.position = position (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = position (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
this vectorsFromAngles() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
keystates put("forward", false) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
keystates put("backward", false) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
keystates put("strafe_left", false) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
keystates put("strafe_right", false) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
keystates put("boost", false) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
target = Double3 new(0, 0, 0) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
target = Double3 new(0, 0, 0) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CInputTask'
CInputTask get() regEvent(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl e : Motion
this vectorsFromAngles() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
gluLookAt(x, y, z, x, y, z, 0, 0, 1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
gluLookAt(x, y, z, x, y, z, 0, 0, 1) (of type FunctionCall) wants to wholeAgain() because 'gluLookAt(x, y, z, x, y, z, 0, 0, 1) looping because not resolved!'
Resolving variable decl event : Event
Resolving variable decl e : Key
Resolving variable decl a : <unknown type> = sym
Resolving variable decl e : Key
Resolving variable decl a : <unknown type> = sym
=speed (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=sensivity (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=position (of type AssArg) wants to wholeAgain() because 'Hasn't resolved type yet :x'
=position (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
FFCamera.position = position (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = position (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
Resolving variable decl up : <unknown type> = Double3 new(0, 0, 1)
Double3 new(0, 0, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl rTemp : <unknown type> = cos(phi / 180.000000)
cos(phi / 180.000000) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double'
sin(phi / 180.000000) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double'
cos(theta / 180.000000) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double'
sin(theta / 180.000000) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double'
up ^ forward (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
up ^ forward (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
left = __OP_B_XOR_Double3_Double3__Double3(up, forward) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
left = __OP_B_XOR_Double3_Double3__Double3(up, forward) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
left normalize() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
position + forward (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
position + forward (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = position (who is null? true, false, false, false)'
target = position + forward (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
target = position + forward (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
forward * speed (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
forward * speed (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
position + __OP_MUL_Double3_Double__Double3(forward, speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
position + __OP_MUL_Double3_Double__Double3(forward, speed) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = position (who is null? true, false, true, false)'
position = position + __OP_MUL_Double3_Double__Double3(forward, speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
position = position + __OP_MUL_Double3_Double__Double3(forward, speed) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
forward * speed (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
forward * speed (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
position - __OP_MUL_Double3_Double__Double3(forward, speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
position - __OP_MUL_Double3_Double__Double3(forward, speed) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = position (who is null? true, false, true, false)'
position = position - __OP_MUL_Double3_Double__Double3(forward, speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
position = position - __OP_MUL_Double3_Double__Double3(forward, speed) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
left * speed (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
left * speed (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
position + __OP_MUL_Double3_Double__Double3(left, speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
position + __OP_MUL_Double3_Double__Double3(left, speed) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = position (who is null? true, false, true, false)'
position = position + __OP_MUL_Double3_Double__Double3(left, speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
position = position + __OP_MUL_Double3_Double__Double3(left, speed) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
left * speed (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
left * speed (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
position - __OP_MUL_Double3_Double__Double3(left, speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
position - __OP_MUL_Double3_Double__Double3(left, speed) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = position (who is null? true, false, true, false)'
position = position - __OP_MUL_Double3_Double__Double3(left, speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
position = position - __OP_MUL_Double3_Double__Double3(left, speed) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
position + forward (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
position + forward (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = position (who is null? true, false, false, false)'
target = position + forward (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
target = position + forward (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
====== Resolving type decl ClassDecl FFCameraClass
.position (of type DotArg) wants to wholeAgain() because 'Hasn't resolved type yet :x'
Resolving variable decl this : FFCamera = FFCamera alloc() as FFCamera
FFCamera alloc() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FFCamera alloc() (of type FunctionCall) wants to wholeAgain() because 'FFCamera alloc() looping because not resolved!'
this : FFCamera = FFCamera alloc() as FFCamera (of type VariableDecl) wants to wholeAgain() because 'fCall isn't resolved.'
this init(position) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this init(position) (of type FunctionCall) wants to wholeAgain() because 'this init(position) looping because not resolved!'
.position (of type DotArg) wants to wholeAgain() because 'Hasn't resolved type yet :x'
FFCamera.position = position (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = position (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
Resolving variable decl genArg81 : Bool = false
Resolving variable decl genArg82 : Bool = false
Resolving variable decl genArg83 : Bool = false
Resolving variable decl genArg84 : Bool = false
Resolving variable decl genArg85 : Bool = false
FFCamera.target = Double3 new(0, 0, 0) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.target = Double3 new(0, 0, 0) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
Resolving variable decl e : Motion
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
x (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
y (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
z (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
gluLookAt(x, y, z, x, y, z, 0, 0, 1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
gluLookAt(x, y, z, x, y, z, 0, 0, 1) (of type FunctionCall) wants to wholeAgain() because 'gluLookAt(x, y, z, x, y, z, 0, 0, 1) looping because not resolved!'
Resolving variable decl event : Event
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
=position (of type AssArg) wants to wholeAgain() because 'Hasn't resolved type yet :x'
FFCamera.position = position (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = position (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
Resolving variable decl up : Double3 = Double3 new(0, 0, 1)
Resolving variable decl rTemp : Double = cos(phi / 180.000000)
__OP_B_XOR_Double3_Double3__Double3(up, FFCamera.forward) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = FFCamera.position (who is null? true, false, false, false)'
FFCamera.target = FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.target = FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
__OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = FFCamera.position (who is null? true, false, false, false)'
FFCamera.position = FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
__OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = FFCamera.position (who is null? true, false, false, false)'
FFCamera.position = FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
__OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = FFCamera.position (who is null? true, false, false, false)'
FFCamera.position = FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
__OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = FFCamera.position (who is null? true, false, false, false)'
FFCamera.position = FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = FFCamera.position (who is null? true, false, false, false)'
FFCamera.target = FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.target = FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'left type is unresolved'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module Camera
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Camera
Resolving variable decl target : <unknown type> = Double3 new(0, 0, 0)
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl position : <unknown type> = Double3 new(1, 1, 1)
Double3 new(1, 1, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl rotation : <unknown type> = Double3 new(0, 0, 0)
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl scale : <unknown type> = Double3 new(1, 1, 1)
Double3 new(1, 1, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
====== Resolving type decl ClassDecl CameraClass
Resolving variable decl this : <unknown type> = Camera alloc() as Camera
Camera alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
gluLookAt(Double3.x + 0.100000, Double3.y + 0.100000, Double3.z + 0.100000, Double3.x + Double3.x, Double3.y + Double3.y, Double3.z + Double3.z, Double3.x, Double3.y, Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl event : Event
====== Resolving type decl ClassDecl CameraClass
Resolving variable decl this : Camera = Camera alloc() as Camera
Resolving variable decl event : Event
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module Movable
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Movable
Resolving variable decl position : Double3
Resolving variable decl rotation : Double3
Resolving variable decl scale : Double3
====== Resolving type decl ClassDecl MovableClass
Resolving variable decl this : <unknown type> = Movable alloc() as Movable
Movable alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Double3 new(1, 1, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
====== Resolving type decl ClassDecl MovableClass
Resolving variable decl this : Movable = Movable alloc() as Movable
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module World
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl World
Resolving variable decl objects : <unknown type> = LinkedList<GameObject> new()
LinkedList<GameObject> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedList<GameObject>'
Resolving variable decl id : <unknown type> = 0
Resolving variable decl pickedID : <unknown type> = -1
Resolving variable decl picked : GameObject = NullLiteral
====== Resolving type decl ClassDecl WorldClass
Resolving variable decl this : <unknown type> = World alloc() as World
World alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl mode : GLenum
Resolving variable decl object : <unknown type>
object : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl object : <unknown type>
object : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl cam : Camera
Resolving variable decl BUFSIZE : <unknown type> = 512
Resolving variable decl selectBuf : GLuint[BUFSIZE]
Resolving variable decl hits : GLint
Resolving variable decl viewport : GLint[4]
glSelectBuffer(BUFSIZE, selectBuf) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glGetIntegerv(GL_VIEWPORT, viewport) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRenderMode(GL_SELECT) (of type FunctionCall) wants to wholeAgain() because 'because of return type GLint'
glInitNames() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPushName(0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glMatrixMode(GL_PROJECTION) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPushMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLoadIdentity() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
gluPickMatrix(x as GLdouble, (viewport[3] - y) as GLdouble, 5.000000, 5.000000, viewport) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
gluPerspective(60, 1280 as Float / 800 as Float, 0.010000, 1000) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
glMatrixMode(GL_MODELVIEW) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glLoadIdentity() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
cam look() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this render(GL_SELECT) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
glMatrixMode(GL_PROJECTION) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPopMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRenderMode(GL_RENDER) (of type FunctionCall) wants to wholeAgain() because 'because of return type GLint'
glMatrixMode(GL_MODELVIEW) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glFlush() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
Resolving variable decl minz : <unknown type> = 2147483647
Resolving variable decl minid : <unknown type> = -1
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
Resolving variable decl hits : GLint
Resolving variable decl names : GLuint*
printf("%d hits:\n", hits) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl jayjay : <unknown type> = 2147483647
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
printf("Number: %d\nMin Z: 0x%0x\nMax Z: 0x%0x\nName on stack: %d\n", names[i * 4] as GLubyte, (names[i * 4 + 1]), (names[i * 4 + 2]), names[i * 4 + 3] as GLubyte) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
println() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl object : GameObject
objects add(object) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
GameObject.id = id (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = GameObject.id (who is null? false, true, false, false)'
objects clear() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CFactory'
CFactory get() clear() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl filename : String
printf("Opening %s...\n", filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl target : <unknown type> = FileWriter new(filename)
FileWriter new(filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type FileWriter'
printf("O_O: Cannot open %s !\n", filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CFactory'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
printf("Saving %d meshes...\n", size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CFactory'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size toString() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
size toString() (of type FunctionCall) wants to wholeAgain() because 'size toString() looping because not resolved!'
target write(size toString()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
target write(size toString()) (of type FunctionCall) wants to wholeAgain() because 'target write(size toString()) looping because not resolved!'
target write("\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl mesh : <unknown type>
mesh : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CFactory'
CFactory.meshes iterator() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CFactory.meshes iterator() (of type FunctionCall) wants to wholeAgain() because 'CFactory.meshes iterator() looping because not resolved!'
for (mesh in CFactory.meshes) (of type Foreach) wants to wholeAgain() because 'need iterType'
printf("Saving %d objects...\n", LinkedList<GameObject>.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
target write(LinkedList<GameObject>.size&, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl object : <unknown type>
object : <unknown type> (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
printf("Level saved =)\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
target close() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl filename : String
printf("Opening %s...\n", filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl source : <unknown type> = FileReader new(filename)
FileReader new(filename) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FileReader new(filename) (of type FunctionCall) wants to wholeAgain() because 'FileReader new(filename) looping because not resolved!'
source : <unknown type> = FileReader new(filename) (of type VariableDecl) wants to wholeAgain() because 'must determine type of source : <unknown type> = FileReader new(filename)
'
printf("O_O: Cannot open %s !\n", filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
objects clear() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CFactory'
CFactory get() clear() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileMeshes : <unknown type> = HashMap<String> new()
HashMap<String> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type HashMap<String>'
Resolving variable decl line : <unknown type> = readLine(source)
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'readLine(source) looping because not resolved!'
line : <unknown type> = readLine(source) (of type VariableDecl) wants to wholeAgain() because 'must determine type of line : <unknown type> = readLine(source)
'
Resolving variable decl nMeshes : <unknown type> = 0
sscanf(line, "%d", nMeshes&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
sscanf(line, "%d", nMeshes&) (of type FunctionCall) wants to wholeAgain() because 'sscanf(line, "%d", nMeshes&) looping because not resolved!'
printf("nMeshes: %d\n", nMeshes) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
Resolving variable decl line : <unknown type> = readLine(source)
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'readLine(source) looping because not resolved!'
line : <unknown type> = readLine(source) (of type VariableDecl) wants to wholeAgain() because 'must determine type of line : <unknown type> = readLine(source)
'
Resolving variable decl id : Int
Resolving variable decl filename : <unknown type> = String new(1024)
String new(1024) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
sscanf(line, "%d %s", id&, filename) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
sscanf(line, "%d %s", id&, filename) (of type FunctionCall) wants to wholeAgain() because 'sscanf(line, "%d %s", id&, filename) looping because not resolved!'
printf("id: %d, filename: %s\n", id, filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
id toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
fileMeshes add(id toString(), filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl nObjects : Int
source read(nObjects&, 0, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(nObjects&, 0, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(nObjects&, 0, IntClass.size) looping because not resolved!'
printf("nObjects: %d\n", nObjects) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
Resolving variable decl id : Int
source read(id&, 0, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(id&, 0, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(id&, 0, IntClass.size) looping because not resolved!'
Resolving variable decl px : Double
Resolving variable decl py : Double
Resolving variable decl pz : Double
Resolving variable decl rx : Double
Resolving variable decl ry : Double
Resolving variable decl rz : Double
Resolving variable decl sx : Double
Resolving variable decl sy : Double
Resolving variable decl sz : Double
source read(px&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(px&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(px&, 0, DoubleClass.size) looping because not resolved!'
source read(py&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(py&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(py&, 0, DoubleClass.size) looping because not resolved!'
source read(pz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(pz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(pz&, 0, DoubleClass.size) looping because not resolved!'
source read(rx&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(rx&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(rx&, 0, DoubleClass.size) looping because not resolved!'
source read(ry&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(ry&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(ry&, 0, DoubleClass.size) looping because not resolved!'
source read(rz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(rz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(rz&, 0, DoubleClass.size) looping because not resolved!'
source read(sx&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(sx&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(sx&, 0, DoubleClass.size) looping because not resolved!'
source read(sy&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(sy&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(sy&, 0, DoubleClass.size) looping because not resolved!'
source read(sz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source read(sz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'source read(sz&, 0, DoubleClass.size) looping because not resolved!'
Resolving variable decl pos : <unknown type> = Double3 new(px, py, pz)
Double3 new(px, py, pz) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl rot : <unknown type> = Double3 new(rx, ry, rz)
Double3 new(rx, ry, rz) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl scl : <unknown type> = Double3 new(sx, sy, sz)
Double3 new(sx, sy, sz) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
id toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
	$$$$ resolving returnType T for fileMeshes get(id toString())
fileMeshes get(id toString()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
fileMeshes get(id toString()) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
GameObject new((comma expr), pos, rot, scl) (of type FunctionCall) wants to wholeAgain() because 'because of return type GameObject'
GameObject new((comma expr), pos, rot, scl) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
GameObject new((comma expr), pos, rot, scl) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
this add(GameObject new((comma expr), pos, rot, scl)) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
GameObject new((comma expr), pos, rot, scl) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
GameObject new((comma expr), pos, rot, scl) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
printf("Loaded %d objects\n", LinkedList<GameObject>.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
printf("Level loaded =)\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
source close() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
source close() (of type FunctionCall) wants to wholeAgain() because 'source close() looping because not resolved!'
====== Resolving type decl ClassDecl WorldClass
Resolving variable decl this : World = World alloc() as World
Resolving variable decl mode : GLenum
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl cam : Camera
Resolving variable decl BUFSIZE : Int = 512
Resolving variable decl selectBuf : GLuint[BUFSIZE]
Resolving variable decl hits : GLint
Resolving variable decl viewport : GLint[4]
Resolving variable decl minz : Int = 2147483647
Resolving variable decl minid : Int = -1
Resolving variable decl i : Int
Resolving variable decl hits : GLint
Resolving variable decl names : GLuint*
Resolving variable decl jayjay : Int = 2147483647
Resolving variable decl i : Int
Resolving variable decl object : GameObject
GameObject.id = World.id (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = GameObject.id (who is null? false, true, false, false)'
Resolving variable decl filename : String
Resolving variable decl target : FileWriter = FileWriter new(filename)
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size (of type VariableAccess) wants to wholeAgain() because 'expr's type isn't resolved yet, and it's needed to resolve the access'
size toString() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
size toString() (of type FunctionCall) wants to wholeAgain() because 'size toString() looping because not resolved!'
target write(size toString()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
target write(size toString()) (of type FunctionCall) wants to wholeAgain() because 'target write(size toString()) looping because not resolved!'
Resolving variable decl mesh : <unknown type>
CFactory.meshes iterator() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CFactory.meshes iterator() (of type FunctionCall) wants to wholeAgain() because 'CFactory.meshes iterator() looping because not resolved!'
for (mesh in CFactory.meshes) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl filename : String
Resolving variable decl source : <unknown type> = FileReader new(filename)
FileReader new(filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type FileReader'
Resolving variable decl fileMeshes : HashMap<String> = HashMap<String> new()
Resolving variable decl line : <unknown type> = readLine(source)
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
line : <unknown type> = readLine(source) (of type VariableDecl) wants to wholeAgain() because 'must determine type of line : <unknown type> = readLine(source)
'
Resolving variable decl nMeshes : Int = 0
sscanf(line, "%d", nMeshes&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
sscanf(line, "%d", nMeshes&) (of type FunctionCall) wants to wholeAgain() because 'sscanf(line, "%d", nMeshes&) looping because not resolved!'
Resolving variable decl i : Int
Resolving variable decl line : <unknown type> = readLine(source)
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
line : <unknown type> = readLine(source) (of type VariableDecl) wants to wholeAgain() because 'must determine type of line : <unknown type> = readLine(source)
'
Resolving variable decl id : Int
Resolving variable decl filename : String = String new(1024)
sscanf(line, "%d %s", id&, filename) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
sscanf(line, "%d %s", id&, filename) (of type FunctionCall) wants to wholeAgain() because 'sscanf(line, "%d %s", id&, filename) looping because not resolved!'
Resolving variable decl nObjects : Int
source read(nObjects&, 0, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl i : Int
Resolving variable decl id : Int
source read(id&, 0, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl px : Double
Resolving variable decl py : Double
Resolving variable decl pz : Double
Resolving variable decl rx : Double
Resolving variable decl ry : Double
Resolving variable decl rz : Double
Resolving variable decl sx : Double
Resolving variable decl sy : Double
Resolving variable decl sz : Double
source read(px&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(py&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(pz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(rx&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(ry&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(rz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(sx&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(sy&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(sz&, 0, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl pos : Double3 = Double3 new(px, py, pz)
Resolving variable decl rot : Double3 = Double3 new(rx, ry, rz)
Resolving variable decl scl : Double3 = Double3 new(sx, sy, sz)
Resolving variable decl genCall86 : String
GameObject new((comma expr), pos, rot, scl) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
GameObject new((comma expr), pos, rot, scl) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
source close() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module GameObject
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl BOX : <unknown type> = 0
Resolving variable decl PLANE : <unknown type> = 1
Resolving variable decl SPHERE : <unknown type> = 2
====== Resolving type decl ClassDecl GameObject
Resolving variable decl model : CProduct = NullLiteral
Resolving variable decl bounds : <unknown type> = BOX
Resolving variable decl boundScale : <unknown type> = Double3 new(1, 1, 1)
Double3 new(1, 1, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
Resolving variable decl renderBounds : <unknown type> = false
Resolving variable decl id : Int
====== Resolving type decl ClassDecl GameObjectClass
Resolving variable decl this : <unknown type> = GameObject alloc() as GameObject
GameObject alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl this : <unknown type> = GameObject alloc() as GameObject
GameObject alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(name, pos) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl name : String
Resolving variable decl pos : Double3
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this setDisplayModel(name) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this setDisplayModel(name) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this setDisplayModel(name) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scale : Double3
Resolving variable decl this : <unknown type> = GameObject alloc() as GameObject
GameObject alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(name, pos, rot, scale) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scale : Double3
this init() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this setDisplayModel(name) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this setDisplayModel(name) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this setDisplayModel(name) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
glPushMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glTranslated(Double3.x, Double3.y, Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRotated(1, Double3.x, Double3.y, Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glScaled(Double3.x, Double3.y, Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
model render() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
glPopMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
Resolving variable decl name : String
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CFactory'
CFactory get() loadStatic(MESH, name) (of type FunctionCall) wants to wholeAgain() because 'because of return type CProduct'
====== Resolving type decl ClassDecl GameObjectClass
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scale : Double3
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scale : Double3
Resolving variable decl name : String
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/text
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl filereader : FileReader
Resolving variable decl line : <unknown type> = String new(254)
String new(254) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl nbytes : <unknown type> = 254
Resolving variable decl nchars : <unknown type> = 0
getline(line&, nbytes&, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl line : String
Resolving variable decl buffer : <unknown type> = String new(8)
String new(8) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl i : <unknown type> = 0
Resolving variable decl n : <unknown type> = 0
printf("line: %s\n", line) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Exception new("getFirstToken: Buffer overflow") (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new("getFirstToken: Buffer overflow") throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : <unknown type> = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : <unknown type> = FileReader new(fromName)
FileReader new(fromName) (of type FunctionCall) wants to wholeAgain() because 'because of return type FileReader'
printf("analyzing file...\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
source hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl line : <unknown type> = readLine(source)
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl ftoken : <unknown type> = getFirstToken(line)
getFirstToken(line) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
ftoken == "v" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
ftoken == "f" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
ftoken == "vt" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
ftoken == "vn" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
ftoken == "#" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
printf("%d vertices, %d faces, %d vertex normals and %d texture coordinates\n", nVertices, nFaces, nVertexNormals, nTexCoordinates) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
source reset(0) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * size)
gc_malloc(nVertices * Float3Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * size)
gc_malloc(nVertexNormals * Float3Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * size)
gc_malloc(nTexCoordinates * Float2Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl faces : Face* = gc_malloc(nFaces * size)
gc_malloc(nFaces * FaceClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * size)
gc_malloc(nFaces * FaceNoTexClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl currentLine : Int = 0
printf("populating arrays...\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
source hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl line : <unknown type> = readLine(source)
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl tok : <unknown type> = StringTokenizer new(line, " /")
StringTokenizer new(line, " /") (of type FunctionCall) wants to wholeAgain() because 'because of return type StringTokenizer'
StringTokenizer new(line, " /") (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
StringTokenizer new(line, " /") (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl ftoken : <unknown type> = tok nextToken()
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
ftoken : <unknown type> = tok nextToken() (of type VariableDecl) wants to wholeAgain() because 'must determine type of ftoken : <unknown type> = tok nextToken()
'
ftoken == "v" (of type Comparison) wants to wholeAgain() because 'score of operator ==(a : Float3, b : Float3) == -1 !!'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "f" (of type Comparison) wants to wholeAgain() because 'score of operator ==(a : Float3, b : Float3) == -1 !!'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "f" (of type Comparison) wants to wholeAgain() because 'score of operator ==(a : Float3, b : Float3) == -1 !!'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "vt" (of type Comparison) wants to wholeAgain() because 'score of operator ==(a : Float3, b : Float3) == -1 !!'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "vn" (of type Comparison) wants to wholeAgain() because 'score of operator ==(a : Float3, b : Float3) == -1 !!'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "#" (of type Comparison) wants to wholeAgain() because 'score of operator ==(a : Float3, b : Float3) == -1 !!'
printf("%s", line) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
printf("%d%%\n", currentLine / nLines) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
printf("recalculating individual normals for each vertex...\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * size)
gc_malloc(nFaces * VFaceClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * size)
gc_malloc(nVertices * Float3Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl vertex : Int
vertex : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
Resolving variable decl normal : <unknown type> = Float3 new(0, 0, 0)
Float3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
face : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
normal + normals[FaceNoTex.n1] (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
normal + normals[FaceNoTex.n1] (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
normal = __OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n1]) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
normal = __OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n1]) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
normal + normals[FaceNoTex.n2] (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
normal + normals[FaceNoTex.n2] (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
normal = __OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n2]) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
normal = __OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n2]) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
normal + normals[FaceNoTex.n3] (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
normal + normals[FaceNoTex.n3] (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
normal = __OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n3]) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
normal = __OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n3]) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
normal / meanCount (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
normal / meanCount (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
new_normals[vertex] = __OP_DIV_Float3_Float__Float3(normal, meanCount) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
new_normals[vertex] = __OP_DIV_Float3_Float__Float3(normal, meanCount) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
printf("%d%%\n", vertex / nVertices) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
printf("copying faces...\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl face : Int
face : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
printf("writing to file...\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
source close() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl file : <unknown type> = File new(toName)
File new(toName) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
file exists() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
file remove() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl dest : <unknown type> = FileWriter new(file, "wb")
FileWriter new(file, "wb") (of type FunctionCall) wants to wholeAgain() because 'because of return type FileWriter'
dest write(nVertices&, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
dest write(nFaces&, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
dest write(vertices, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
dest write(new_normals, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
dest write(new_faces, VFaceClass.size * nFaces) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
printf("sorry, tex coords unsupported yet :(\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
printf("DONE\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
dest close() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : <unknown type> = StringTokenizer alloc() as StringTokenizer
StringTokenizer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(input, delim) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : <unknown type> = StringTokenizer alloc() as StringTokenizer
StringTokenizer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(input, delim) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : <unknown type> = StringTokenizer alloc() as StringTokenizer
StringTokenizer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(input, delim, maxSplits) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
String new(delim) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : <unknown type> = StringTokenizer alloc() as StringTokenizer
StringTokenizer alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(input, delim, maxSplits) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=input (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=delim (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
=maxSplits (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizerIterator new(this) looping because not resolved!'
iterator: func  -> Iterator<String> (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
this hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
this hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
delim contains(input[index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
delim contains(input[index]) (of type FunctionCall) wants to wholeAgain() because 'delim contains(input[index]) looping because not resolved!'
this hasNext() && delim contains(input[index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
this hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
delim contains(input[index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
delim contains(input[index]) (of type FunctionCall) wants to wholeAgain() because 'delim contains(input[index]) looping because not resolved!'
this hasNext() && delim contains(input[index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : <unknown type> = index
input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'input substring(oldIndex) looping because not resolved!'
return input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
this hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
delim contains(input[index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
delim contains(input[index]) (of type FunctionCall) wants to wholeAgain() because 'delim contains(input[index]) looping because not resolved!'
this hasNext() && !delim contains(input[index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
input substring(oldIndex, index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input substring(oldIndex, index) (of type FunctionCall) wants to wholeAgain() because 'input substring(oldIndex, index) looping because not resolved!'
return input substring(oldIndex, index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizerIterator new(this) looping because not resolved!'
iterator: func  -> Iterator<String> (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : <unknown type> = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : <unknown type> = StringTokenizerIterator alloc() as StringTokenizerIterator
StringTokenizerIterator alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this init(st) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
=st (of type AssArg) wants to wholeAgain() because 'Just unwrapped!'
st hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
st nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For next: func , response of body = LOOP
Response of fDecl next: func  = LOOP
response of tDecl ClassDecl StringTokenizerIteratorClass = LOOP
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
StringTokenizer new(this, s, maxSplits) (of type FunctionCall) wants to wholeAgain() because 'because of return type StringTokenizer'
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
StringTokenizer new(this, c, maxSplits) (of type FunctionCall) wants to wholeAgain() because 'because of return type StringTokenizer'
Resolving variable decl s : String
StringTokenizer new(this, s) (of type FunctionCall) wants to wholeAgain() because 'because of return type StringTokenizer'
Resolving variable decl c : Char
StringTokenizer new(this, c) (of type FunctionCall) wants to wholeAgain() because 'because of return type StringTokenizer'
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : <unknown type> = StringTokenizer new(this, s)
StringTokenizer new(this, s) (of type FunctionCall) wants to wholeAgain() because 'because of return type StringTokenizer'
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : <unknown type> = StringTokenizer new(this, c)
StringTokenizer new(this, c) (of type FunctionCall) wants to wholeAgain() because 'because of return type StringTokenizer'
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = LOOP (wholeAgain = true)

=======================================

Tinkerer, round 2, 38 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module main
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CApplication get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CApplication'
CApplication get() run() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
main: func  -> Int (of type FunctionDecl) wants to wholeAgain() because 'was needing return'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CApplication
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CApplication
Resolving variable decl videoTask : CVideoUpdate
Resolving variable decl globalTimer : CGlobalTimer
Resolving variable decl inputTask : CInputTask
====== Resolving type decl ClassDecl CApplicationClass
Resolving variable decl instance : CApplication = NullLiteral
Resolving variable decl this : CApplication = CApplication alloc() as CApplication
CApplication alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
CGlobalTimer get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CGlobalTimer'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CInputTask'
Resolving variable decl test : LevelEditor = LevelEditor new()
CVideoUpdate get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CVideoUpdate'
Resolving variable decl kernel : <unknown type> = CKernel get()
CKernel get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CKernel'
kernel addTask(CApplication.globalTimer) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
kernel addTask(CApplication.inputTask) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
kernel addTask(CApplication.videoTask) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
kernel addTask(test) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
kernel execute() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
====== Resolving type decl ClassDecl CApplicationClass
Resolving variable decl instance : CApplication = NullLiteral
Resolving variable decl this : CApplication = CApplication alloc() as CApplication
Resolving variable decl test : LevelEditor = LevelEditor new()
Resolving variable decl kernel : CKernel = CKernel get()
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CVideoUpdate
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CVideoUpdate
Resolving variable decl scrWidth : Int
Resolving variable decl scrHeight : Int
Resolving variable decl scrBPP : Int
Resolving variable decl surface : Surface*
====== Resolving type decl ClassDecl CVideoUpdateClass
Resolving variable decl instance : CVideoUpdate = NullLiteral
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
CVideoUpdate alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
SDL init(SDL_INIT_EVERYTHING) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
SDL getError() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
CLog get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CLog'
CLog get() write(LOG_CLIENT, __OP_ADD_String_String__String("Video: ", SDL getError())) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CLog get() write(LOG_CLIENT, __OP_ADD_String_String__String("Video: ", SDL getError())) (of type FunctionCall) wants to wholeAgain() because 'CLog get() write(LOG_CLIENT, __OP_ADD_String_String__String("Video: ", SDL getError())) looping because not resolved!'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CInputTask'
CInputTask get() regEvent(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl flags : Int = SDL_OPENGL | SDL_ANYFORMAT
SDLVideo setMode(CVideoUpdate.scrWidth, CVideoUpdate.scrHeight, CVideoUpdate.scrBPP, flags) (of type FunctionCall) wants to wholeAgain() because 'because of return type Surface*'
SDL getError() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
"Video: " + SDL getError() (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
CLog get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CLog'
CLog get() write(LOG_CLIENT, __OP_ADD_String_String__String("Video: ", SDL getError())) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
CLog get() write(LOG_CLIENT, __OP_ADD_String_String__String("Video: ", SDL getError())) (of type FunctionCall) wants to wholeAgain() because 'CLog get() write(LOG_CLIENT, __OP_ADD_String_String__String("Video: ", SDL getError())) looping because not resolved!'
glShadeModel(GL_SMOOTH) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glEnable(GL_DEPTH_TEST) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
CInputTask get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CInputTask'
CInputTask get() unRegEvent(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
====== Resolving type decl ClassDecl CVideoUpdateClass
Resolving variable decl instance : CVideoUpdate = NullLiteral
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
__OP_ADD_String_String__String("Video: ", SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
CLog get() write(LOG_CLIENT, __OP_ADD_String_String__String("Video: ", SDL getError())) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl flags : Int = SDL_OPENGL | SDL_ANYFORMAT
__OP_ADD_String_String__String("Video: ", SDL getError()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
CLog get() write(LOG_CLIENT, __OP_ADD_String_String__String("Video: ", SDL getError())) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/stdio
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl stdout : FStream
Resolving variable decl stderr : FStream
Resolving variable decl stdin : FStream
====== Resolving type decl CoverDecl FILE
====== Resolving type decl ClassDecl FILEClass
====== Resolving type decl ClassDecl FILEClass
====== Resolving type decl CoverDecl FStream
====== Resolving type decl ClassDecl FStreamClass
Resolving variable decl c : Char
fread(c&, 1, 1, this) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl chunk : Int = 128
Resolving variable decl length : Int = chunk
Resolving variable decl pos : Int = 0
Resolving variable decl str : String = gc_malloc(length) as String
gc_malloc(length) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
str last() (of type FunctionCall) wants to wholeAgain() because 'because of return type Char'
Resolving variable decl tmp : String = gc_realloc(str, length) as String
gc_realloc(str, length) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Ran out of memory while reading a (apparently never-ending) line!") throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
feof(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl str : Char*
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
fwrite(str + offset, 1, length, this) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
====== Resolving type decl ClassDecl FStreamClass
Resolving variable decl c : Char
Resolving variable decl chunk : Int = 128
Resolving variable decl length : Int = chunk
Resolving variable decl pos : Int = 0
Resolving variable decl str : String = gc_malloc(length) as String
Resolving variable decl tmp : String = gc_realloc(str, length) as String
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl str : Char*
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
Resolving variable decl str : String
printf("%s\n", str) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
printf("\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl String
Resolving variable decl String
Resolving variable decl String
Resolving variable decl Int
Resolving variable decl String
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl String
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl String
Resolving variable decl Int
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl nmemb : SizeT
Resolving variable decl stream : FStream
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl nmemb : SizeT
Resolving variable decl stream : FStream
Resolving variable decl stream : FStream
Resolving variable decl String
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl stream : FStream
Resolving variable decl Char
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl format : String
Resolving variable decl stream : FStream
Resolving variable decl format : String
Resolving variable decl str : String
Resolving variable decl format : String
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl stream : FStream
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl str : String
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl str : String
Resolving variable decl length : SizeT
Resolving variable decl stream : FStream
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/memory
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl size : SizeT
Resolving variable decl size : SizeT
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl nmemb : SizeT
Resolving variable decl size : SizeT
Resolving variable decl Pointer
Resolving variable decl Int
Resolving variable decl SizeT
Resolving variable decl Pointer
Resolving variable decl Pointer
Resolving variable decl SizeT
Resolving variable decl Pointer
Resolving variable decl Pointer
Resolving variable decl SizeT
Resolving variable decl Pointer
Resolving variable decl Pointer
Resolving variable decl SizeT
Resolving variable decl Pointer
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module lang/memory finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Object
Resolving variable decl class : Class
====== Resolving type decl ClassDecl ObjectClass
Resolving variable decl T : Class
Object.class inheritsFrom(T) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
====== Resolving type decl ClassDecl ObjectClass
Resolving variable decl T : Class
====== Resolving type decl ClassDecl Class
Resolving variable decl instanceSize : SizeT
Resolving variable decl size : SizeT
Resolving variable decl name : String
Resolving variable decl super : Class
====== Resolving type decl ClassDecl ClassClass
Resolving variable decl object : Object = gc_malloc(Class.instanceSize) as Object
Resolving variable decl T : Class
====== Resolving type decl ClassDecl ClassClass
Resolving variable decl object : Object = gc_malloc(Class.instanceSize) as Object
Resolving variable decl T : Class
====== Resolving type decl ClassDecl None
====== Resolving type decl ClassDecl NoneClass
Resolving variable decl this : None = None alloc() as None
====== Resolving type decl ClassDecl NoneClass
Resolving variable decl this : None = None alloc() as None
====== Resolving type decl CoverDecl Void
====== Resolving type decl ClassDecl VoidClass
====== Resolving type decl ClassDecl VoidClass
====== Resolving type decl CoverDecl Pointer
====== Resolving type decl ClassDecl PointerClass
"%p" format(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
====== Resolving type decl ClassDecl PointerClass
====== Resolving type decl CoverDecl Char
====== Resolving type decl ClassDecl CharClass
String new(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
====== Resolving type decl ClassDecl CharClass
====== Resolving type decl CoverDecl SChar
====== Resolving type decl ClassDecl SCharClass
====== Resolving type decl ClassDecl SCharClass
====== Resolving type decl CoverDecl UChar
====== Resolving type decl ClassDecl UCharClass
====== Resolving type decl ClassDecl UCharClass
====== Resolving type decl CoverDecl WChar
====== Resolving type decl ClassDecl WCharClass
====== Resolving type decl ClassDecl WCharClass
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl length : SizeT
Resolving variable decl result : String = gc_malloc(length + 1) as String
Resolving variable decl c : Char
Resolving variable decl result : String = This new(1)
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl length : SizeT
Resolving variable decl i : SizeT
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl other : String
Resolving variable decl other : String
Resolving variable decl i : SizeT
Resolving variable decl s : String
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl l1 : SizeT = this length()
Resolving variable decl l2 : SizeT = s length()
Resolving variable decl offset : SizeT = (l1 - l2)
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl i : Int
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl slength : SizeT = s length()
Resolving variable decl i : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
Resolving variable decl s : String
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
Resolving variable decl c : Char
Resolving variable decl i : SizeT = this length()
Resolving variable decl start : SizeT
Resolving variable decl len : SizeT = this length()
Exception new(This, "substring") (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "substring") throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl diff : SizeT = (len - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl start : SizeT
Resolving variable decl end : SizeT
Resolving variable decl len : SizeT = this length()
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "String.substring: out of bounds: length = %zd, start = %zd, end = %zd\n" format(len, start, end)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl diff : SizeT = (end - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl len : SizeT = this length()
Resolving variable decl result : String = This new(len + 1)
Resolving variable decl i : SizeT
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : String = This new(length)
Resolving variable decl count : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl result : Char* = This new(length * count) as Char*
Resolving variable decl i : Int
Resolving variable decl other : String
Resolving variable decl length : SizeT = this length()
Resolving variable decl rlength : SizeT = other length()
Resolving variable decl copy : Char* = This new(length + rlength) as Char*
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl other : String
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl index : SizeT
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Accessing a String out of bounds index = %d, length = %d!" format(index, this length())) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl list : VaList
Resolving variable decl length : Int = vsnprintf(NullLiteral, 0, this, list)
Resolving variable decl output : String = This new(length)
StringIterator<Char> new(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type StringIterator<Char>'
====== Resolving type decl ClassDecl StringClass
Resolving variable decl length : SizeT
Resolving variable decl result : String = gc_malloc(length + 1) as String
Resolving variable decl c : Char
Resolving variable decl result : String = This new(1)
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl length : SizeT
Resolving variable decl i : SizeT
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl other : String
Resolving variable decl other : String
Resolving variable decl i : SizeT
Resolving variable decl s : String
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl l1 : SizeT = this length()
Resolving variable decl l2 : SizeT = s length()
Resolving variable decl offset : SizeT = (l1 - l2)
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl i : Int
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl slength : SizeT = s length()
Resolving variable decl i : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
Resolving variable decl s : String
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
Resolving variable decl c : Char
Resolving variable decl i : SizeT = this length()
Resolving variable decl start : SizeT
Resolving variable decl len : SizeT = this length()
Resolving variable decl diff : SizeT = (len - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl start : SizeT
Resolving variable decl end : SizeT
Resolving variable decl len : SizeT = this length()
Resolving variable decl diff : SizeT = (end - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl len : SizeT = this length()
Resolving variable decl result : String = This new(len + 1)
Resolving variable decl i : SizeT
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : String = This new(length)
Resolving variable decl count : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl result : Char* = This new(length * count) as Char*
Resolving variable decl i : Int
Resolving variable decl other : String
Resolving variable decl length : SizeT = this length()
Resolving variable decl rlength : SizeT = other length()
Resolving variable decl copy : Char* = This new(length + rlength) as Char*
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl other : String
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl index : SizeT
Resolving variable decl list : VaList
Resolving variable decl length : Int = vsnprintf(NullLiteral, 0, this, list)
Resolving variable decl output : String = This new(length)
====== Resolving type decl InterfaceDecl Comparable
====== Resolving type decl ClassDecl ComparableClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl Comparable__reference
Resolving variable decl impl : ComparableClass
Resolving variable decl obj : Object
====== Resolving type decl ClassDecl Comparable__referenceClass
====== Resolving type decl ClassDecl ComparableClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl LLong
====== Resolving type decl ClassDecl LLongClass
Resolving variable decl range : Range
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl InterfaceImpl LLong__impl__Comparable
====== Resolving type decl ClassDecl LLong__impl__ComparableClass
====== Resolving type decl ClassDecl LLong__impl__ComparableClass
====== Resolving type decl ClassDecl LLongClass
Resolving variable decl range : Range
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl Long
====== Resolving type decl ClassDecl LongClass
====== Resolving type decl ClassDecl LongClass
====== Resolving type decl CoverDecl Short
====== Resolving type decl ClassDecl ShortClass
====== Resolving type decl ClassDecl ShortClass
====== Resolving type decl CoverDecl Int
====== Resolving type decl ClassDecl IntClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl ClassDecl IntClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl ULLong
====== Resolving type decl ClassDecl ULLongClass
Resolving variable decl range : Range
====== Resolving type decl ClassDecl ULLongClass
Resolving variable decl range : Range
====== Resolving type decl CoverDecl ULong
====== Resolving type decl ClassDecl ULongClass
====== Resolving type decl ClassDecl ULongClass
====== Resolving type decl CoverDecl UInt
====== Resolving type decl ClassDecl UIntClass
====== Resolving type decl ClassDecl UIntClass
====== Resolving type decl CoverDecl UShort
====== Resolving type decl ClassDecl UShortClass
====== Resolving type decl ClassDecl UShortClass
====== Resolving type decl CoverDecl Int8
====== Resolving type decl ClassDecl Int8Class
====== Resolving type decl ClassDecl Int8Class
====== Resolving type decl CoverDecl Int16
====== Resolving type decl ClassDecl Int16Class
====== Resolving type decl ClassDecl Int16Class
====== Resolving type decl CoverDecl Int32
====== Resolving type decl ClassDecl Int32Class
====== Resolving type decl ClassDecl Int32Class
====== Resolving type decl CoverDecl Int64
====== Resolving type decl ClassDecl Int64Class
====== Resolving type decl ClassDecl Int64Class
====== Resolving type decl CoverDecl UInt8
====== Resolving type decl ClassDecl UInt8Class
====== Resolving type decl ClassDecl UInt8Class
====== Resolving type decl CoverDecl UInt16
====== Resolving type decl ClassDecl UInt16Class
====== Resolving type decl ClassDecl UInt16Class
====== Resolving type decl CoverDecl UInt32
====== Resolving type decl ClassDecl UInt32Class
====== Resolving type decl ClassDecl UInt32Class
====== Resolving type decl CoverDecl UInt64
====== Resolving type decl ClassDecl UInt64Class
====== Resolving type decl ClassDecl UInt64Class
====== Resolving type decl CoverDecl Octet
====== Resolving type decl ClassDecl OctetClass
====== Resolving type decl ClassDecl OctetClass
====== Resolving type decl CoverDecl SizeT
====== Resolving type decl ClassDecl SizeTClass
====== Resolving type decl ClassDecl SizeTClass
====== Resolving type decl CoverDecl Bool
====== Resolving type decl ClassDecl BoolClass
====== Resolving type decl ClassDecl BoolClass
====== Resolving type decl CoverDecl LDouble
====== Resolving type decl ClassDecl LDoubleClass
Resolving variable decl str : String = gc_malloc(64)
====== Resolving type decl ClassDecl LDoubleClass
Resolving variable decl str : String = gc_malloc(64)
====== Resolving type decl CoverDecl Double
====== Resolving type decl ClassDecl DoubleClass
====== Resolving type decl ClassDecl DoubleClass
====== Resolving type decl CoverDecl Float
====== Resolving type decl ClassDecl FloatClass
====== Resolving type decl ClassDecl FloatClass
====== Resolving type decl CoverDecl Range
Resolving variable decl min : Int
Resolving variable decl max : Int
====== Resolving type decl ClassDecl RangeClass
Resolving variable decl this : Range
====== Resolving type decl ClassDecl RangeClass
Resolving variable decl this : Range
====== Resolving type decl ClassDecl Iterator
Resolving variable decl T : Class
Resolving variable decl T : Class
====== Resolving type decl ClassDecl IteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterator = Iterator alloc() as Iterator
====== Resolving type decl ClassDecl IteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterator = Iterator alloc() as Iterator
====== Resolving type decl ClassDecl Iterable
Resolving variable decl T : Class
Resolving variable decl T : Class
====== Resolving type decl ClassDecl IterableClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterable = Iterable alloc() as Iterable
====== Resolving type decl ClassDecl IterableClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterable = Iterable alloc() as Iterable
====== Resolving type decl ClassDecl StringIterator
Resolving variable decl T : Class
Resolving variable decl i : Int = 0
Resolving variable decl str : String
====== Resolving type decl ClassDecl StringIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringIterator = StringIterator alloc() as StringIterator
Resolving variable decl c : Char = StringIterator.str[StringIterator.i]
Resolving variable decl returnVal2 : Char = c
memcpy(returnArg1, returnVal2&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl returnVal4 : <unknown type> = str[i]
returnArg3 = returnVal4 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
====== Resolving type decl ClassDecl StringIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringIterator = StringIterator alloc() as StringIterator
Resolving variable decl c : Char = StringIterator.str[StringIterator.i]
Resolving variable decl returnVal2 : Char = c
Resolving variable decl returnVal4 : Char = StringIterator.str[StringIterator.i]
memcpy(returnArg3, returnVal4&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl Exception
Resolving variable decl origin : Class
Resolving variable decl msg : String
====== Resolving type decl ClassDecl ExceptionClass
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl x : Int = 0
Resolving variable decl max : Int = 1024
Resolving variable decl buffer : String = gc_malloc(max) as String
====== Resolving type decl ClassDecl ExceptionClass
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl x : Int = 0
Resolving variable decl max : Int = 1024
Resolving variable decl buffer : String = gc_malloc(max) as String
Resolving variable decl str1 : String
Resolving variable decl str2 : String
Resolving variable decl str1 : String
Resolving variable decl str2 : String
Resolving variable decl str : String
Resolving variable decl count : Int
Resolving variable decl left : String
Resolving variable decl right : String
Resolving variable decl left : LLong
Resolving variable decl right : String
__OP_ADD_String_String__String(left toString(), right) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : String
Resolving variable decl right : LLong
__OP_ADD_String_String__String(left, right toString()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : Int
Resolving variable decl right : String
__OP_ADD_String_String__String(left toString(), right) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : String
Resolving variable decl right : Int
__OP_ADD_String_String__String(left, right toString()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : Bool
Resolving variable decl right : String
__OP_ADD_String_String__String(left toString(), right) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : String
Resolving variable decl right : Bool
__OP_ADD_String_String__String(left, right toString()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : Double
Resolving variable decl right : String
__OP_ADD_String_String__String(left toString(), right) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : String
Resolving variable decl right : Double
__OP_ADD_String_String__String(left, right toString()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl left : String
Resolving variable decl right : Char
Resolving variable decl left : Char
Resolving variable decl right : String
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module ITask
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl ITask
Resolving variable decl canKill : Bool
Resolving variable decl priority : Long
====== Resolving type decl ClassDecl ITaskClass
Resolving variable decl this : ITask = ITask alloc() as ITask
ITask alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl ITaskClass
Resolving variable decl this : ITask = ITask alloc() as ITask
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module Listener
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Listener
====== Resolving type decl ClassDecl ListenerClass
Resolving variable decl this : Listener = Listener alloc() as Listener
Resolving variable decl event : Event
====== Resolving type decl ClassDecl ListenerClass
Resolving variable decl this : Listener = Listener alloc() as Listener
Resolving variable decl event : Event
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module Listener finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CLog
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl LOG_APP : Int = 1
Resolving variable decl LOG_CLIENT : Int = 2
Resolving variable decl LOG_SERVER : Int = 4
Resolving variable decl LOG_USER : Int = 8
Resolving variable decl MAX_LOG_STRINGS : Int = 256
====== Resolving type decl ClassDecl CLog
Resolving variable decl appLog : FileWriter
Resolving variable decl clientLog : FileWriter
Resolving variable decl serverLog : FileWriter
====== Resolving type decl ClassDecl CLogClass
Resolving variable decl instance : CLog = NullLiteral
Resolving variable decl this : CLog = CLog alloc() as CLog
Resolving variable decl target : Int
Resolving variable decl msg : String
Resolving variable decl target : Int
Resolving variable decl msgID : ULong
====== Resolving type decl ClassDecl CLogClass
Resolving variable decl instance : CLog = NullLiteral
Resolving variable decl this : CLog = CLog alloc() as CLog
Resolving variable decl target : Int
Resolving variable decl msg : String
Resolving variable decl target : Int
Resolving variable decl msgID : ULong
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module CLog finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/FileWriter
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl FileWriter
Resolving variable decl file : FStream
====== Resolving type decl ClassDecl FileWriterClass
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
fileObject getPath() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this init(fileObject getPath(), append) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileObject : File
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
FileWriter alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl fileName : String
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl fmt : String
Resolving variable decl ap : VaList
Resolving variable decl fmt : String
Resolving variable decl args : VaList
====== Resolving type decl ClassDecl FileWriterClass
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl fileObject : File
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl fmt : String
Resolving variable decl ap : VaList
Resolving variable decl fmt : String
Resolving variable decl args : VaList
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/Writer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Writer
====== Resolving type decl ClassDecl WriterClass
Resolving variable decl this : Writer = Writer alloc() as Writer
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chars : String
====== Resolving type decl ClassDecl WriterClass
Resolving variable decl this : Writer = Writer alloc() as Writer
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chars : String
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module io/Writer finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/File
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl File
Resolving variable decl path : String
====== Resolving type decl ClassDecl FileClass
Resolving variable decl MAX_PATH_LENGTH : Int = 16383
Resolving variable decl separator : Char = CharLiteral
Resolving variable decl pathDelimiter : Char = CharLiteral
FileUnix new(path) (of type FunctionCall) wants to wholeAgain() because 'because of return type FileUnix'
FileWin32 new(path) (of type FunctionCall) wants to wholeAgain() because 'because of return type FileWin32'
Resolving variable decl parent : File
__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), path)) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
Resolving variable decl parent : String
__OP_ADD_String_String__String(__OP_ADD_String_Char__String(parent, FileClass.separator), path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(parent, FileClass.separator), path)) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
fopen(File.path, "r") (of type FunctionCall) wants to wholeAgain() because 'because of return type FILE*'
Resolving variable decl trimmed : String = File.path trim(FileClass.separator)
Resolving variable decl idx : Int = trimmed lastIndexOf(FileClass.separator)
Resolving variable decl pName : String = this parentName()
Resolving variable decl idx : Int = File.path lastIndexOf(FileClass.separator)
Resolving variable decl mode : Int32
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
_remove(File.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl dstFile : File
Resolving variable decl src : FileReader = FileReader new(this)
Resolving variable decl dst : FileWriter = FileWriter new(dstFile)
Resolving variable decl max : Int = 8192
Resolving variable decl buffer : Char[max]
src hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl num : <unknown type> = src read(buffer, 0, max)
src read(buffer, 0, max) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
dst write(buffer, num) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl name : String
__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), name) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
this new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(File.path, FileClass.separator), name)) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
Resolving variable decl ret : String = String new(FileClass.MAX_PATH_LENGTH + 1)
_getcwd(ret, FileClass.MAX_PATH_LENGTH) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
====== Resolving type decl ClassDecl FileClass
Resolving variable decl MAX_PATH_LENGTH : Int = 16383
Resolving variable decl separator : Char = CharLiteral
Resolving variable decl pathDelimiter : Char = CharLiteral
Resolving variable decl parent : File
Resolving variable decl parent : String
Resolving variable decl trimmed : String = File.path trim(FileClass.separator)
Resolving variable decl idx : Int = trimmed lastIndexOf(FileClass.separator)
Resolving variable decl pName : String = this parentName()
Resolving variable decl idx : Int = File.path lastIndexOf(FileClass.separator)
Resolving variable decl mode : Int32
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
Resolving variable decl dstFile : File
Resolving variable decl src : FileReader = FileReader new(this)
Resolving variable decl dst : FileWriter = FileWriter new(dstFile)
Resolving variable decl max : Int = 8192
Resolving variable decl buffer : Char[max]
Resolving variable decl num : SizeT = src read(buffer, 0, max)
Resolving variable decl name : String
Resolving variable decl ret : String = String new(FileClass.MAX_PATH_LENGTH + 1)
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/ArrayList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl ArrayList
Resolving variable decl T : Class
Resolving variable decl data : T*
Resolving variable decl capacity : Int
Resolving variable decl size : Int = 0
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
ArrayList alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
Resolving variable decl element : T
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
memcpy(ArrayList.data[ArrayList.size * Class.size]&, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl index : Int
Resolving variable decl element : T
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
memmove(dst, src, Class.size * ArrayList.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(ArrayList.data[0 * Class.size]&, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this ensureCapacity(ArrayList.size + 1) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl bsize : Int = (ArrayList.size - index) * size
memcpy(ArrayList.data[index * Class.size]&, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl index : Int
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl returnVal6 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal6, ArrayList.data[index * Class.size]&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg5, returnVal6, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl element : T
Resolving variable decl index : Int = -1
Resolving variable decl candidate : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(candidate, ArrayList.data[index * Class.size]&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcmp(candidate, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl element : T
Resolving variable decl index : Int = size
Resolving variable decl candidate : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(candidate, ArrayList.data[index * Class.size]&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcmp(candidate, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl index : Int
Resolving variable decl element : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(element, ArrayList.data[index * Class.size]&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl returnVal8 : <unknown type> = element
returnVal8 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal8 = element (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg7 = returnVal8 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl element : T
Resolving variable decl index : <unknown type> = indexOf(element)
this indexOf(element) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
	$$$$ resolving returnType T for this removeAt(index)
this removeAt(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl index : Int
Resolving variable decl element : T
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this checkIndex(index) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl old : <unknown type> = data[index]
old : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
old = ArrayList.data[index * size] (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
data[index * size] = element (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl newSize : Int
this grow() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl tmpData : <unknown type> = gc_realloc(data, capacity * size)
gc_realloc(data, capacity * Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
printf("Failed to allocate %zu bytes of memory for array to grow! Exiting..\n", capacity * Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl x : <unknown type> = 0
Resolving variable decl index : Int
"Index too small! " + index (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Int__String("Index too small! ", index) + " < 0" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Index too small! ", index) + " < 0" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Index too small! ", index) (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_Int__String("Index too small! ", index) + " < 0") (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Index too small! ", index) + " < 0") (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Index too small! ", index) + " < 0") looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String("Index too small! ", index) + " < 0") throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Index too small! ", index) + " < 0") throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Index too small! ", index) + " < 0") throw() looping because not resolved!'
"Index too big! " + index (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Int__String("Index too big! ", index) + " >= " (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Index too big! ", index) + " >= " (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Index too big! ", index) (who is null? true, false, false, false)'
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
__OP_ADD_String_Int__String("Index too big! ", index) + " >= " + this size() (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Index too big! ", index) + " >= " + this size() (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Index too big! ", index) + " >= " (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_Int__String("Index too big! ", index) + " >= " + this size()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Index too big! ", index) + " >= " + this size()) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Index too big! ", index) + " >= " + this size()) looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String("Index too big! ", index) + " >= " + this size()) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Index too big! ", index) + " >= " + this size()) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Index too big! ", index) + " >= " + this size()) throw() looping because not resolved!'
ArrayListIterator<T> new(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayListIterator<T>'
return ArrayListIterator<T> new(this) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl copy : <unknown type> = This<T> new(size())
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
ArrayList<T> new(this size()) (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<T>'
copy addAll(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl bsize : Int = (ArrayList.size - index) * Class.size
Resolving variable decl index : Int
Resolving variable decl returnVal6 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = -1
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = ArrayList.size
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal8 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal8, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg7, returnVal8, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl element : T
Resolving variable decl index : Int = this indexOf(element)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl old : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(old, ArrayList.data[index * Class.size]&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(ArrayList.data[index * Class.size]&, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For set: func (index : Int, element : T), response of body = LOOP
Response of fDecl set: func (index : Int, element : T) = LOOP
response of tDecl ClassDecl ArrayListClass = LOOP
====== Resolving type decl ClassDecl ArrayListIterator
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
ArrayListIterator.list size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal10 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal10, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg9, returnVal10, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl element : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal12 : <unknown type> = element
returnVal12 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal12 = element (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg11 = returnVal12 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
	$$$$ resolving returnType T for list removeAt(index - 1)
list removeAt(index - 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
list removeAt(index - 1) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
list size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal10 : T = gc_malloc(Class.size)
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal12 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal12, element, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg11, returnVal12, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl genCall91 : T
genCall91 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
list get(i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For __OP_IDX_ArrayList_Int__T: func (list : ArrayList<T>, i : Int), response of body = LOOP
response of oDecl operator [](list : ArrayList<T>, i : Int) = LOOP
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
	$$$$ resolving returnType T for list set(i, element)
list set(i, element) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
list remove(element) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl data : T*
Resolving variable decl size : SizeT
Resolving variable decl T : Class
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/List
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl List
Resolving variable decl T : Class
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl iter19 : Iterator<T> = list iterator()
element = iter19 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
this add(element) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl genArg15 : T = gc_malloc(Class.size)
Resolving variable decl size : Int = this size()
Resolving variable decl element : T
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : Int = this indexOf(oldie)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal18 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal18, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg17, returnVal18, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
this lastIndex() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
	$$$$ resolving returnType T for this get(this lastIndex())
this get(this lastIndex()) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
this get(this lastIndex()) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
return (comma expr) (of type Return) wants to wholeAgain() because 'expr type is unresolved'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For last: func , response of body = LOOP
Response of fDecl last: func  = LOOP
-- ClassDecl ListClass, meta of ClassDecl List, isn't resolved, looping.
response of tDecl ClassDecl List = LOOP
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl iter19 : Iterator<T> = list iterator()
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T = gc_malloc(Class.size)
Resolving variable decl genArg15 : T = gc_malloc(Class.size)
Resolving variable decl size : Int = this size()
Resolving variable decl element : T
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : Int = this indexOf(oldie)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T = gc_malloc(Class.size)
Resolving variable decl returnVal18 : T = gc_malloc(Class.size)
Resolving variable decl genCall95 : T
genCall95 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl returnVal97 : <unknown type> = (comma expr)
returnVal97 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal97 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg96 = returnVal97 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl i : Int = 0
Resolving variable decl j : Int = this size() - 1
Resolving variable decl genCall20 : T
genCall20 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl genArg21 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(genArg21, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl genCall22 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl genArg23 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(genArg23, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl arr : T* = gc_malloc(this size() * Class.size)
Resolving variable decl i : Int
	$$$$ resolving returnType T for __OP_IDX_List_Int__T(this, i)
__OP_IDX_List_Int__T(this, i) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
arr[i * size] = __OP_IDX_List_Int__T(this, i) (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
Resolving variable decl str : String
Resolving variable decl result : Buffer = Buffer new()
Resolving variable decl first : Bool = true
Resolving variable decl item : String
this iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type Iterator<T>'
iter98 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter98 next()
iter98 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
for (item in this) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
result toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl chr : Char
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
list get(i) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For __OP_IDX_List_Int__T: func (list : List<T>, i : Int), response of body = LOOP
response of oDecl operator [](list : List<T>, i : Int) = LOOP
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/Buffer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Buffer
Resolving variable decl size : SizeT
Resolving variable decl capacity : SizeT
Resolving variable decl data : String
====== Resolving type decl ClassDecl BufferClass
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl str : String
Resolving variable decl length : SizeT = str length()
Resolving variable decl str : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
Resolving variable decl offset : Int
Resolving variable decl min : SizeT
Resolving variable decl newCapa : SizeT = min * 1.200000 + 10
Resolving variable decl tmp : Pointer = gc_realloc(Buffer.data, newCapa)
Resolving variable decl newCapa : SizeT = Buffer.size + 1
Resolving variable decl tmp : Pointer = gc_realloc(Buffer.data as Char*, newCapa)
====== Resolving type decl ClassDecl BufferClass
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl str : String
Resolving variable decl length : SizeT = str length()
Resolving variable decl str : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
Resolving variable decl offset : Int
Resolving variable decl min : SizeT
Resolving variable decl newCapa : SizeT = min * 1.200000 + 10
Resolving variable decl tmp : Pointer = gc_realloc(Buffer.data, newCapa)
Resolving variable decl newCapa : SizeT = Buffer.size + 1
Resolving variable decl tmp : Pointer = gc_realloc(Buffer.data as Char*, newCapa)
====== Resolving type decl ClassDecl BufferWriter
Resolving variable decl buffer : Buffer
====== Resolving type decl ClassDecl BufferWriterClass
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
====== Resolving type decl ClassDecl BufferWriterClass
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
====== Resolving type decl ClassDecl BufferReader
Resolving variable decl buffer : Buffer
====== Resolving type decl ClassDecl BufferReaderClass
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
BufferReader alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this __defaults__() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl c : Char = BufferReader.buffer get(BufferReader.marker)
Resolving variable decl offset : Int
Resolving variable decl marker : Long
====== Resolving type decl ClassDecl BufferReaderClass
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl c : Char = BufferReader.buffer get(BufferReader.marker)
Resolving variable decl offset : Int
Resolving variable decl marker : Long
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/Reader
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Reader
Resolving variable decl marker : Long
====== Resolving type decl ClassDecl ReaderClass
Resolving variable decl this : Reader = Reader alloc() as Reader
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl offset : Int
Resolving variable decl marker : Long
Resolving variable decl offset : Int
Resolving variable decl i : Int
====== Resolving type decl ClassDecl ReaderClass
Resolving variable decl this : Reader = Reader alloc() as Reader
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl offset : Int
Resolving variable decl marker : Long
Resolving variable decl offset : Int
Resolving variable decl i : Int
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module io/Reader finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/FileReader
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl SEEK_CUR : Int
Resolving variable decl SEEK_SET : Int
Resolving variable decl SEEK_END : Int
====== Resolving type decl ClassDecl FileReader
Resolving variable decl file : FILE*
====== Resolving type decl ClassDecl FileReaderClass
Resolving variable decl fileObject : File
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileName : String
fopen(fileName, "r") (of type FunctionCall) wants to wholeAgain() because 'because of return type FILE*'
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
fread(chars as Char* + offset, 1, count, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl value : Char
fread(value&, 1, 1, FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl sb : Buffer = Buffer new(40)
Resolving variable decl c : Char = this read()
feof(FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl offset : Int
fseek(FileReader.file, -offset, SEEK_CUR) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
ftell(FileReader.file) (of type FunctionCall) wants to wholeAgain() because 'because of return type Long'
Resolving variable decl marker : Long
fseek(FileReader.file, marker, SEEK_SET) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
====== Resolving type decl ClassDecl FileReaderClass
Resolving variable decl fileObject : File
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileName : String
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl value : Char
Resolving variable decl sb : Buffer = Buffer new(40)
Resolving variable decl c : Char = this read()
Resolving variable decl offset : Int
Resolving variable decl marker : Long
Resolving variable decl filename : Char*
Resolving variable decl mode : Char*
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl count : SizeT
Resolving variable decl stream : FILE*
Resolving variable decl stream : FILE*
Resolving variable decl stream : FILE*
Resolving variable decl offset : Long
Resolving variable decl origin : Int
Resolving variable decl stream : FILE*
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/native/FileWin32
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl FILE_ATTRIBUTE_DIRECTORY : Long
Resolving variable decl FILE_ATTRIBUTE_REPARSE_POINT : Long
Resolving variable decl FILE_ATTRIBUTE_NORMAL : Long
====== Resolving type decl CoverDecl FindData
Resolving variable decl attr : Long
Resolving variable decl fileSizeLow : Long
Resolving variable decl fileSizeHigh : Long
Resolving variable decl creationTime : FileTime
Resolving variable decl lastAccessTime : FileTime
Resolving variable decl lastWriteTime : FileTime
Resolving variable decl fileName : String
====== Resolving type decl ClassDecl FindDataClass
====== Resolving type decl ClassDecl FindDataClass
====== Resolving type decl ClassDecl FileWin32
====== Resolving type decl ClassDecl FileWin32Class
Resolving variable decl this : FileWin32 = FileWin32 alloc() as FileWin32
GetFileAttributes(FileWin32.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type Long'
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : Handle = this findFirst(ffdPtr)
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : <unknown type> = FindFirstFile(FileWin32.path, ffdPtr)
FindFirstFile(FileWin32.path, ffdPtr) (of type FunctionCall) wants to wholeAgain() because 'because of return type Handle'
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
toLLong(FindData.fileSizeLow, FindData.fileSizeHigh) (of type FunctionCall) wants to wholeAgain() because 'because of return type LLong'
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
CreateDirectory(FileWin32.path, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl ffd : FindData
toTimestamp(FindData.lastAccessTime) (of type FunctionCall) wants to wholeAgain() because 'because of return type Long'
Resolving variable decl ffd : FindData
toTimestamp(FindData.lastWriteTime) (of type FunctionCall) wants to wholeAgain() because 'because of return type Long'
Resolving variable decl ffd : FindData
toTimestamp(FindData.creationTime) (of type FunctionCall) wants to wholeAgain() because 'because of return type Long'
__OP_ADD_String_String__String(__OP_ADD_String_Char__String(this getCwd(), FileWin32Class.separator), FileWin32.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Handle'
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
result add(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl result : ArrayList<FileWin32> = ArrayList<This> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : <unknown type> = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Handle'
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
result add(File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName))) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
FindNextFile(hFile, ffd&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
====== Resolving type decl ClassDecl FileWin32Class
Resolving variable decl this : FileWin32 = FileWin32 alloc() as FileWin32
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : Handle = this findFirst(ffdPtr)
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : Handle = FindFirstFile(FileWin32.path, ffdPtr)
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : Handle = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
Resolving variable decl genArg102 : String = __OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)
Resolving variable decl result : ArrayList<FileWin32> = ArrayList<This> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : Handle = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
Resolving variable decl genArg103 : File = File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName))
Resolving variable decl String
Resolving variable decl FindData*
Resolving variable decl Handle
Resolving variable decl FindData*
Resolving variable decl Handle
Resolving variable decl String
Resolving variable decl String
Resolving variable decl Pointer
Resolving variable decl path : String
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/native/FileUnix
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl S_IRWXU : Long
Resolving variable decl S_IRWXG : Long
Resolving variable decl S_IRWXO : Long
====== Resolving type decl CoverDecl ModeT
====== Resolving type decl ClassDecl ModeTClass
====== Resolving type decl ClassDecl ModeTClass
====== Resolving type decl CoverDecl FileStat
Resolving variable decl st_mode : ModeT
Resolving variable decl st_size : SizeT
Resolving variable decl st_atime : TimeT
Resolving variable decl st_mtime : TimeT
Resolving variable decl st_ctime : TimeT
====== Resolving type decl ClassDecl FileStatClass
====== Resolving type decl ClassDecl FileStatClass
====== Resolving type decl ClassDecl FileUnix
====== Resolving type decl ClassDecl FileUnixClass
Resolving variable decl this : FileUnix = FileUnix alloc() as FileUnix
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
S_ISDIR(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
S_ISREG(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
S_ISLNK(FileStat.st_mode) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl stat : FileStat
lstat(FileUnix.path, stat&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl actualPath : String = String new(FileUnixClass.MAX_PATH_LENGTH + 1)
realpath(FileUnix.path, actualPath) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl actualPath : String = this getAbsolutePath()
__OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!")) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Resolving variable decl dir : <unknown type> = opendir(FileUnix.path)
opendir(FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type DirPtr'
__OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!")) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl entry : <unknown type> = readdir(dir)
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'because of return type DirEnt*'
DirEnt.name equals(".") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
DirEnt.name equals("..") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
DirEnt.name clone() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
result add(DirEnt.name clone()) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'because of return type DirEnt*'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
__OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Trying to get the children of the non-directory '", FileUnix.path), "'!")) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Resolving variable decl dir : <unknown type> = opendir(FileUnix.path)
opendir(FileUnix.path) (of type FunctionCall) wants to wholeAgain() because 'because of return type DirPtr'
__OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_String__String("Couldn't open directory '", FileUnix.path), "' for reading!")) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Resolving variable decl result : ArrayList<FileUnix> = ArrayList<This> new()
Resolving variable decl entry : <unknown type> = readdir(dir)
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'because of return type DirEnt*'
DirEnt.name equals(".") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
DirEnt.name equals("..") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
DirEnt.name clone() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
File new(this, DirEnt.name clone()) (of type FunctionCall) wants to wholeAgain() because 'because of return type File'
result add(File new(this, DirEnt.name clone())) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
readdir(dir) (of type FunctionCall) wants to wholeAgain() because 'because of return type DirEnt*'
closedir(dir) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl mode : Int32
_mkdir(FileUnix.path, mode) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
====== Resolving type decl ClassDecl FileUnixClass
Resolving variable decl this : FileUnix = FileUnix alloc() as FileUnix
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl actualPath : String = String new(FileUnixClass.MAX_PATH_LENGTH + 1)
Resolving variable decl actualPath : String = this getAbsolutePath()
Resolving variable decl dir : DirPtr = opendir(FileUnix.path)
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl entry : DirEnt* = readdir(dir)
Resolving variable decl genArg104 : String = DirEnt.name clone()
Resolving variable decl dir : DirPtr = opendir(FileUnix.path)
Resolving variable decl result : ArrayList<FileUnix> = ArrayList<This> new()
Resolving variable decl entry : DirEnt* = readdir(dir)
Resolving variable decl genArg105 : File = File new(this, DirEnt.name clone())
Resolving variable decl mode : Int32
Resolving variable decl path : String
Resolving variable decl resolved : String
Resolving variable decl buf : String
Resolving variable decl size : SizeT
Resolving variable decl String
Resolving variable decl FileStat*
Resolving variable decl String
Resolving variable decl ModeT
Resolving variable decl path : String
Resolving variable decl path : String
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module os/Time
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl CoverDecl SystemTime
Resolving variable decl wHour : UShort
Resolving variable decl wMinute : UShort
Resolving variable decl wSecond : UShort
Resolving variable decl wMilliseconds : UShort
====== Resolving type decl ClassDecl SystemTimeClass
====== Resolving type decl ClassDecl SystemTimeClass
====== Resolving type decl CoverDecl TimeT
====== Resolving type decl ClassDecl TimeTClass
====== Resolving type decl ClassDecl TimeTClass
====== Resolving type decl CoverDecl TimeZone
====== Resolving type decl ClassDecl TimeZoneClass
====== Resolving type decl ClassDecl TimeZoneClass
====== Resolving type decl CoverDecl TMStruct
Resolving variable decl tm_sec : Int
Resolving variable decl tm_min : Int
Resolving variable decl tm_hour : Int
Resolving variable decl tm_mday : Int
Resolving variable decl tm_mon : Int
Resolving variable decl tm_year : Int
Resolving variable decl tm_wday : Int
Resolving variable decl tm_yday : Int
Resolving variable decl tm_isdst : Int
====== Resolving type decl ClassDecl TMStructClass
====== Resolving type decl ClassDecl TMStructClass
====== Resolving type decl CoverDecl TimeVal
Resolving variable decl tv_sec : TimeT
Resolving variable decl tv_usec : Int
====== Resolving type decl ClassDecl TimeValClass
====== Resolving type decl ClassDecl TimeValClass
====== Resolving type decl ClassDecl Time
====== Resolving type decl ClassDecl TimeClass
Resolving variable decl this : Time = Time alloc() as Time
Resolving variable decl st : SystemTime
Resolving variable decl tv : TimeVal
gettimeofday(tv&, NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl st : SystemTime
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'because of return type TimeT'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'because of return type TMStruct*'
Resolving variable decl st : SystemTime
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'because of return type TimeT'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'because of return type TMStruct*'
Resolving variable decl st : SystemTime
Resolving variable decl tt : <unknown type> = time(NullLiteral)
time(NullLiteral) (of type FunctionCall) wants to wholeAgain() because 'because of return type TimeT'
Resolving variable decl val : <unknown type> = localtime(tt&)
localtime(tt&) (of type FunctionCall) wants to wholeAgain() because 'because of return type TMStruct*'
Resolving variable decl duration : Float
Resolving variable decl duration : UInt
Resolving variable decl duration : UInt
====== Resolving type decl ClassDecl TimeClass
Resolving variable decl this : Time = Time alloc() as Time
Resolving variable decl st : SystemTime
Resolving variable decl tv : TimeVal
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl duration : Float
Resolving variable decl duration : UInt
Resolving variable decl duration : UInt
Resolving variable decl SystemTime*
Resolving variable decl UInt
Resolving variable decl TimeT*
Resolving variable decl TimeT*
Resolving variable decl TimeVal*
Resolving variable decl TimeZone*
Resolving variable decl UInt
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CInputTask
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CInputTask
Resolving variable decl keyCount : Int
Resolving variable decl dX : Int
Resolving variable decl dY : Int
Resolving variable decl event : Event
Resolving variable decl listeners : LinkedList<Listener>
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
LinkedList<Listener> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedList<Listener>'
Resolving variable decl listener : <unknown type>
CInputTask.listeners iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (listener in CInputTask.listeners) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl event : Event
Resolving variable decl listener : Listener
Resolving variable decl listener : Listener
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
Resolving variable decl listener : <unknown type>
CInputTask.listeners iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (listener in CInputTask.listeners) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl event : Event
Resolving variable decl listener : Listener
Resolving variable decl listener : Listener
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/LinkedList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LinkedList
Resolving variable decl T : Class
Resolving variable decl size : Int = 0
Resolving variable decl first : Node<T>
Resolving variable decl last : Node<T>
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Node<T> new(LinkedList.last, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'because of return type Node<T>'
Node<T> new(NullLiteral, NullLiteral, data) (of type FunctionCall) wants to wholeAgain() because 'because of return type Node<T>'
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : Node<T> = this getNode(index - 1)
Resolving variable decl nextNode : Node<T> = Node<T>.next
Resolving variable decl node : <unknown type> = Node<T> new(prevNode, nextNode, data)
Node<T> new(prevNode, nextNode, data) (of type FunctionCall) wants to wholeAgain() because 'because of return type Node<T>'
this size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
index == this size() (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl node : <unknown type> = Node<T> new(NullLiteral, LinkedList.first, data)
Node<T> new(NullLiteral, LinkedList.first, data) (of type FunctionCall) wants to wholeAgain() because 'because of return type Node<T>'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() looping because not resolved!'
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl next : Node<T> = Node<T>.next
Resolving variable decl index : Int
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For get: func (index : Int), response of body = LOOP
Response of fDecl get: func (index : Int) = LOOP
-- ClassDecl LinkedListClass, meta of ClassDecl LinkedList, isn't resolved, looping.
response of tDecl ClassDecl LinkedList = LOOP
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : Node<T> = this getNode(index - 1)
Resolving variable decl nextNode : Node<T> = Node<T>.next
Resolving variable decl node : Node<T> = Node<T> new(prevNode, nextNode, data)
this size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
index == this size() (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl node : Node<T> = Node<T> new(NullLiteral, LinkedList.first, data)
__OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl next : Node<T> = Node<T>.next
Resolving variable decl index : Int
Resolving variable decl returnVal107 : <unknown type> = Node<T>.data
returnVal107 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal107 = Node<T>.data (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg106 = returnVal107 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl index : Int
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() looping because not resolved!'
Resolving variable decl i : Int = 0
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl i : Int = 0
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.last
Resolving variable decl i : Int = LinkedList.size - 1
Resolving variable decl index : Int
Resolving variable decl toRemove : Node<T> = this getNode(index)
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
Response of statement [If] if (LinkedList.first != NullLiteral && index >= 0 && index < LinkedList.size) = LOOP
))))))) For removeAt: func (index : Int), response of body = LOOP
Response of fDecl removeAt: func (index : Int) = LOOP
response of tDecl ClassDecl LinkedListClass = LOOP
====== Resolving type decl ClassDecl Node
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl prev : Node<T>
Resolving variable decl next : Node<T>
Resolving variable decl data : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
====== Resolving type decl ClassDecl LinkedListIterator
Resolving variable decl T : Class
Resolving variable decl current : Node<T>
Resolving variable decl list : LinkedList<T>
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = LinkedListIterator.current
Resolving variable decl returnVal26 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal26, Node<T>.data, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg25, returnVal26, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl returnVal28 : <unknown type> = Node<T>.data
returnVal28 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal28 = Node<T>.data (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg27 = returnVal28 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl old : <unknown type> = current
list removeNode(old) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
list removeNode(old) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
list removeNode(old) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return list removeNode(old) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = LinkedListIterator.current
Resolving variable decl returnVal26 : T = gc_malloc(Class.size)
Resolving variable decl returnVal28 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal28, Node<T>.data, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg27, returnVal28, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl old : Node<T> = current
LinkedListIterator.list removeNode(old) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
LinkedListIterator.list removeNode(old) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
LinkedListIterator.list removeNode(old) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
return LinkedListIterator.list removeNode(old) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
Resolving variable decl list : LinkedList<T>
Resolving variable decl index : Int
Resolving variable decl T : Class
Resolving variable decl genCall29 : T
genCall29 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl returnVal31 : <unknown type> = (comma expr)
returnVal31 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal31 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg30 = returnVal31 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module os/Terminal
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Attr
====== Resolving type decl ClassDecl AttrClass
Resolving variable decl reset : Int = 0
Resolving variable decl bright : Int = 1
Resolving variable decl dim : Int = 2
Resolving variable decl under : Int = 3
Resolving variable decl blink : Int = 5
Resolving variable decl reverse : Int = 7
Resolving variable decl hidden : Int = 8
Resolving variable decl this : Attr = Attr alloc() as Attr
====== Resolving type decl ClassDecl AttrClass
Resolving variable decl reset : Int = 0
Resolving variable decl bright : Int = 1
Resolving variable decl dim : Int = 2
Resolving variable decl under : Int = 3
Resolving variable decl blink : Int = 5
Resolving variable decl reverse : Int = 7
Resolving variable decl hidden : Int = 8
Resolving variable decl this : Attr = Attr alloc() as Attr
====== Resolving type decl ClassDecl Color
====== Resolving type decl ClassDecl ColorClass
Resolving variable decl black : Int = 30
Resolving variable decl red : Int = 31
Resolving variable decl green : Int = 32
Resolving variable decl yellow : Int = 33
Resolving variable decl blue : Int = 34
Resolving variable decl magenta : Int = 35
Resolving variable decl cyan : Int = 36
Resolving variable decl grey : Int = 37
Resolving variable decl white : Int = 38
Resolving variable decl this : Color = Color alloc() as Color
====== Resolving type decl ClassDecl ColorClass
Resolving variable decl black : Int = 30
Resolving variable decl red : Int = 31
Resolving variable decl green : Int = 32
Resolving variable decl yellow : Int = 33
Resolving variable decl blue : Int = 34
Resolving variable decl magenta : Int = 35
Resolving variable decl cyan : Int = 36
Resolving variable decl grey : Int = 37
Resolving variable decl white : Int = 38
Resolving variable decl this : Color = Color alloc() as Color
====== Resolving type decl ClassDecl Terminal
====== Resolving type decl ClassDecl TerminalClass
Resolving variable decl this : Terminal = Terminal alloc() as Terminal
Resolving variable decl f : Int
Resolving variable decl b : Int
Resolving variable decl c : Int
Resolving variable decl c : Int
Resolving variable decl att : Int
====== Resolving type decl ClassDecl TerminalClass
Resolving variable decl this : Terminal = Terminal alloc() as Terminal
Resolving variable decl f : Int
Resolving variable decl b : Int
Resolving variable decl c : Int
Resolving variable decl c : Int
Resolving variable decl att : Int
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module os/Terminal finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CGlobalTimer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CGlobalTimer
Resolving variable decl dT : Float
Resolving variable decl lastFrameIndex : ULong
Resolving variable decl thisFrameIndex : ULong
====== Resolving type decl ClassDecl CGlobalTimerClass
Resolving variable decl instance : CGlobalTimer = NullLiteral
Resolving variable decl this : CGlobalTimer = CGlobalTimer alloc() as CGlobalTimer
Resolving variable decl event : Event
====== Resolving type decl ClassDecl CGlobalTimerClass
Resolving variable decl instance : CGlobalTimer = NullLiteral
Resolving variable decl this : CGlobalTimer = CGlobalTimer alloc() as CGlobalTimer
Resolving variable decl event : Event
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module CGlobalTimer finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CKernel
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CKernel
Resolving variable decl taskList : LinkedList<ITask>
Resolving variable decl pausedTaskList : LinkedList<ITask>
====== Resolving type decl ClassDecl CKernelClass
Resolving variable decl instance : CKernel = NullLiteral
Resolving variable decl this : CKernel = CKernel alloc() as CKernel
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
CKernel.taskList size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.taskList size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl t : ITask
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl t : ITask
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl pos : Int = 0
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl t : ITask
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
====== Resolving type decl ClassDecl CKernelClass
Resolving variable decl instance : CKernel = NullLiteral
Resolving variable decl this : CKernel = CKernel alloc() as CKernel
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
CKernel.taskList size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.taskList size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl t : ITask
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl t : ITask
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl pos : Int = 0
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl t : ITask
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'need iterType'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module LevelEditor
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LevelEditor
Resolving variable decl NONE : Int = 0
Resolving variable decl GRAB : Int = 1
Resolving variable decl SCALE : Int = 2
Resolving variable decl ROTATE : Int = 3
Resolving variable decl ADDMODEL : Int = 4
Resolving variable decl currentModelName : Node<String>
Resolving variable decl currentModelType : CProduct
Resolving variable decl grabLock : <unknown type> = Int3 new(0, 0, 0)
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int3'
Resolving variable decl rotLock : <unknown type> = Int3 new(0, 0, 0)
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int3'
Resolving variable decl sclLock : <unknown type> = Int3 new(0, 0, 0)
Int3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int3'
Resolving variable decl camera : FFCamera
Resolving variable decl wire : Bool = false
Resolving variable decl world : World = World new()
Resolving variable decl mode : Bool = false
Resolving variable decl editMode : Int = NONE
Resolving variable decl backupPos : <unknown type> = Double3 new(0, 0, 0)
Double3 new(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
====== Resolving type decl ClassDecl LevelEditorClass
Resolving variable decl this : LevelEditor = LevelEditor alloc() as LevelEditor
Resolving variable decl name : String
CFactory get() (of type FunctionCall) wants to wholeAgain() because 'because of return type CFactory'
CFactory get() loadStatic(MESH, name) (of type FunctionCall) wants to wholeAgain() because 'because of return type CProduct'
Double3 new(5, 5, 5) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'FFCamera new(Double3 new(5, 5, 5)) looping because not resolved!'
LevelEditor.camera = FFCamera new(Double3 new(5, 5, 5)) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
LevelEditor.camera = FFCamera new(Double3 new(5, 5, 5)) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl ambientLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl genArg32 : Float = 0.200000
Resolving variable decl genArg33 : Float = 0.200000
Resolving variable decl genArg34 : Float = 0.200000
Resolving variable decl genArg35 : Float = 1.000000
Resolving variable decl diffuseLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl specularLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl position : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl event : Event
Resolving variable decl event : Event
Resolving variable decl mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y)
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y) (of type VariableDecl) wants to wholeAgain() because 'must determine type of mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y)
'
moveObject(mouse) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
moveObject(mouse) (of type FunctionCall) wants to wholeAgain() because 'moveObject(mouse) looping because not resolved!'
Resolving variable decl mouse : Double3
Resolving variable decl t : Double = (z - z) / (z - z)
Resolving variable decl Mx : Double = t * (x - x) + x
Resolving variable decl My : Double = t * (y - y) + y
Resolving variable decl Mz : Double = z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (y - y) / (y - y)
Resolving variable decl Mx : Double = t * (x - x) + x
Resolving variable decl My : Double = y
Resolving variable decl Mz : Double = t * (z - z) + z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (x - x) / (x - x)
Resolving variable decl Mx : Double = x
Resolving variable decl My : Double = t * (y - y) + y
Resolving variable decl Mz : Double = t * (z - z) + z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (z - z) / (z - z)
Resolving variable decl Mx : Double = t * (x - x) + x
Resolving variable decl My : Double = y
Resolving variable decl Mz : Double = z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (z - z) / (z - z)
Resolving variable decl Mx : Double = x
Resolving variable decl My : Double = t * (y - y) + y
Resolving variable decl Mz : Double = z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (x - x) / (x - x)
Resolving variable decl Mx : Double = x
Resolving variable decl My : Double = y
Resolving variable decl Mz : Double = t * (z - z) + z
 >> Resolving [Mx, My, Mz]
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
glPushMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glBegin(GL_LINES) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(128, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(-50, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(255, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(50, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 128, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, -50, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 255, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 50, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 0, 128) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, -50) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 0, 255) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, 50) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glEnd() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPopMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
glPushMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glTranslated(Double3.x, Double3.y, Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRotated(90, 1, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRotated(90, 0, 1, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRotated(90, 0, 0, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glBegin(GL_LINE_STRIP) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(128, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(-100, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(-10, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(255, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(128, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(10, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(100, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 128, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, -100, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, -10, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 255, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 128, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 10, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 100, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 0, 128) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, -100) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, -10) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 0, 255) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 0, 128) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, 10) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, 0, 100) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glEnd() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPopMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
glPushMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glTranslated(Double3.x, Double3.y, Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRotated(90, 1, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRotated(90, 0, 1, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glRotated(90, 0, 0, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glScaled(Double3.x, Double3.y, Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glBegin(GL_LINES) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
glColor3ub(64, 64, 64) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(-5, i, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(255, 255, 255) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, i, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(0, i, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(64, 64, 64) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(5, i, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
Resolving variable decl i : Int
i : Int (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
glColor3ub(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(i, -5, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(255, 255, 255) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(i, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(i, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(0, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glVertex3d(i, 5, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glEnd() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glEnable(GL_BLEND) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor4ub(255, 255, 255, 64) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glDisable(GL_BLEND) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glPopMatrix() (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
Resolving variable decl mousex : Int
Resolving variable decl mousey : Int
Resolving variable decl Bx : GLdouble
Resolving variable decl By : GLdouble
Resolving variable decl Bz : GLdouble
Resolving variable decl viewport : GLint[4]
Resolving variable decl mvmatrix : GLdouble[16]
Resolving variable decl projmatrix : GLdouble[16]
glGetDoublev(GL_MODELVIEW_MATRIX, mvmatrix) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glGetDoublev(GL_PROJECTION_MATRIX, projmatrix) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glGetIntegerv(GL_VIEWPORT, viewport) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
gluUnProject(mousex, viewport[3] - mousey, 0, mvmatrix, projmatrix, viewport, Bx&, By&, Bz&) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Double3 new(Bx, By, Bz) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
====== Resolving type decl ClassDecl LevelEditorClass
Resolving variable decl this : LevelEditor = LevelEditor alloc() as LevelEditor
Resolving variable decl name : String
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'FFCamera new(Double3 new(5, 5, 5)) looping because not resolved!'
LevelEditor.camera = FFCamera new(Double3 new(5, 5, 5)) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
LevelEditor.camera = FFCamera new(Double3 new(5, 5, 5)) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl ambientLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl genArg32 : Float = 0.200000
Resolving variable decl genArg33 : Float = 0.200000
Resolving variable decl genArg34 : Float = 0.200000
Resolving variable decl genArg35 : Float = 1.000000
Resolving variable decl diffuseLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl specularLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl position : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl event : Event
Resolving variable decl event : Event
Resolving variable decl mouse : <unknown type> = this getMouseVector(Motion.x, Motion.y)
this getMouseVector(Motion.x, Motion.y) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
this moveObject(mouse) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl mouse : Double3
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.y - Double3.y) / (Double3.y - Double3.y)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl i : Int
Resolving variable decl i : Int
Resolving variable decl mousex : Int
Resolving variable decl mousey : Int
Resolving variable decl Bx : GLdouble
Resolving variable decl By : GLdouble
Resolving variable decl Bz : GLdouble
Resolving variable decl viewport : GLint[4]
Resolving variable decl mvmatrix : GLdouble[16]
Resolving variable decl projmatrix : GLdouble[16]
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CFactory
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CFactory
Resolving variable decl meshes : <unknown type> = HashMap<StaticMesh> new()
HashMap<StaticMesh> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type HashMap<StaticMesh>'
Resolving variable decl names : LinkedList<String> = LinkedList<String> new()
Resolving variable decl id : Int = 0
====== Resolving type decl ClassDecl CFactoryClass
Resolving variable decl instance : CFactory = NullLiteral
Resolving variable decl this : CFactory = CFactory alloc() as CFactory
Resolving variable decl productType : Int
Resolving variable decl filename : String
CFactory.meshes clear() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl CFactoryClass
Resolving variable decl instance : CFactory = NullLiteral
Resolving variable decl this : CFactory = CFactory alloc() as CFactory
Resolving variable decl productType : Int
Resolving variable decl filename : String
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CProduct
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl MESH : Int = 0
Resolving variable decl TEXTURE : Int = 1
====== Resolving type decl ClassDecl CProduct
Resolving variable decl filename : String
Resolving variable decl id : Int
====== Resolving type decl ClassDecl CProductClass
Resolving variable decl this : CProduct = CProduct alloc() as CProduct
====== Resolving type decl ClassDecl CProductClass
Resolving variable decl this : CProduct = CProduct alloc() as CProduct
====== Resolving type decl ClassDecl StaticMesh
Resolving variable decl vertices : ArrayList<Float3>
Resolving variable decl normals : ArrayList<Float3>
Resolving variable decl faces : ArrayList<FaceNoTex>
Resolving variable decl dlist : GLuint = 0
====== Resolving type decl ClassDecl StaticMeshClass
Resolving variable decl this : StaticMesh = StaticMesh alloc() as StaticMesh
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl nVertices : Int = 0
Resolving variable decl nNormals : Int = 0
Resolving variable decl nFaces : Int = 0
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(ArrayList<Float3>.data, 0, Float3Class.size * nVertices) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
source read(ArrayList<FaceNoTex>.data, 0, VFaceClass.size * nFaces) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl i : Int
Resolving variable decl genCall36 : FaceNoTex
Resolving variable decl genCall37 : FaceNoTex
Resolving variable decl genCall38 : FaceNoTex
Resolving variable decl genCall39 : Float3
Resolving variable decl genCall40 : Float3
Resolving variable decl genCall41 : Float3
Resolving variable decl genCall42 : FaceNoTex
Resolving variable decl genCall43 : FaceNoTex
Resolving variable decl genCall44 : FaceNoTex
Resolving variable decl genCall45 : Float3
Resolving variable decl genCall46 : Float3
Resolving variable decl genCall47 : Float3
Resolving variable decl genCall48 : FaceNoTex
Resolving variable decl genCall49 : FaceNoTex
Resolving variable decl genCall50 : FaceNoTex
Resolving variable decl genCall51 : Float3
Resolving variable decl genCall52 : Float3
Resolving variable decl genCall53 : Float3
Resolving variable decl genCall54 : FaceNoTex
Resolving variable decl genCall55 : FaceNoTex
Resolving variable decl genCall56 : FaceNoTex
Resolving variable decl genCall57 : Float3
Resolving variable decl genCall58 : Float3
Resolving variable decl genCall59 : Float3
Resolving variable decl genCall60 : FaceNoTex
Resolving variable decl genCall61 : FaceNoTex
Resolving variable decl genCall62 : FaceNoTex
Resolving variable decl genCall63 : Float3
Resolving variable decl genCall64 : Float3
Resolving variable decl genCall65 : Float3
Resolving variable decl genCall66 : FaceNoTex
Resolving variable decl genCall67 : FaceNoTex
Resolving variable decl genCall68 : FaceNoTex
Resolving variable decl genCall69 : Float3
Resolving variable decl genCall70 : Float3
Resolving variable decl genCall71 : Float3
====== Resolving type decl ClassDecl StaticMeshClass
Resolving variable decl this : StaticMesh = StaticMesh alloc() as StaticMesh
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl nVertices : Int = 0
Resolving variable decl nNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl i : Int
Resolving variable decl genCall36 : FaceNoTex
Resolving variable decl genCall37 : FaceNoTex
Resolving variable decl genCall38 : FaceNoTex
Resolving variable decl genCall39 : Float3
Resolving variable decl genCall40 : Float3
Resolving variable decl genCall41 : Float3
Resolving variable decl genCall42 : FaceNoTex
Resolving variable decl genCall43 : FaceNoTex
Resolving variable decl genCall44 : FaceNoTex
Resolving variable decl genCall45 : Float3
Resolving variable decl genCall46 : Float3
Resolving variable decl genCall47 : Float3
Resolving variable decl genCall48 : FaceNoTex
Resolving variable decl genCall49 : FaceNoTex
Resolving variable decl genCall50 : FaceNoTex
Resolving variable decl genCall51 : Float3
Resolving variable decl genCall52 : Float3
Resolving variable decl genCall53 : Float3
Resolving variable decl genCall54 : FaceNoTex
Resolving variable decl genCall55 : FaceNoTex
Resolving variable decl genCall56 : FaceNoTex
Resolving variable decl genCall57 : Float3
Resolving variable decl genCall58 : Float3
Resolving variable decl genCall59 : Float3
Resolving variable decl genCall60 : FaceNoTex
Resolving variable decl genCall61 : FaceNoTex
Resolving variable decl genCall62 : FaceNoTex
Resolving variable decl genCall63 : Float3
Resolving variable decl genCall64 : Float3
Resolving variable decl genCall65 : Float3
Resolving variable decl genCall66 : FaceNoTex
Resolving variable decl genCall67 : FaceNoTex
Resolving variable decl genCall68 : FaceNoTex
Resolving variable decl genCall69 : Float3
Resolving variable decl genCall70 : Float3
Resolving variable decl genCall71 : Float3
====== Resolving type decl ClassDecl StaticTexture
====== Resolving type decl ClassDecl StaticTextureClass
Resolving variable decl this : StaticTexture = StaticTexture alloc() as StaticTexture
====== Resolving type decl ClassDecl StaticTextureClass
Resolving variable decl this : StaticTexture = StaticTexture alloc() as StaticTexture
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl PI : Float = 3.140000
====== Resolving type decl ClassDecl Double2
Resolving variable decl x : Double
Resolving variable decl y : Double
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double3
Resolving variable decl x : Double
Resolving variable decl y : Double
Resolving variable decl z : Double
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : Double = this length()
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|") + Double3.y (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) (who is null? true, false, false, false)'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" + Double3.z (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" + Double3.z (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" (who is null? true, false, false, false)'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" + Double3.z + ")" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" + Double3.z + ")" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" + Double3.z (who is null? true, false, false, false)'
return __OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" + Double3.z + ")" (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : Double = this length()
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y) + "|" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") + Double3.z (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") + Double3.z (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") (who is null? true, false, false, false)'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") + Double3.z + ")" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") + Double3.z + ")" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") + Double3.z (who is null? true, false, false, false)'
return __OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") + Double3.z + ")" (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl CoverDecl Float2
Resolving variable decl x : Float
Resolving variable decl y : Float
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl CoverDecl Float3
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl CoverDecl Float4
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl CoverDecl Octet3
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl CoverDecl Octet4
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl CoverDecl Int3
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl CoverDecl Int2
Resolving variable decl x : Int
Resolving variable decl y : Int
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl CoverDecl VFace
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl CoverDecl Face
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl CoverDecl FaceNoTex
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceNoTexClass
====== Resolving type decl ClassDecl FaceNoTexClass
Resolving variable decl v1 : Double3
Resolving variable decl n : Double
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl vals : Double*
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl d : Float
Resolving variable decl i3 : Int3
Resolving variable decl vals : Int*
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/HashMap
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl HashEntry
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl key : String
Resolving variable decl value : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
====== Resolving type decl ClassDecl HashMap
Resolving variable decl T : Class
Resolving variable decl size : UInt
Resolving variable decl capacity : UInt
Resolving variable decl buckets : ArrayList<T>*
Resolving variable decl keys : ArrayList<String>
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl iter : <unknown type> = HashMap.buckets[hash] iterator()
HashMap.buckets[hash] iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type Iterator<T>'
iter hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter next()
iter next() (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
entry = iter next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl v1 : Int = HashMap.capacity / 0.700000
Resolving variable decl v2 : Int = HashMap.capacity * 2
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal73, HashEntry<T>.value, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg72, returnVal73, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl returnVal74 : <unknown type> = NullLiteral
returnArg72 = returnVal74 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
keys isEmpty() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl key : String
this getEntry(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type HashEntry<T>'
Resolving variable decl key : String
Resolving variable decl entry : <unknown type> = getEntry(key)
this getEntry(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type HashEntry<T>'
Resolving variable decl hash : UInt = ac_X31_hash(key) % capacity
this ac_X31_hash(key) (of type FunctionCall) wants to wholeAgain() because 'because of return type UInt'
Resolving variable decl i : UInt
i : UInt (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
keys size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl cKey : <unknown type> = keys get(i)
	$$$$ resolving returnType T for keys get(i)
keys get(i) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
cKey = HashMap.keys get(i) (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
key equals(cKey) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for keys removeAt(i)
keys removeAt(i) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
buckets[hash] remove(entry) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl _capacity : UInt
Resolving variable decl old_capacity : <unknown type> = capacity
Resolving variable decl old_buckets : <unknown type> = gc_malloc(old_capacity * size) as ArrayList<T>*
gc_malloc(old_capacity * PointerClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Exception new(This, "Out of memory: failed to allocate %d bytes\n" + (old_capacity * PointerClass.size)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Out of memory: failed to allocate %d bytes\n" + (old_capacity * PointerClass.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl i : UInt
i : UInt (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
buckets[i] clone() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<T>'
keys clear() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
gc_malloc(capacity * PointerClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Exception new(This, "Out of memory: failed to allocate %d bytes\n" + (capacity * PointerClass.size)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, "Out of memory: failed to allocate %d bytes\n" + (capacity * PointerClass.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl i : UInt
i : UInt (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
ArrayList<T> new() (of type FunctionCall) wants to wholeAgain() because 'because of return type ArrayList<T>'
Resolving variable decl entry : HashEntry<T>
Resolving variable decl bucket : UInt
bucket : UInt (of type VariableDecl) wants to wholeAgain() because 'parent isn't scope nor typedecl, unwrapped'
old_buckets[bucket] size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl iter : <unknown type> = old_buckets[bucket] iterator()
old_buckets[bucket] iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type Iterator<T>'
iter hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter next()
iter next() (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
entry = iter next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
this put(HashEntry<T>.key, HashEntry<T>.value) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
HashMapValueIterator<T> new(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type HashMapValueIterator<T>'
this init(capacity) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl iter : Iterator<T> = HashMap.buckets[hash] iterator()
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl v1 : Int = HashMap.capacity / 0.700000
Resolving variable decl v2 : Int = HashMap.capacity * 2
this resize(v1 > v2 ? v1 : v2) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : T = gc_malloc(Class.size)
Resolving variable decl returnVal74 : Pointer = NullLiteral
memcpy(returnArg72, returnVal74&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl key : String
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl hash : UInt = this ac_X31_hash(key) % capacity
Resolving variable decl i : UInt
Resolving variable decl cKey : String
Resolving variable decl _capacity : UInt
Resolving variable decl old_capacity : UInt = capacity
Resolving variable decl old_buckets : ArrayList<T>* = gc_malloc(old_capacity * PointerClass.size) as ArrayList<T>*
Resolving variable decl i : UInt
Resolving variable decl i : UInt
Resolving variable decl entry : HashEntry<T>
Resolving variable decl bucket : UInt
Resolving variable decl iter : Iterator<T> = old_buckets[bucket] iterator()
====== Resolving type decl ClassDecl HashMapValueIterator
Resolving variable decl T : Class
Resolving variable decl map : HashMap<T>
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
HashMap<T>.keys size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl key : String
Resolving variable decl genCall75 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal77 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal77, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg76, returnVal77, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl key : String
Resolving variable decl genCall78 : T
genCall78 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl returnVal80 : <unknown type> = (comma expr)
returnVal80 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal80 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg79 = returnVal80 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl result : <unknown type> = map remove(keys get(index))
	$$$$ resolving returnType T for HashMap<T>.keys get(index)
HashMap<T>.keys get(index) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
HashMap<T>.keys get(index) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
map remove((comma expr)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl result : Bool = map remove((comma expr))
HashMap<T>.keys size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
Resolving variable decl key : String
Resolving variable decl genCall75 : T = gc_malloc(Class.size)
Resolving variable decl returnVal77 : T = gc_malloc(Class.size)
Resolving variable decl key : String
Resolving variable decl genCall78 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal80 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal80, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg79, returnVal80, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl genCall110 : String
Resolving variable decl result : Bool = HashMapValueIterator.map remove((comma expr))
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl T : Class
map get(key) (of type FunctionCall) wants to wholeAgain() because 'just unwrapped'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For __OP_IDX_HashMap_String__T: func (map : HashMap<T>, key : String), response of body = LOOP
response of oDecl operator [](map : HashMap<T>, key : String) = LOOP
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl T : Class
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module FFCamera
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl FFCamera
Resolving variable decl speed : Double
Resolving variable decl sensivity : Double
Resolving variable decl phi : Double
Resolving variable decl theta : Double
Resolving variable decl forward : Double3 = Double3 new(0, 0, 0)
Resolving variable decl left : Double3 = Double3 new(0, 0, 0)
Resolving variable decl kforward : Bool = false
Resolving variable decl kbackward : Bool = false
Resolving variable decl kstrafe_left : Bool = false
Resolving variable decl kstrafe_right : Bool = false
Resolving variable decl keyconf : HashMap<Int> = HashMap<Int> new()
Resolving variable decl keystates : HashMap<Bool> = HashMap<Bool> new()
Resolving variable decl enabled : Bool = true
====== Resolving type decl ClassDecl FFCameraClass
Resolving variable decl this : FFCamera = FFCamera alloc() as FFCamera
FFCamera alloc() (of type FunctionCall) wants to wholeAgain() because 'because of return type Object'
this init(position) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl genArg81 : Bool = false
Resolving variable decl genArg82 : Bool = false
Resolving variable decl genArg83 : Bool = false
Resolving variable decl genArg84 : Bool = false
Resolving variable decl genArg85 : Bool = false
Resolving variable decl e : Motion
gluLookAt(Double3.x, Double3.y, Double3.z, Double3.x, Double3.y, Double3.z, 0, 0, 1) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl event : Event
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl up : Double3 = Double3 new(0, 0, 1)
Resolving variable decl rTemp : Double = cos(FFCamera.phi / 180.000000)
FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
FFCamera.target = __OP_ADD_Double3_Double3__Double3(FFCamera.position, FFCamera.forward) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.target = __OP_ADD_Double3_Double3__Double3(FFCamera.position, FFCamera.forward) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
FFCamera.position = __OP_ADD_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed)) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = __OP_ADD_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed)) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
FFCamera.position = __OP_SUB_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed)) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = __OP_SUB_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed)) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
FFCamera.position + __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
FFCamera.position = __OP_ADD_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed)) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = __OP_ADD_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed)) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
FFCamera.position - __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed) (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
FFCamera.position = __OP_SUB_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed)) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.position = __OP_SUB_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed)) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
FFCamera.position + FFCamera.forward (of type BinaryOp) wants to wholeAgain() because 'Illegal use, looping in hope.'
FFCamera.target = __OP_ADD_Double3_Double3__Double3(FFCamera.position, FFCamera.forward) (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FFCamera.target = __OP_ADD_Double3_Double3__Double3(FFCamera.position, FFCamera.forward) (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
====== Resolving type decl ClassDecl FFCameraClass
Resolving variable decl this : FFCamera = FFCamera alloc() as FFCamera
Resolving variable decl genArg81 : Bool = false
Resolving variable decl genArg82 : Bool = false
Resolving variable decl genArg83 : Bool = false
Resolving variable decl genArg84 : Bool = false
Resolving variable decl genArg85 : Bool = false
Resolving variable decl e : Motion
Resolving variable decl event : Event
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl up : Double3 = Double3 new(0, 0, 1)
Resolving variable decl rTemp : Double = cos(FFCamera.phi / 180.000000)
__OP_ADD_Double3_Double3__Double3(FFCamera.position, FFCamera.forward) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
__OP_ADD_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
__OP_SUB_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.forward, FFCamera.speed)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
__OP_ADD_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
__OP_SUB_Double3_Double3__Double3(FFCamera.position, __OP_MUL_Double3_Double__Double3(FFCamera.left, FFCamera.speed)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
__OP_ADD_Double3_Double3__Double3(FFCamera.position, FFCamera.forward) (of type FunctionCall) wants to wholeAgain() because 'because of return type Double3'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module Camera
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Camera
Resolving variable decl target : Double3 = Double3 new(0, 0, 0)
Resolving variable decl position : Double3 = Double3 new(1, 1, 1)
Resolving variable decl rotation : Double3 = Double3 new(0, 0, 0)
Resolving variable decl scale : Double3 = Double3 new(1, 1, 1)
====== Resolving type decl ClassDecl CameraClass
Resolving variable decl this : Camera = Camera alloc() as Camera
Resolving variable decl event : Event
====== Resolving type decl ClassDecl CameraClass
Resolving variable decl this : Camera = Camera alloc() as Camera
Resolving variable decl event : Event
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module Camera finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module Movable
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Movable
Resolving variable decl position : Double3
Resolving variable decl rotation : Double3
Resolving variable decl scale : Double3
====== Resolving type decl ClassDecl MovableClass
Resolving variable decl this : Movable = Movable alloc() as Movable
====== Resolving type decl ClassDecl MovableClass
Resolving variable decl this : Movable = Movable alloc() as Movable
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module Movable finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module World
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl World
Resolving variable decl objects : LinkedList<GameObject> = LinkedList<GameObject> new()
Resolving variable decl id : Int = 0
Resolving variable decl pickedID : Int = -1
Resolving variable decl picked : GameObject = NullLiteral
====== Resolving type decl ClassDecl WorldClass
Resolving variable decl this : World = World alloc() as World
Resolving variable decl mode : GLenum
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl cam : Camera
Resolving variable decl BUFSIZE : Int = 512
Resolving variable decl selectBuf : GLuint[BUFSIZE]
Resolving variable decl hits : GLint
Resolving variable decl viewport : GLint[4]
Resolving variable decl minz : Int = 2147483647
Resolving variable decl minid : Int = -1
Resolving variable decl i : Int
Resolving variable decl hits : GLint
Resolving variable decl names : GLuint*
Resolving variable decl jayjay : Int = 2147483647
Resolving variable decl i : Int
Resolving variable decl object : GameObject
Resolving variable decl filename : String
Resolving variable decl target : FileWriter = FileWriter new(filename)
HashMap<StaticMesh>.size toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
target write(HashMap<StaticMesh>.size toString()) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl mesh : <unknown type>
CFactory.meshes iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type Iterator<StaticMesh>'
iter114 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter114 next()
iter114 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type StaticMesh'
for (mesh in CFactory.meshes) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl filename : String
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl fileMeshes : HashMap<String> = HashMap<String> new()
Resolving variable decl line : <unknown type> = readLine(source)
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl nMeshes : Int = 0
sscanf(line, "%d", nMeshes&) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
sscanf(line, "%d", nMeshes&) (of type FunctionCall) wants to wholeAgain() because 'sscanf(line, "%d", nMeshes&) looping because not resolved!'
Resolving variable decl i : Int
Resolving variable decl line : <unknown type> = readLine(source)
readLine(source) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Resolving variable decl id : Int
Resolving variable decl filename : String = String new(1024)
sscanf(line, "%d %s", id&, filename) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl nObjects : Int
Resolving variable decl i : Int
Resolving variable decl id : Int
Resolving variable decl px : Double
Resolving variable decl py : Double
Resolving variable decl pz : Double
Resolving variable decl rx : Double
Resolving variable decl ry : Double
Resolving variable decl rz : Double
Resolving variable decl sx : Double
Resolving variable decl sy : Double
Resolving variable decl sz : Double
Resolving variable decl pos : Double3 = Double3 new(px, py, pz)
Resolving variable decl rot : Double3 = Double3 new(rx, ry, rz)
Resolving variable decl scl : Double3 = Double3 new(sx, sy, sz)
Resolving variable decl genCall86 : String
====== Resolving type decl ClassDecl WorldClass
Resolving variable decl this : World = World alloc() as World
Resolving variable decl mode : GLenum
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl cam : Camera
Resolving variable decl BUFSIZE : Int = 512
Resolving variable decl selectBuf : GLuint[BUFSIZE]
Resolving variable decl hits : GLint
Resolving variable decl viewport : GLint[4]
Resolving variable decl minz : Int = 2147483647
Resolving variable decl minid : Int = -1
Resolving variable decl i : Int
Resolving variable decl hits : GLint
Resolving variable decl names : GLuint*
Resolving variable decl jayjay : Int = 2147483647
Resolving variable decl i : Int
Resolving variable decl object : GameObject
Resolving variable decl filename : String
Resolving variable decl target : FileWriter = FileWriter new(filename)
Resolving variable decl mesh : StaticMesh
Resolving variable decl iter114 : Iterator<StaticMesh> = CFactory.meshes iterator()
mesh = iter114 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
StaticMesh.id toString() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
target write(StaticMesh.id toString()) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(" ") (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
StaticMesh.filename + "\n" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
target write(__OP_ADD_String_String__String(StaticMesh.filename, "\n")) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
target write(__OP_ADD_String_String__String(StaticMesh.filename, "\n")) (of type FunctionCall) wants to wholeAgain() because 'target write(__OP_ADD_String_String__String(StaticMesh.filename, "\n")) looping because not resolved!'
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl filename : String
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl fileMeshes : HashMap<String> = HashMap<String> new()
Resolving variable decl line : String = readLine(source)
Resolving variable decl nMeshes : Int = 0
sscanf(line, "%d", nMeshes&) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl i : Int
Resolving variable decl line : String = readLine(source)
Resolving variable decl id : Int
Resolving variable decl filename : String = String new(1024)
Resolving variable decl nObjects : Int
Resolving variable decl i : Int
Resolving variable decl id : Int
Resolving variable decl px : Double
Resolving variable decl py : Double
Resolving variable decl pz : Double
Resolving variable decl rx : Double
Resolving variable decl ry : Double
Resolving variable decl rz : Double
Resolving variable decl sx : Double
Resolving variable decl sy : Double
Resolving variable decl sz : Double
Resolving variable decl pos : Double3 = Double3 new(px, py, pz)
Resolving variable decl rot : Double3 = Double3 new(rx, ry, rz)
Resolving variable decl scl : Double3 = Double3 new(sx, sy, sz)
Resolving variable decl genCall86 : String
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module GameObject
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl BOX : Int = 0
Resolving variable decl PLANE : Int = 1
Resolving variable decl SPHERE : Int = 2
====== Resolving type decl ClassDecl GameObject
Resolving variable decl model : CProduct = NullLiteral
Resolving variable decl bounds : Int = BOX
Resolving variable decl boundScale : Double3 = Double3 new(1, 1, 1)
Resolving variable decl renderBounds : Bool = false
Resolving variable decl id : Int
====== Resolving type decl ClassDecl GameObjectClass
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scale : Double3
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scale : Double3
Resolving variable decl name : String
====== Resolving type decl ClassDecl GameObjectClass
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scale : Double3
Resolving variable decl this : GameObject = GameObject alloc() as GameObject
Resolving variable decl name : String
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scale : Double3
Resolving variable decl name : String
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module GameObject finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/text
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl filereader : FileReader
Resolving variable decl line : String = String new(254)
Resolving variable decl nbytes : Int = 254
Resolving variable decl nchars : Int = 0
Resolving variable decl line : String
Resolving variable decl buffer : String = String new(8)
Resolving variable decl i : Int = 0
Resolving variable decl n : Int = 0
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module utils/text finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
__OP_EQ_String_String__Bool(ftoken, "v") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
__OP_EQ_String_String__Bool(ftoken, "f") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
__OP_EQ_String_String__Bool(ftoken, "vt") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
__OP_EQ_String_String__Bool(ftoken, "vn") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
__OP_EQ_String_String__Bool(ftoken, "#") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : <unknown type> = tok nextToken()
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
ftoken == "v" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "f" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_EQ_String_String__Bool(ftoken, "f") && nTexCoordinates > 0 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_EQ_String_String__Bool(ftoken, "f") (who is null? true, false, false, false)'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "f" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_EQ_String_String__Bool(ftoken, "f") && nTexCoordinates == 0 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_EQ_String_String__Bool(ftoken, "f") (who is null? true, false, false, false)'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "vt" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "vn" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
ftoken == "#" (of type Comparison) wants to wholeAgain() because 'Just replaced with an operator overloading'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
__OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n1]) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n2]) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_ADD_Float3_Float3__Float3(normal, normals[FaceNoTex.n3]) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
__OP_DIV_Float3_Float__Float3(normal, meanCount) (of type FunctionCall) wants to wholeAgain() because 'because of return type Float3'
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type StringTokenizerIterator<T>'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : <unknown type> = StringTokenizerIterator.st nextToken()
returnArg87 = returnVal88 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For prev: func , response of body = LOOP
Response of fDecl prev: func  = LOOP
-- ClassDecl StringTokenizerIteratorClass, meta of ClassDecl StringTokenizerIterator, isn't resolved, looping.
response of tDecl ClassDecl StringTokenizerIterator = LOOP
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
memcpy(returnArg87, returnVal88&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl returnVal116 : <unknown type> = NullLiteral
returnArg115 = returnVal116 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = LOOP (wholeAgain = true)

=======================================

Tinkerer, round 3, 27 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module main
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module main finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CApplication
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CApplication
Resolving variable decl videoTask : CVideoUpdate
Resolving variable decl globalTimer : CGlobalTimer
Resolving variable decl inputTask : CInputTask
====== Resolving type decl ClassDecl CApplicationClass
Resolving variable decl instance : CApplication = NullLiteral
Resolving variable decl this : CApplication = CApplication alloc() as CApplication
Resolving variable decl test : LevelEditor = LevelEditor new()
Resolving variable decl kernel : CKernel = CKernel get()
====== Resolving type decl ClassDecl CApplicationClass
Resolving variable decl instance : CApplication = NullLiteral
Resolving variable decl this : CApplication = CApplication alloc() as CApplication
Resolving variable decl test : LevelEditor = LevelEditor new()
Resolving variable decl kernel : CKernel = CKernel get()
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module CApplication finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CVideoUpdate
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CVideoUpdate
Resolving variable decl scrWidth : Int
Resolving variable decl scrHeight : Int
Resolving variable decl scrBPP : Int
Resolving variable decl surface : Surface*
====== Resolving type decl ClassDecl CVideoUpdateClass
Resolving variable decl instance : CVideoUpdate = NullLiteral
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
Resolving variable decl flags : Int = SDL_OPENGL | SDL_ANYFORMAT
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
====== Resolving type decl ClassDecl CVideoUpdateClass
Resolving variable decl instance : CVideoUpdate = NullLiteral
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
Resolving variable decl this : CVideoUpdate = CVideoUpdate alloc() as CVideoUpdate
Resolving variable decl flags : Int = SDL_OPENGL | SDL_ANYFORMAT
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module CVideoUpdate finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/stdio
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl stdout : FStream
Resolving variable decl stderr : FStream
Resolving variable decl stdin : FStream
====== Resolving type decl CoverDecl FILE
====== Resolving type decl ClassDecl FILEClass
====== Resolving type decl ClassDecl FILEClass
====== Resolving type decl CoverDecl FStream
====== Resolving type decl ClassDecl FStreamClass
Resolving variable decl c : Char
Resolving variable decl chunk : Int = 128
Resolving variable decl length : Int = chunk
Resolving variable decl pos : Int = 0
Resolving variable decl str : String = gc_malloc(length) as String
Resolving variable decl tmp : String = gc_realloc(str, length) as String
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl str : Char*
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
====== Resolving type decl ClassDecl FStreamClass
Resolving variable decl c : Char
Resolving variable decl chunk : Int = 128
Resolving variable decl length : Int = chunk
Resolving variable decl pos : Int = 0
Resolving variable decl str : String = gc_malloc(length) as String
Resolving variable decl tmp : String = gc_realloc(str, length) as String
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl str : Char*
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
Resolving variable decl str : String
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl String
Resolving variable decl String
Resolving variable decl String
Resolving variable decl Int
Resolving variable decl String
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl String
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl String
Resolving variable decl Int
Resolving variable decl String
Resolving variable decl VaList
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl nmemb : SizeT
Resolving variable decl stream : FStream
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl nmemb : SizeT
Resolving variable decl stream : FStream
Resolving variable decl stream : FStream
Resolving variable decl String
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl stream : FStream
Resolving variable decl Char
Resolving variable decl FStream
Resolving variable decl String
Resolving variable decl FStream
Resolving variable decl format : String
Resolving variable decl stream : FStream
Resolving variable decl format : String
Resolving variable decl str : String
Resolving variable decl format : String
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl stream : FStream
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl str : String
Resolving variable decl format : String
Resolving variable decl ap : VaList
Resolving variable decl str : String
Resolving variable decl length : SizeT
Resolving variable decl stream : FStream
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module lang/stdio finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module lang/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Object
Resolving variable decl class : Class
====== Resolving type decl ClassDecl ObjectClass
Resolving variable decl T : Class
====== Resolving type decl ClassDecl ObjectClass
Resolving variable decl T : Class
====== Resolving type decl ClassDecl Class
Resolving variable decl instanceSize : SizeT
Resolving variable decl size : SizeT
Resolving variable decl name : String
Resolving variable decl super : Class
====== Resolving type decl ClassDecl ClassClass
Resolving variable decl object : Object = gc_malloc(Class.instanceSize) as Object
Resolving variable decl T : Class
====== Resolving type decl ClassDecl ClassClass
Resolving variable decl object : Object = gc_malloc(Class.instanceSize) as Object
Resolving variable decl T : Class
====== Resolving type decl ClassDecl None
====== Resolving type decl ClassDecl NoneClass
Resolving variable decl this : None = None alloc() as None
====== Resolving type decl ClassDecl NoneClass
Resolving variable decl this : None = None alloc() as None
====== Resolving type decl CoverDecl Void
====== Resolving type decl ClassDecl VoidClass
====== Resolving type decl ClassDecl VoidClass
====== Resolving type decl CoverDecl Pointer
====== Resolving type decl ClassDecl PointerClass
====== Resolving type decl ClassDecl PointerClass
====== Resolving type decl CoverDecl Char
====== Resolving type decl ClassDecl CharClass
====== Resolving type decl ClassDecl CharClass
====== Resolving type decl CoverDecl SChar
====== Resolving type decl ClassDecl SCharClass
====== Resolving type decl ClassDecl SCharClass
====== Resolving type decl CoverDecl UChar
====== Resolving type decl ClassDecl UCharClass
====== Resolving type decl ClassDecl UCharClass
====== Resolving type decl CoverDecl WChar
====== Resolving type decl ClassDecl WCharClass
====== Resolving type decl ClassDecl WCharClass
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl length : SizeT
Resolving variable decl result : String = gc_malloc(length + 1) as String
Resolving variable decl c : Char
Resolving variable decl result : String = This new(1)
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl length : SizeT
Resolving variable decl i : SizeT
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl other : String
Resolving variable decl other : String
Resolving variable decl i : SizeT
Resolving variable decl s : String
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl l1 : SizeT = this length()
Resolving variable decl l2 : SizeT = s length()
Resolving variable decl offset : SizeT = (l1 - l2)
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl i : Int
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl slength : SizeT = s length()
Resolving variable decl i : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
Resolving variable decl s : String
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
Resolving variable decl c : Char
Resolving variable decl i : SizeT = this length()
Resolving variable decl start : SizeT
Resolving variable decl len : SizeT = this length()
Resolving variable decl diff : SizeT = (len - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl start : SizeT
Resolving variable decl end : SizeT
Resolving variable decl len : SizeT = this length()
Resolving variable decl diff : SizeT = (end - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl len : SizeT = this length()
Resolving variable decl result : String = This new(len + 1)
Resolving variable decl i : SizeT
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : String = This new(length)
Resolving variable decl count : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl result : Char* = This new(length * count) as Char*
Resolving variable decl i : Int
Resolving variable decl other : String
Resolving variable decl length : SizeT = this length()
Resolving variable decl rlength : SizeT = other length()
Resolving variable decl copy : Char* = This new(length + rlength) as Char*
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl other : String
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl index : SizeT
Resolving variable decl list : VaList
Resolving variable decl length : Int = vsnprintf(NullLiteral, 0, this, list)
Resolving variable decl output : String = This new(length)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl length : SizeT
Resolving variable decl result : String = gc_malloc(length + 1) as String
Resolving variable decl c : Char
Resolving variable decl result : String = This new(1)
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl length : SizeT
Resolving variable decl i : SizeT
Resolving variable decl other : String
Resolving variable decl start : SizeT
Resolving variable decl other : String
Resolving variable decl other : String
Resolving variable decl i : SizeT
Resolving variable decl s : String
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl l1 : SizeT = this length()
Resolving variable decl l2 : SizeT = s length()
Resolving variable decl offset : SizeT = (l1 - l2)
Resolving variable decl i : SizeT
Resolving variable decl c : Char
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl i : Int
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl start : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl slength : SizeT = s length()
Resolving variable decl i : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
Resolving variable decl s : String
Resolving variable decl start : Int = 0
Resolving variable decl end : SizeT = this length()
Resolving variable decl c : Char
Resolving variable decl i : SizeT = this length()
Resolving variable decl start : SizeT
Resolving variable decl len : SizeT = this length()
Resolving variable decl diff : SizeT = (len - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl start : SizeT
Resolving variable decl end : SizeT
Resolving variable decl len : SizeT = this length()
Resolving variable decl diff : SizeT = (end - start)
Resolving variable decl sub : String = This new(diff)
Resolving variable decl len : SizeT = this length()
Resolving variable decl result : String = This new(len + 1)
Resolving variable decl i : SizeT
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : String = This new(length)
Resolving variable decl count : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl result : Char* = This new(length * count) as Char*
Resolving variable decl i : Int
Resolving variable decl other : String
Resolving variable decl length : SizeT = this length()
Resolving variable decl rlength : SizeT = other length()
Resolving variable decl copy : Char* = This new(length + rlength) as Char*
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl other : String
Resolving variable decl other : Char
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length + 1) as Char*
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl length : SizeT = this length()
Resolving variable decl copy : Char* = This new(length) as Char*
Resolving variable decl i : Int
Resolving variable decl index : SizeT
Resolving variable decl list : VaList
Resolving variable decl length : Int = vsnprintf(NullLiteral, 0, this, list)
Resolving variable decl output : String = This new(length)
====== Resolving type decl InterfaceDecl Comparable
====== Resolving type decl ClassDecl ComparableClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl Comparable__reference
Resolving variable decl impl : ComparableClass
Resolving variable decl obj : Object
====== Resolving type decl ClassDecl Comparable__referenceClass
====== Resolving type decl ClassDecl ComparableClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl LLong
====== Resolving type decl ClassDecl LLongClass
Resolving variable decl range : Range
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl InterfaceImpl LLong__impl__Comparable
====== Resolving type decl ClassDecl LLong__impl__ComparableClass
====== Resolving type decl ClassDecl LLong__impl__ComparableClass
====== Resolving type decl ClassDecl LLongClass
Resolving variable decl range : Range
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl Long
====== Resolving type decl ClassDecl LongClass
====== Resolving type decl ClassDecl LongClass
====== Resolving type decl CoverDecl Short
====== Resolving type decl ClassDecl ShortClass
====== Resolving type decl ClassDecl ShortClass
====== Resolving type decl CoverDecl Int
====== Resolving type decl ClassDecl IntClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl ClassDecl IntClass
Resolving variable decl other : T
Resolving variable decl T : Class
====== Resolving type decl CoverDecl ULLong
====== Resolving type decl ClassDecl ULLongClass
Resolving variable decl range : Range
====== Resolving type decl ClassDecl ULLongClass
Resolving variable decl range : Range
====== Resolving type decl CoverDecl ULong
====== Resolving type decl ClassDecl ULongClass
====== Resolving type decl ClassDecl ULongClass
====== Resolving type decl CoverDecl UInt
====== Resolving type decl ClassDecl UIntClass
====== Resolving type decl ClassDecl UIntClass
====== Resolving type decl CoverDecl UShort
====== Resolving type decl ClassDecl UShortClass
====== Resolving type decl ClassDecl UShortClass
====== Resolving type decl CoverDecl Int8
====== Resolving type decl ClassDecl Int8Class
====== Resolving type decl ClassDecl Int8Class
====== Resolving type decl CoverDecl Int16
====== Resolving type decl ClassDecl Int16Class
====== Resolving type decl ClassDecl Int16Class
====== Resolving type decl CoverDecl Int32
====== Resolving type decl ClassDecl Int32Class
====== Resolving type decl ClassDecl Int32Class
====== Resolving type decl CoverDecl Int64
====== Resolving type decl ClassDecl Int64Class
====== Resolving type decl ClassDecl Int64Class
====== Resolving type decl CoverDecl UInt8
====== Resolving type decl ClassDecl UInt8Class
====== Resolving type decl ClassDecl UInt8Class
====== Resolving type decl CoverDecl UInt16
====== Resolving type decl ClassDecl UInt16Class
====== Resolving type decl ClassDecl UInt16Class
====== Resolving type decl CoverDecl UInt32
====== Resolving type decl ClassDecl UInt32Class
====== Resolving type decl ClassDecl UInt32Class
====== Resolving type decl CoverDecl UInt64
====== Resolving type decl ClassDecl UInt64Class
====== Resolving type decl ClassDecl UInt64Class
====== Resolving type decl CoverDecl Octet
====== Resolving type decl ClassDecl OctetClass
====== Resolving type decl ClassDecl OctetClass
====== Resolving type decl CoverDecl SizeT
====== Resolving type decl ClassDecl SizeTClass
====== Resolving type decl ClassDecl SizeTClass
====== Resolving type decl CoverDecl Bool
====== Resolving type decl ClassDecl BoolClass
====== Resolving type decl ClassDecl BoolClass
====== Resolving type decl CoverDecl LDouble
====== Resolving type decl ClassDecl LDoubleClass
Resolving variable decl str : String = gc_malloc(64)
====== Resolving type decl ClassDecl LDoubleClass
Resolving variable decl str : String = gc_malloc(64)
====== Resolving type decl CoverDecl Double
====== Resolving type decl ClassDecl DoubleClass
====== Resolving type decl ClassDecl DoubleClass
====== Resolving type decl CoverDecl Float
====== Resolving type decl ClassDecl FloatClass
====== Resolving type decl ClassDecl FloatClass
====== Resolving type decl CoverDecl Range
Resolving variable decl min : Int
Resolving variable decl max : Int
====== Resolving type decl ClassDecl RangeClass
Resolving variable decl this : Range
====== Resolving type decl ClassDecl RangeClass
Resolving variable decl this : Range
====== Resolving type decl ClassDecl Iterator
Resolving variable decl T : Class
Resolving variable decl T : Class
====== Resolving type decl ClassDecl IteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterator = Iterator alloc() as Iterator
====== Resolving type decl ClassDecl IteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterator = Iterator alloc() as Iterator
====== Resolving type decl ClassDecl Iterable
Resolving variable decl T : Class
Resolving variable decl T : Class
====== Resolving type decl ClassDecl IterableClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterable = Iterable alloc() as Iterable
====== Resolving type decl ClassDecl IterableClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Iterable = Iterable alloc() as Iterable
====== Resolving type decl ClassDecl StringIterator
Resolving variable decl T : Class
Resolving variable decl i : Int = 0
Resolving variable decl str : String
====== Resolving type decl ClassDecl StringIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringIterator = StringIterator alloc() as StringIterator
Resolving variable decl c : Char = StringIterator.str[StringIterator.i]
Resolving variable decl returnVal2 : Char = c
Resolving variable decl returnVal4 : Char = StringIterator.str[StringIterator.i]
====== Resolving type decl ClassDecl StringIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringIterator = StringIterator alloc() as StringIterator
Resolving variable decl c : Char = StringIterator.str[StringIterator.i]
Resolving variable decl returnVal2 : Char = c
Resolving variable decl returnVal4 : Char = StringIterator.str[StringIterator.i]
====== Resolving type decl ClassDecl Exception
Resolving variable decl origin : Class
Resolving variable decl msg : String
====== Resolving type decl ClassDecl ExceptionClass
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl x : Int = 0
Resolving variable decl max : Int = 1024
Resolving variable decl buffer : String = gc_malloc(max) as String
====== Resolving type decl ClassDecl ExceptionClass
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl this : Exception = Exception alloc() as Exception
Resolving variable decl x : Int = 0
Resolving variable decl max : Int = 1024
Resolving variable decl buffer : String = gc_malloc(max) as String
Resolving variable decl str1 : String
Resolving variable decl str2 : String
Resolving variable decl str1 : String
Resolving variable decl str2 : String
Resolving variable decl str : String
Resolving variable decl count : Int
Resolving variable decl left : String
Resolving variable decl right : String
Resolving variable decl left : LLong
Resolving variable decl right : String
Resolving variable decl left : String
Resolving variable decl right : LLong
Resolving variable decl left : Int
Resolving variable decl right : String
Resolving variable decl left : String
Resolving variable decl right : Int
Resolving variable decl left : Bool
Resolving variable decl right : String
Resolving variable decl left : String
Resolving variable decl right : Bool
Resolving variable decl left : Double
Resolving variable decl right : String
Resolving variable decl left : String
Resolving variable decl right : Double
Resolving variable decl left : String
Resolving variable decl right : Char
Resolving variable decl left : Char
Resolving variable decl right : String
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module lang/types finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module ITask
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl ITask
Resolving variable decl canKill : Bool
Resolving variable decl priority : Long
====== Resolving type decl ClassDecl ITaskClass
Resolving variable decl this : ITask = ITask alloc() as ITask
====== Resolving type decl ClassDecl ITaskClass
Resolving variable decl this : ITask = ITask alloc() as ITask
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module ITask finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/FileWriter
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl FileWriter
Resolving variable decl file : FStream
====== Resolving type decl ClassDecl FileWriterClass
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl fileObject : File
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl fmt : String
Resolving variable decl ap : VaList
Resolving variable decl fmt : String
Resolving variable decl args : VaList
====== Resolving type decl ClassDecl FileWriterClass
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileObject : File
Resolving variable decl append : Bool
Resolving variable decl fileObject : File
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl append : Bool
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl fileName : String
Resolving variable decl this : FileWriter = FileWriter alloc() as FileWriter
Resolving variable decl fileName : String
Resolving variable decl chars : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl fmt : String
Resolving variable decl ap : VaList
Resolving variable decl fmt : String
Resolving variable decl args : VaList
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module io/FileWriter finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/File
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl File
Resolving variable decl path : String
====== Resolving type decl ClassDecl FileClass
Resolving variable decl MAX_PATH_LENGTH : Int = 16383
Resolving variable decl separator : Char = CharLiteral
Resolving variable decl pathDelimiter : Char = CharLiteral
Resolving variable decl parent : File
Resolving variable decl parent : String
Resolving variable decl trimmed : String = File.path trim(FileClass.separator)
Resolving variable decl idx : Int = trimmed lastIndexOf(FileClass.separator)
Resolving variable decl pName : String = this parentName()
Resolving variable decl idx : Int = File.path lastIndexOf(FileClass.separator)
Resolving variable decl mode : Int32
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
Resolving variable decl dstFile : File
Resolving variable decl src : FileReader = FileReader new(this)
Resolving variable decl dst : FileWriter = FileWriter new(dstFile)
Resolving variable decl max : Int = 8192
Resolving variable decl buffer : Char[max]
Resolving variable decl num : SizeT = src read(buffer, 0, max)
Resolving variable decl name : String
Resolving variable decl ret : String = String new(FileClass.MAX_PATH_LENGTH + 1)
====== Resolving type decl ClassDecl FileClass
Resolving variable decl MAX_PATH_LENGTH : Int = 16383
Resolving variable decl separator : Char = CharLiteral
Resolving variable decl pathDelimiter : Char = CharLiteral
Resolving variable decl parent : File
Resolving variable decl parent : String
Resolving variable decl trimmed : String = File.path trim(FileClass.separator)
Resolving variable decl idx : Int = trimmed lastIndexOf(FileClass.separator)
Resolving variable decl pName : String = this parentName()
Resolving variable decl idx : Int = File.path lastIndexOf(FileClass.separator)
Resolving variable decl mode : Int32
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
Resolving variable decl dstFile : File
Resolving variable decl src : FileReader = FileReader new(this)
Resolving variable decl dst : FileWriter = FileWriter new(dstFile)
Resolving variable decl max : Int = 8192
Resolving variable decl buffer : Char[max]
Resolving variable decl num : SizeT = src read(buffer, 0, max)
Resolving variable decl name : String
Resolving variable decl ret : String = String new(FileClass.MAX_PATH_LENGTH + 1)
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module io/File finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/ArrayList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl ArrayList
Resolving variable decl T : Class
Resolving variable decl data : T*
Resolving variable decl capacity : Int
Resolving variable decl size : Int = 0
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl bsize : Int = (ArrayList.size - index) * Class.size
Resolving variable decl index : Int
Resolving variable decl returnVal6 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = -1
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = ArrayList.size
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal8 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = this indexOf(element)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl old : T = gc_malloc(Class.size)
Resolving variable decl returnVal90 : <unknown type> = old
returnVal90 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal90 = old (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg89 = returnVal90 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl newSize : Int
Resolving variable decl tmpData : Pointer = gc_realloc(data, capacity * Class.size)
Resolving variable decl x : Int = 0
Resolving variable decl index : Int
__OP_ADD_String_Int__String("Index too small! ", index) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Int__String("Index too small! ", index) + " < 0" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0")) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0")) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0")) looping because not resolved!'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0")) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0")) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0")) throw() looping because not resolved!'
__OP_ADD_String_Int__String("Index too big! ", index) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Int__String("Index too big! ", index) + " >= " (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size() (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size() (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size()) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size()) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size()) looping because not resolved!'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size()) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size()) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size()) throw() looping because not resolved!'
Resolving variable decl copy : ArrayList<T> = ArrayList<T> new(this size())
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl bsize : Int = (ArrayList.size - index) * Class.size
Resolving variable decl index : Int
Resolving variable decl returnVal6 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = -1
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = ArrayList.size
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal8 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = this indexOf(element)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl old : T = gc_malloc(Class.size)
Resolving variable decl returnVal90 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal90, old, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg89, returnVal90, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl newSize : Int
Resolving variable decl tmpData : Pointer = gc_realloc(ArrayList.data, ArrayList.capacity * Class.size)
Resolving variable decl x : Int = 0
Resolving variable decl index : Int
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0")) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too small! ", index), " < 0")) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= ") + this size() (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size())) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size())) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size())) looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size())) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size())) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size())) throw() looping because not resolved!'
Resolving variable decl copy : ArrayList<T> = ArrayList<T> new(this size())
====== Resolving type decl ClassDecl ArrayListIterator
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal10 : T = gc_malloc(Class.size)
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal12 : T = gc_malloc(Class.size)
Resolving variable decl genCall91 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal10 : T = gc_malloc(Class.size)
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal12 : T = gc_malloc(Class.size)
Resolving variable decl genCall91 : T = gc_malloc(Class.size)
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
Resolving variable decl genCall92 : T
genCall92 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl returnVal94 : <unknown type> = (comma expr)
returnVal94 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal94 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg93 = returnVal94 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl data : T*
Resolving variable decl size : SizeT
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/List
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl List
Resolving variable decl T : Class
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl iter19 : Iterator<T> = list iterator()
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T = gc_malloc(Class.size)
Resolving variable decl genArg15 : T = gc_malloc(Class.size)
Resolving variable decl size : Int = this size()
Resolving variable decl element : T
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : Int = this indexOf(oldie)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T = gc_malloc(Class.size)
Resolving variable decl returnVal18 : T = gc_malloc(Class.size)
Resolving variable decl genCall95 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal97 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal97, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg96, returnVal97, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl i : Int = 0
Resolving variable decl j : Int = this size() - 1
Resolving variable decl genCall20 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl genArg21 : T = gc_malloc(Class.size)
Resolving variable decl genCall22 : T = gc_malloc(Class.size)
Resolving variable decl genArg23 : T = gc_malloc(Class.size)
Resolving variable decl arr : T* = gc_malloc(this size() * Class.size)
Resolving variable decl i : Int
Resolving variable decl str : String
Resolving variable decl result : Buffer = Buffer new()
Resolving variable decl first : Bool = true
Resolving variable decl item : String
Resolving variable decl iter98 : Iterator<T> = this iterator()
item = iter98 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
result append(str) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
result append(item) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl chr : Char
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl iter19 : Iterator<T> = list iterator()
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T = gc_malloc(Class.size)
Resolving variable decl genArg15 : T = gc_malloc(Class.size)
Resolving variable decl size : Int = this size()
Resolving variable decl element : T
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : Int = this indexOf(oldie)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T = gc_malloc(Class.size)
Resolving variable decl returnVal18 : T = gc_malloc(Class.size)
Resolving variable decl genCall95 : T = gc_malloc(Class.size)
Resolving variable decl returnVal97 : T = gc_malloc(Class.size)
Resolving variable decl i : Int = 0
Resolving variable decl j : Int = this size() - 1
Resolving variable decl genCall20 : T = gc_malloc(Class.size)
Resolving variable decl genArg21 : T = gc_malloc(Class.size)
Resolving variable decl genCall22 : T = gc_malloc(Class.size)
Resolving variable decl genArg23 : T = gc_malloc(Class.size)
Resolving variable decl arr : T* = gc_malloc(this size() * Class.size)
Resolving variable decl i : Int
Resolving variable decl str : String
Resolving variable decl result : Buffer = Buffer new()
Resolving variable decl first : Bool = true
Resolving variable decl item : String
Resolving variable decl iter98 : Iterator<T> = this iterator()
Resolving variable decl chr : Char
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
Resolving variable decl genCall99 : T
genCall99 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl returnVal101 : <unknown type> = (comma expr)
returnVal101 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal101 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg100 = returnVal101 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/Buffer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl Buffer
Resolving variable decl size : SizeT
Resolving variable decl capacity : SizeT
Resolving variable decl data : String
====== Resolving type decl ClassDecl BufferClass
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl str : String
Resolving variable decl length : SizeT = str length()
Resolving variable decl str : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
Resolving variable decl offset : Int
Resolving variable decl min : SizeT
Resolving variable decl newCapa : SizeT = min * 1.200000 + 10
Resolving variable decl tmp : Pointer = gc_realloc(Buffer.data, newCapa)
Resolving variable decl newCapa : SizeT = Buffer.size + 1
Resolving variable decl tmp : Pointer = gc_realloc(Buffer.data as Char*, newCapa)
====== Resolving type decl ClassDecl BufferClass
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl this : Buffer = Buffer alloc() as Buffer
Resolving variable decl str : String
Resolving variable decl length : SizeT = str length()
Resolving variable decl str : String
Resolving variable decl length : SizeT
Resolving variable decl chr : Char
Resolving variable decl str : String
Resolving variable decl offset : SizeT
Resolving variable decl length : SizeT
Resolving variable decl offset : Int
Resolving variable decl min : SizeT
Resolving variable decl newCapa : SizeT = min * 1.200000 + 10
Resolving variable decl tmp : Pointer = gc_realloc(Buffer.data, newCapa)
Resolving variable decl newCapa : SizeT = Buffer.size + 1
Resolving variable decl tmp : Pointer = gc_realloc(Buffer.data as Char*, newCapa)
====== Resolving type decl ClassDecl BufferWriter
Resolving variable decl buffer : Buffer
====== Resolving type decl ClassDecl BufferWriterClass
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
====== Resolving type decl ClassDecl BufferWriterClass
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl this : BufferWriter = BufferWriter alloc() as BufferWriter
Resolving variable decl chr : Char
Resolving variable decl chars : String
Resolving variable decl length : SizeT
====== Resolving type decl ClassDecl BufferReader
Resolving variable decl buffer : Buffer
====== Resolving type decl ClassDecl BufferReaderClass
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl c : Char = BufferReader.buffer get(BufferReader.marker)
Resolving variable decl offset : Int
Resolving variable decl marker : Long
====== Resolving type decl ClassDecl BufferReaderClass
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
Resolving variable decl this : BufferReader = BufferReader alloc() as BufferReader
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl c : Char = BufferReader.buffer get(BufferReader.marker)
Resolving variable decl offset : Int
Resolving variable decl marker : Long
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module text/Buffer finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/FileReader
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl SEEK_CUR : Int
Resolving variable decl SEEK_SET : Int
Resolving variable decl SEEK_END : Int
====== Resolving type decl ClassDecl FileReader
Resolving variable decl file : FILE*
====== Resolving type decl ClassDecl FileReaderClass
Resolving variable decl fileObject : File
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileName : String
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl value : Char
Resolving variable decl sb : Buffer = Buffer new(40)
Resolving variable decl c : Char = this read()
Resolving variable decl offset : Int
Resolving variable decl marker : Long
====== Resolving type decl ClassDecl FileReaderClass
Resolving variable decl fileObject : File
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileObject : File
Resolving variable decl fileName : String
Resolving variable decl this : FileReader = FileReader alloc() as FileReader
Resolving variable decl fileName : String
Resolving variable decl chars : String
Resolving variable decl offset : Int
Resolving variable decl count : Int
Resolving variable decl value : Char
Resolving variable decl sb : Buffer = Buffer new(40)
Resolving variable decl c : Char = this read()
Resolving variable decl offset : Int
Resolving variable decl marker : Long
Resolving variable decl filename : Char*
Resolving variable decl mode : Char*
Resolving variable decl ptr : Pointer
Resolving variable decl size : SizeT
Resolving variable decl count : SizeT
Resolving variable decl stream : FILE*
Resolving variable decl stream : FILE*
Resolving variable decl stream : FILE*
Resolving variable decl offset : Long
Resolving variable decl origin : Int
Resolving variable decl stream : FILE*
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module io/FileReader finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/native/FileWin32
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl FILE_ATTRIBUTE_DIRECTORY : Long
Resolving variable decl FILE_ATTRIBUTE_REPARSE_POINT : Long
Resolving variable decl FILE_ATTRIBUTE_NORMAL : Long
====== Resolving type decl CoverDecl FindData
Resolving variable decl attr : Long
Resolving variable decl fileSizeLow : Long
Resolving variable decl fileSizeHigh : Long
Resolving variable decl creationTime : FileTime
Resolving variable decl lastAccessTime : FileTime
Resolving variable decl lastWriteTime : FileTime
Resolving variable decl fileName : String
====== Resolving type decl ClassDecl FindDataClass
====== Resolving type decl ClassDecl FindDataClass
====== Resolving type decl ClassDecl FileWin32
====== Resolving type decl ClassDecl FileWin32Class
Resolving variable decl this : FileWin32 = FileWin32 alloc() as FileWin32
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : Handle = this findFirst(ffdPtr)
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : Handle = FindFirstFile(FileWin32.path, ffdPtr)
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : Handle = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
Resolving variable decl genArg102 : String = __OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)
Resolving variable decl result : ArrayList<FileWin32> = ArrayList<This> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : Handle = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
Resolving variable decl genArg103 : File = File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName))
====== Resolving type decl ClassDecl FileWin32Class
Resolving variable decl this : FileWin32 = FileWin32 alloc() as FileWin32
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : Handle = this findFirst(ffdPtr)
Resolving variable decl ffdPtr : FindData*
Resolving variable decl hFind : Handle = FindFirstFile(FileWin32.path, ffdPtr)
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl mode : Int32
Resolving variable decl parent : File = this parent()
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl ffd : FindData
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : Handle = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
Resolving variable decl genArg102 : String = __OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName)
Resolving variable decl result : ArrayList<FileWin32> = ArrayList<This> new()
Resolving variable decl ffd : FindData
Resolving variable decl hFile : Handle = FindFirstFile(__OP_ADD_String_String__String(FileWin32.path, "\\*"), ffd&)
Resolving variable decl running : Bool = (hFile != INVALID_HANDLE_VALUE)
Resolving variable decl genArg103 : File = File new(__OP_ADD_String_String__String(__OP_ADD_String_Char__String(FileWin32.path, CharLiteral), FindData.fileName))
Resolving variable decl String
Resolving variable decl FindData*
Resolving variable decl Handle
Resolving variable decl FindData*
Resolving variable decl Handle
Resolving variable decl String
Resolving variable decl String
Resolving variable decl Pointer
Resolving variable decl path : String
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module io/native/FileWin32 finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module io/native/FileUnix
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl S_IRWXU : Long
Resolving variable decl S_IRWXG : Long
Resolving variable decl S_IRWXO : Long
====== Resolving type decl CoverDecl ModeT
====== Resolving type decl ClassDecl ModeTClass
====== Resolving type decl ClassDecl ModeTClass
====== Resolving type decl CoverDecl FileStat
Resolving variable decl st_mode : ModeT
Resolving variable decl st_size : SizeT
Resolving variable decl st_atime : TimeT
Resolving variable decl st_mtime : TimeT
Resolving variable decl st_ctime : TimeT
====== Resolving type decl ClassDecl FileStatClass
====== Resolving type decl ClassDecl FileStatClass
====== Resolving type decl ClassDecl FileUnix
====== Resolving type decl ClassDecl FileUnixClass
Resolving variable decl this : FileUnix = FileUnix alloc() as FileUnix
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl actualPath : String = String new(FileUnixClass.MAX_PATH_LENGTH + 1)
Resolving variable decl actualPath : String = this getAbsolutePath()
Resolving variable decl dir : DirPtr = opendir(FileUnix.path)
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl entry : DirEnt* = readdir(dir)
Resolving variable decl genArg104 : String = DirEnt.name clone()
Resolving variable decl dir : DirPtr = opendir(FileUnix.path)
Resolving variable decl result : ArrayList<FileUnix> = ArrayList<This> new()
Resolving variable decl entry : DirEnt* = readdir(dir)
Resolving variable decl genArg105 : File = File new(this, DirEnt.name clone())
Resolving variable decl mode : Int32
====== Resolving type decl ClassDecl FileUnixClass
Resolving variable decl this : FileUnix = FileUnix alloc() as FileUnix
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl stat : FileStat
Resolving variable decl actualPath : String = String new(FileUnixClass.MAX_PATH_LENGTH + 1)
Resolving variable decl actualPath : String = this getAbsolutePath()
Resolving variable decl dir : DirPtr = opendir(FileUnix.path)
Resolving variable decl result : ArrayList<String> = ArrayList<String> new()
Resolving variable decl entry : DirEnt* = readdir(dir)
Resolving variable decl genArg104 : String = DirEnt.name clone()
Resolving variable decl dir : DirPtr = opendir(FileUnix.path)
Resolving variable decl result : ArrayList<FileUnix> = ArrayList<This> new()
Resolving variable decl entry : DirEnt* = readdir(dir)
Resolving variable decl genArg105 : File = File new(this, DirEnt.name clone())
Resolving variable decl mode : Int32
Resolving variable decl path : String
Resolving variable decl resolved : String
Resolving variable decl buf : String
Resolving variable decl size : SizeT
Resolving variable decl String
Resolving variable decl FileStat*
Resolving variable decl String
Resolving variable decl ModeT
Resolving variable decl path : String
Resolving variable decl path : String
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module io/native/FileUnix finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module os/Time
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl CoverDecl SystemTime
Resolving variable decl wHour : UShort
Resolving variable decl wMinute : UShort
Resolving variable decl wSecond : UShort
Resolving variable decl wMilliseconds : UShort
====== Resolving type decl ClassDecl SystemTimeClass
====== Resolving type decl ClassDecl SystemTimeClass
====== Resolving type decl CoverDecl TimeT
====== Resolving type decl ClassDecl TimeTClass
====== Resolving type decl ClassDecl TimeTClass
====== Resolving type decl CoverDecl TimeZone
====== Resolving type decl ClassDecl TimeZoneClass
====== Resolving type decl ClassDecl TimeZoneClass
====== Resolving type decl CoverDecl TMStruct
Resolving variable decl tm_sec : Int
Resolving variable decl tm_min : Int
Resolving variable decl tm_hour : Int
Resolving variable decl tm_mday : Int
Resolving variable decl tm_mon : Int
Resolving variable decl tm_year : Int
Resolving variable decl tm_wday : Int
Resolving variable decl tm_yday : Int
Resolving variable decl tm_isdst : Int
====== Resolving type decl ClassDecl TMStructClass
====== Resolving type decl ClassDecl TMStructClass
====== Resolving type decl CoverDecl TimeVal
Resolving variable decl tv_sec : TimeT
Resolving variable decl tv_usec : Int
====== Resolving type decl ClassDecl TimeValClass
====== Resolving type decl ClassDecl TimeValClass
====== Resolving type decl ClassDecl Time
====== Resolving type decl ClassDecl TimeClass
Resolving variable decl this : Time = Time alloc() as Time
Resolving variable decl st : SystemTime
Resolving variable decl tv : TimeVal
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl duration : Float
Resolving variable decl duration : UInt
Resolving variable decl duration : UInt
====== Resolving type decl ClassDecl TimeClass
Resolving variable decl this : Time = Time alloc() as Time
Resolving variable decl st : SystemTime
Resolving variable decl tv : TimeVal
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl st : SystemTime
Resolving variable decl tt : TimeT = time(NullLiteral)
Resolving variable decl val : TMStruct* = localtime(tt&)
Resolving variable decl duration : Float
Resolving variable decl duration : UInt
Resolving variable decl duration : UInt
Resolving variable decl SystemTime*
Resolving variable decl UInt
Resolving variable decl TimeT*
Resolving variable decl TimeT*
Resolving variable decl TimeVal*
Resolving variable decl TimeZone*
Resolving variable decl UInt
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module os/Time finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CInputTask
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CInputTask
Resolving variable decl keyCount : Int
Resolving variable decl dX : Int
Resolving variable decl dY : Int
Resolving variable decl event : Event
Resolving variable decl listeners : LinkedList<Listener>
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
Resolving variable decl listener : <unknown type>
CInputTask.listeners iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (listener in CInputTask.listeners) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl event : Event
Resolving variable decl listener : Listener
Resolving variable decl listener : Listener
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
Resolving variable decl listener : <unknown type>
CInputTask.listeners iterator() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
for (listener in CInputTask.listeners) (of type Foreach) wants to wholeAgain() because 'need iterType'
Resolving variable decl event : Event
Resolving variable decl listener : Listener
Resolving variable decl listener : Listener
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'need ref arg type'
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'To resolve interface-args, need to resolve declArg and callArg'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/LinkedList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LinkedList
Resolving variable decl T : Class
Resolving variable decl size : Int = 0
Resolving variable decl first : Node<T>
Resolving variable decl last : Node<T>
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : Node<T> = this getNode(index - 1)
Resolving variable decl nextNode : Node<T> = Node<T>.next
Resolving variable decl node : Node<T> = Node<T> new(prevNode, nextNode, data)
this size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
index == this size() (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl node : Node<T> = Node<T> new(NullLiteral, LinkedList.first, data)
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl next : Node<T> = Node<T>.next
Resolving variable decl index : Int
Resolving variable decl returnVal107 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal107, Node<T>.data, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg106, returnVal107, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl index : Int
__OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl i : Int = 0
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl i : Int = 0
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.last
Resolving variable decl i : Int = LinkedList.size - 1
Resolving variable decl index : Int
Resolving variable decl toRemove : Node<T> = this getNode(index)
Resolving variable decl returnVal109 : <unknown type> = Node<T>.data
returnVal109 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal109 = Node<T>.data (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg108 = returnVal109 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
"Check index: 0 <= " + index (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Check index: 0 <= ", index) (who is null? true, false, false, false)'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " + size) throw() looping because not resolved!'
removeAt: func (index : Int) (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl data : T
Resolving variable decl i : <unknown type> = indexOf(data)
this indexOf(data) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
	$$$$ resolving returnType T for this removeAt(i)
this removeAt(i) (of type FunctionCall) wants to wholeAgain() because 'because of return type T'
Resolving variable decl toRemove : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
return (of type Return) wants to wholeAgain() because 'Turned into an assignment'
Response of statement [Return] return = LOOP
))))))) For set: func (index : Int, data : T), response of body = LOOP
Response of fDecl set: func (index : Int, data : T) = LOOP
-- ClassDecl LinkedListClass, meta of ClassDecl LinkedList, isn't resolved, looping.
response of tDecl ClassDecl LinkedList = LOOP
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : Node<T> = this getNode(index - 1)
Resolving variable decl nextNode : Node<T> = Node<T>.next
Resolving variable decl node : Node<T> = Node<T> new(prevNode, nextNode, data)
this size() (of type FunctionCall) wants to wholeAgain() because 'need to know if the return type of our ref is generic.'
index == this size() (of type Comparison) wants to wholeAgain() because 'score of operator ==(str1 : String, str2 : String) == -1 !!'
Resolving variable decl node : Node<T> = Node<T> new(NullLiteral, LinkedList.first, data)
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl next : Node<T> = Node<T>.next
Resolving variable decl index : Int
Resolving variable decl returnVal107 : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl i : Int = 0
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl i : Int = 0
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.last
Resolving variable decl i : Int = LinkedList.size - 1
Resolving variable decl index : Int
Resolving variable decl toRemove : Node<T> = this getNode(index)
Resolving variable decl returnVal109 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal109, Node<T>.data, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg108, returnVal109, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Int__String("Check index: 0 <= ", index) + " < " (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'score of operator +(left : String, right : String) == -1 !!'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") (who is null? true, false, false, false)'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) looping because not resolved!'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size) throw() looping because not resolved!'
removeAt: func (index : Int) (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl data : T
Resolving variable decl i : Int = this indexOf(data)
Resolving variable decl toRemove : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl returnVal118 : <unknown type> = NullLiteral
returnArg117 = returnVal118 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
LinkedListIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<T>'
println() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("prev: ") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl current : <unknown type> = first
Terminal setFgColor(ColorClass.red + Node<T>.prev as Int % 7) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("|%p|", Node<T>.prev) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Terminal reset() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("|         |") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
println() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("this: ") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Terminal setFgColor(ColorClass.red + current as Int % 7) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("|%p|", current) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Terminal reset() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
println() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("next: ") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Terminal setFgColor(ColorClass.red + Node<T>.next as Int % 7) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("|%p|", Node<T>.next) (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Terminal reset() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
printf("|         |") (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
println() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl Node
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl prev : Node<T>
Resolving variable decl next : Node<T>
Resolving variable decl data : T = gc_malloc(Class.size)
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
====== Resolving type decl ClassDecl LinkedListIterator
Resolving variable decl T : Class
Resolving variable decl current : Node<T>
Resolving variable decl list : LinkedList<T>
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = LinkedListIterator.current
Resolving variable decl returnVal26 : T = gc_malloc(Class.size)
Resolving variable decl returnVal28 : T = gc_malloc(Class.size)
Resolving variable decl old : Node<T> = LinkedListIterator.current
LinkedListIterator.list removeNode(old) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = LinkedListIterator.current
Resolving variable decl returnVal26 : T = gc_malloc(Class.size)
Resolving variable decl returnVal28 : T = gc_malloc(Class.size)
Resolving variable decl old : Node<T> = LinkedListIterator.current
Resolving variable decl list : LinkedList<T>
Resolving variable decl index : Int
Resolving variable decl T : Class
Resolving variable decl genCall29 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal31 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal31, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg30, returnVal31, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
[Module] response = LOOP (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CKernel
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CKernel
Resolving variable decl taskList : LinkedList<ITask>
Resolving variable decl pausedTaskList : LinkedList<ITask>
====== Resolving type decl ClassDecl CKernelClass
Resolving variable decl instance : CKernel = NullLiteral
Resolving variable decl this : CKernel = CKernel alloc() as CKernel
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<ITask>'
iter119 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter119 next()
iter119 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type ITask'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
CKernel.taskList size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
CKernel.taskList size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<ITask>'
iter120 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter120 next()
iter120 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type ITask'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<ITask>'
iter121 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter121 next()
iter121 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type ITask'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl t : ITask
CKernel.taskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl t : ITask
CKernel.pausedTaskList remove(t) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl pos : Int = 0
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<ITask>'
iter122 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter122 next()
iter122 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type ITask'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl t : ITask
Resolving variable decl task : <unknown type>
CKernel.taskList iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<ITask>'
iter123 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter123 next()
iter123 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type ITask'
for (task in CKernel.taskList) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
====== Resolving type decl ClassDecl CKernelClass
Resolving variable decl instance : CKernel = NullLiteral
Resolving variable decl this : CKernel = CKernel alloc() as CKernel
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : ITask
Resolving variable decl iter119 : LinkedListIterator<ITask> = CKernel.taskList iterator()
task = iter119 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
Resolving variable decl task : ITask
Resolving variable decl iter120 : LinkedListIterator<ITask> = CKernel.taskList iterator()
task = iter120 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
task update() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl task : ITask
Resolving variable decl iter121 : LinkedListIterator<ITask> = CKernel.taskList iterator()
task = iter121 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
task stop() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
taskList remove(task) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl t : ITask
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : ITask
Resolving variable decl iter122 : LinkedListIterator<ITask> = CKernel.taskList iterator()
task = iter122 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
Resolving variable decl t : ITask
Resolving variable decl task : ITask
Resolving variable decl iter123 : LinkedListIterator<ITask> = CKernel.taskList iterator()
task = iter123 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module LevelEditor
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LevelEditor
Resolving variable decl NONE : Int = 0
Resolving variable decl GRAB : Int = 1
Resolving variable decl SCALE : Int = 2
Resolving variable decl ROTATE : Int = 3
Resolving variable decl ADDMODEL : Int = 4
Resolving variable decl currentModelName : Node<String>
Resolving variable decl currentModelType : CProduct
Resolving variable decl grabLock : Int3 = Int3 new(0, 0, 0)
Resolving variable decl rotLock : Int3 = Int3 new(0, 0, 0)
Resolving variable decl sclLock : Int3 = Int3 new(0, 0, 0)
Resolving variable decl camera : FFCamera
Resolving variable decl wire : Bool = false
Resolving variable decl world : World = World new()
Resolving variable decl mode : Bool = false
Resolving variable decl editMode : Int = LevelEditor.NONE
Resolving variable decl backupPos : Double3 = Double3 new(0, 0, 0)
====== Resolving type decl ClassDecl LevelEditorClass
Resolving variable decl this : LevelEditor = LevelEditor alloc() as LevelEditor
Resolving variable decl name : String
FFCamera new(Double3 new(5, 5, 5)) (of type FunctionCall) wants to wholeAgain() because 'because of return type FFCamera'
Resolving variable decl ambientLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl genArg32 : Float = 0.200000
Resolving variable decl genArg33 : Float = 0.200000
Resolving variable decl genArg34 : Float = 0.200000
Resolving variable decl genArg35 : Float = 1.000000
Resolving variable decl diffuseLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl specularLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl position : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl event : Event
Resolving variable decl event : Event
Resolving variable decl mouse : Double3 = this getMouseVector(Motion.x, Motion.y)
Resolving variable decl mouse : Double3
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.y - Double3.y) / (Double3.y - Double3.y)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl i : Int
Resolving variable decl i : Int
Resolving variable decl mousex : Int
Resolving variable decl mousey : Int
Resolving variable decl Bx : GLdouble
Resolving variable decl By : GLdouble
Resolving variable decl Bz : GLdouble
Resolving variable decl viewport : GLint[4]
Resolving variable decl mvmatrix : GLdouble[16]
Resolving variable decl projmatrix : GLdouble[16]
====== Resolving type decl ClassDecl LevelEditorClass
Resolving variable decl this : LevelEditor = LevelEditor alloc() as LevelEditor
Resolving variable decl name : String
Resolving variable decl ambientLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl genArg32 : Float = 0.200000
Resolving variable decl genArg33 : Float = 0.200000
Resolving variable decl genArg34 : Float = 0.200000
Resolving variable decl genArg35 : Float = 1.000000
Resolving variable decl diffuseLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl specularLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl position : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl event : Event
Resolving variable decl event : Event
Resolving variable decl mouse : Double3 = this getMouseVector(Motion.x, Motion.y)
Resolving variable decl mouse : Double3
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.y - Double3.y) / (Double3.y - Double3.y)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl i : Int
Resolving variable decl i : Int
Resolving variable decl mousex : Int
Resolving variable decl mousey : Int
Resolving variable decl Bx : GLdouble
Resolving variable decl By : GLdouble
Resolving variable decl Bz : GLdouble
Resolving variable decl viewport : GLint[4]
Resolving variable decl mvmatrix : GLdouble[16]
Resolving variable decl projmatrix : GLdouble[16]
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CFactory
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CFactory
Resolving variable decl meshes : HashMap<StaticMesh> = HashMap<StaticMesh> new()
Resolving variable decl names : LinkedList<String> = LinkedList<String> new()
Resolving variable decl id : Int = 0
====== Resolving type decl ClassDecl CFactoryClass
Resolving variable decl instance : CFactory = NullLiteral
Resolving variable decl this : CFactory = CFactory alloc() as CFactory
Resolving variable decl productType : Int
Resolving variable decl filename : String
====== Resolving type decl ClassDecl CFactoryClass
Resolving variable decl instance : CFactory = NullLiteral
Resolving variable decl this : CFactory = CFactory alloc() as CFactory
Resolving variable decl productType : Int
Resolving variable decl filename : String
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module CFactory finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CProduct
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl MESH : Int = 0
Resolving variable decl TEXTURE : Int = 1
====== Resolving type decl ClassDecl CProduct
Resolving variable decl filename : String
Resolving variable decl id : Int
====== Resolving type decl ClassDecl CProductClass
Resolving variable decl this : CProduct = CProduct alloc() as CProduct
====== Resolving type decl ClassDecl CProductClass
Resolving variable decl this : CProduct = CProduct alloc() as CProduct
====== Resolving type decl ClassDecl StaticMesh
Resolving variable decl vertices : ArrayList<Float3>
Resolving variable decl normals : ArrayList<Float3>
Resolving variable decl faces : ArrayList<FaceNoTex>
Resolving variable decl dlist : GLuint = 0
====== Resolving type decl ClassDecl StaticMeshClass
Resolving variable decl this : StaticMesh = StaticMesh alloc() as StaticMesh
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl nVertices : Int = 0
Resolving variable decl nNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl i : Int
Resolving variable decl genCall36 : FaceNoTex
Resolving variable decl genCall37 : FaceNoTex
Resolving variable decl genCall38 : FaceNoTex
Resolving variable decl genCall39 : Float3
Resolving variable decl genCall40 : Float3
Resolving variable decl genCall41 : Float3
Resolving variable decl genCall42 : FaceNoTex
Resolving variable decl genCall43 : FaceNoTex
Resolving variable decl genCall44 : FaceNoTex
Resolving variable decl genCall45 : Float3
Resolving variable decl genCall46 : Float3
Resolving variable decl genCall47 : Float3
Resolving variable decl genCall48 : FaceNoTex
Resolving variable decl genCall49 : FaceNoTex
Resolving variable decl genCall50 : FaceNoTex
Resolving variable decl genCall51 : Float3
Resolving variable decl genCall52 : Float3
Resolving variable decl genCall53 : Float3
Resolving variable decl genCall54 : FaceNoTex
Resolving variable decl genCall55 : FaceNoTex
Resolving variable decl genCall56 : FaceNoTex
Resolving variable decl genCall57 : Float3
Resolving variable decl genCall58 : Float3
Resolving variable decl genCall59 : Float3
Resolving variable decl genCall60 : FaceNoTex
Resolving variable decl genCall61 : FaceNoTex
Resolving variable decl genCall62 : FaceNoTex
Resolving variable decl genCall63 : Float3
Resolving variable decl genCall64 : Float3
Resolving variable decl genCall65 : Float3
Resolving variable decl genCall66 : FaceNoTex
Resolving variable decl genCall67 : FaceNoTex
Resolving variable decl genCall68 : FaceNoTex
Resolving variable decl genCall69 : Float3
Resolving variable decl genCall70 : Float3
Resolving variable decl genCall71 : Float3
====== Resolving type decl ClassDecl StaticMeshClass
Resolving variable decl this : StaticMesh = StaticMesh alloc() as StaticMesh
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl nVertices : Int = 0
Resolving variable decl nNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl i : Int
Resolving variable decl genCall36 : FaceNoTex
Resolving variable decl genCall37 : FaceNoTex
Resolving variable decl genCall38 : FaceNoTex
Resolving variable decl genCall39 : Float3
Resolving variable decl genCall40 : Float3
Resolving variable decl genCall41 : Float3
Resolving variable decl genCall42 : FaceNoTex
Resolving variable decl genCall43 : FaceNoTex
Resolving variable decl genCall44 : FaceNoTex
Resolving variable decl genCall45 : Float3
Resolving variable decl genCall46 : Float3
Resolving variable decl genCall47 : Float3
Resolving variable decl genCall48 : FaceNoTex
Resolving variable decl genCall49 : FaceNoTex
Resolving variable decl genCall50 : FaceNoTex
Resolving variable decl genCall51 : Float3
Resolving variable decl genCall52 : Float3
Resolving variable decl genCall53 : Float3
Resolving variable decl genCall54 : FaceNoTex
Resolving variable decl genCall55 : FaceNoTex
Resolving variable decl genCall56 : FaceNoTex
Resolving variable decl genCall57 : Float3
Resolving variable decl genCall58 : Float3
Resolving variable decl genCall59 : Float3
Resolving variable decl genCall60 : FaceNoTex
Resolving variable decl genCall61 : FaceNoTex
Resolving variable decl genCall62 : FaceNoTex
Resolving variable decl genCall63 : Float3
Resolving variable decl genCall64 : Float3
Resolving variable decl genCall65 : Float3
Resolving variable decl genCall66 : FaceNoTex
Resolving variable decl genCall67 : FaceNoTex
Resolving variable decl genCall68 : FaceNoTex
Resolving variable decl genCall69 : Float3
Resolving variable decl genCall70 : Float3
Resolving variable decl genCall71 : Float3
====== Resolving type decl ClassDecl StaticTexture
====== Resolving type decl ClassDecl StaticTextureClass
Resolving variable decl this : StaticTexture = StaticTexture alloc() as StaticTexture
====== Resolving type decl ClassDecl StaticTextureClass
Resolving variable decl this : StaticTexture = StaticTexture alloc() as StaticTexture
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module CProduct finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl PI : Float = 3.140000
====== Resolving type decl ClassDecl Double2
Resolving variable decl x : Double
Resolving variable decl y : Double
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double3
Resolving variable decl x : Double
Resolving variable decl y : Double
Resolving variable decl z : Double
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : Double = this length()
__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|") + Double3.z (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|"), Double3.z) + ")" (of type BinaryOp) wants to wholeAgain() because 'score of operator +(v1 : Double3, v2 : Double3) == -1 !!'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|"), Double3.z) + ")" (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = __OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|"), Double3.z) (who is null? true, false, false, false)'
return __OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|"), Double3.z) + ")" (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : Double = this length()
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|"), Double3.z) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|"), Double3.z) + ")" (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
return __OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|"), Double3.z), ")") (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl CoverDecl Float2
Resolving variable decl x : Float
Resolving variable decl y : Float
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl CoverDecl Float3
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl CoverDecl Float4
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl CoverDecl Octet3
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl CoverDecl Octet4
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl CoverDecl Int3
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl CoverDecl Int2
Resolving variable decl x : Int
Resolving variable decl y : Int
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl CoverDecl VFace
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl CoverDecl Face
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl CoverDecl FaceNoTex
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceNoTexClass
====== Resolving type decl ClassDecl FaceNoTexClass
Resolving variable decl v1 : Double3
Resolving variable decl n : Double
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl vals : Double*
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl d : Float
Resolving variable decl i3 : Int3
Resolving variable decl vals : Int*
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/HashMap
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl HashEntry
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl key : String
Resolving variable decl value : T = gc_malloc(Class.size)
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
====== Resolving type decl ClassDecl HashMap
Resolving variable decl T : Class
Resolving variable decl size : UInt
Resolving variable decl capacity : UInt
Resolving variable decl buckets : ArrayList<T>*
Resolving variable decl keys : ArrayList<String>
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl iter : Iterator<T> = HashMap.buckets[hash] iterator()
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl v1 : Int = HashMap.capacity / 0.700000
Resolving variable decl v2 : Int = HashMap.capacity * 2
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : T = gc_malloc(Class.size)
Resolving variable decl returnVal74 : Pointer = NullLiteral
Resolving variable decl key : String
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl i : UInt
Resolving variable decl cKey : String
Resolving variable decl _capacity : UInt
Resolving variable decl old_capacity : UInt = HashMap.capacity
Resolving variable decl old_buckets : ArrayList<T>* = gc_malloc(old_capacity * PointerClass.size) as ArrayList<T>*
Resolving variable decl i : UInt
Resolving variable decl i : UInt
Resolving variable decl entry : HashEntry<T>
Resolving variable decl bucket : UInt
Resolving variable decl iter : Iterator<T> = old_buckets[bucket] iterator()
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl iter : Iterator<T> = HashMap.buckets[hash] iterator()
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl v1 : Int = HashMap.capacity / 0.700000
Resolving variable decl v2 : Int = HashMap.capacity * 2
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : T = gc_malloc(Class.size)
Resolving variable decl returnVal74 : Pointer = NullLiteral
Resolving variable decl key : String
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl i : UInt
Resolving variable decl cKey : String
Resolving variable decl _capacity : UInt
Resolving variable decl old_capacity : UInt = HashMap.capacity
Resolving variable decl old_buckets : ArrayList<T>* = gc_malloc(old_capacity * PointerClass.size) as ArrayList<T>*
Resolving variable decl i : UInt
Resolving variable decl i : UInt
Resolving variable decl entry : HashEntry<T>
Resolving variable decl bucket : UInt
Resolving variable decl iter : Iterator<T> = old_buckets[bucket] iterator()
====== Resolving type decl ClassDecl HashMapValueIterator
Resolving variable decl T : Class
Resolving variable decl map : HashMap<T>
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
Resolving variable decl key : String
Resolving variable decl genCall75 : T = gc_malloc(Class.size)
Resolving variable decl returnVal77 : T = gc_malloc(Class.size)
Resolving variable decl key : String
Resolving variable decl genCall78 : T = gc_malloc(Class.size)
Resolving variable decl returnVal80 : T = gc_malloc(Class.size)
Resolving variable decl genCall110 : String
Resolving variable decl result : Bool = HashMapValueIterator.map remove((comma expr))
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
Resolving variable decl key : String
Resolving variable decl genCall75 : T = gc_malloc(Class.size)
Resolving variable decl returnVal77 : T = gc_malloc(Class.size)
Resolving variable decl key : String
Resolving variable decl genCall78 : T = gc_malloc(Class.size)
Resolving variable decl returnVal80 : T = gc_malloc(Class.size)
Resolving variable decl genCall110 : String
Resolving variable decl result : Bool = HashMapValueIterator.map remove((comma expr))
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl T : Class
Resolving variable decl genCall111 : T
genCall111 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
Resolving variable decl returnVal113 : <unknown type> = (comma expr)
returnVal113 : T = gc_malloc(size) (of type VariableDecl) wants to wholeAgain() because 'just set expr to gc_malloc cause generic!'
returnVal113 = (comma expr) (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
returnArg112 = returnVal113 (of type BinaryOp) wants to wholeAgain() because 'Replaced ourselves, need to tidy up'
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module FFCamera
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl FFCamera
Resolving variable decl speed : Double
Resolving variable decl sensivity : Double
Resolving variable decl phi : Double
Resolving variable decl theta : Double
Resolving variable decl forward : Double3 = Double3 new(0, 0, 0)
Resolving variable decl left : Double3 = Double3 new(0, 0, 0)
Resolving variable decl kforward : Bool = false
Resolving variable decl kbackward : Bool = false
Resolving variable decl kstrafe_left : Bool = false
Resolving variable decl kstrafe_right : Bool = false
Resolving variable decl keyconf : HashMap<Int> = HashMap<Int> new()
Resolving variable decl keystates : HashMap<Bool> = HashMap<Bool> new()
Resolving variable decl enabled : Bool = true
====== Resolving type decl ClassDecl FFCameraClass
Resolving variable decl this : FFCamera = FFCamera alloc() as FFCamera
Resolving variable decl genArg81 : Bool = false
Resolving variable decl genArg82 : Bool = false
Resolving variable decl genArg83 : Bool = false
Resolving variable decl genArg84 : Bool = false
Resolving variable decl genArg85 : Bool = false
Resolving variable decl e : Motion
Resolving variable decl event : Event
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl up : Double3 = Double3 new(0, 0, 1)
Resolving variable decl rTemp : Double = cos(FFCamera.phi / 180.000000)
====== Resolving type decl ClassDecl FFCameraClass
Resolving variable decl this : FFCamera = FFCamera alloc() as FFCamera
Resolving variable decl genArg81 : Bool = false
Resolving variable decl genArg82 : Bool = false
Resolving variable decl genArg83 : Bool = false
Resolving variable decl genArg84 : Bool = false
Resolving variable decl genArg85 : Bool = false
Resolving variable decl e : Motion
Resolving variable decl event : Event
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl e : Key
Resolving variable decl a : Int = Keysym.sym
Resolving variable decl up : Double3 = Double3 new(0, 0, 1)
Resolving variable decl rTemp : Double = cos(FFCamera.phi / 180.000000)
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module FFCamera finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module World
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl World
Resolving variable decl objects : LinkedList<GameObject> = LinkedList<GameObject> new()
Resolving variable decl id : Int = 0
Resolving variable decl pickedID : Int = -1
Resolving variable decl picked : GameObject = NullLiteral
====== Resolving type decl ClassDecl WorldClass
Resolving variable decl this : World = World alloc() as World
Resolving variable decl mode : GLenum
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<GameObject>'
iter124 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter124 next()
iter124 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type GameObject'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<GameObject>'
iter125 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter125 next()
iter125 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type GameObject'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl cam : Camera
Resolving variable decl BUFSIZE : Int = 512
Resolving variable decl selectBuf : GLuint[BUFSIZE]
Resolving variable decl hits : GLint
Resolving variable decl viewport : GLint[4]
Resolving variable decl minz : Int = 2147483647
Resolving variable decl minid : Int = -1
Resolving variable decl i : Int
Resolving variable decl hits : GLint
Resolving variable decl names : GLuint*
Resolving variable decl jayjay : Int = 2147483647
Resolving variable decl i : Int
Resolving variable decl object : GameObject
Resolving variable decl filename : String
Resolving variable decl target : FileWriter = FileWriter new(filename)
Resolving variable decl mesh : StaticMesh
Resolving variable decl iter114 : Iterator<StaticMesh> = CFactory.meshes iterator()
__OP_ADD_String_String__String(StaticMesh.filename, "\n") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
target write(__OP_ADD_String_String__String(StaticMesh.filename, "\n")) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl object : <unknown type>
World.objects iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<GameObject>'
iter126 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter126 next()
iter126 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type GameObject'
for (object in World.objects) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl filename : String
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl fileMeshes : HashMap<String> = HashMap<String> new()
Resolving variable decl line : String = readLine(source)
Resolving variable decl nMeshes : Int = 0
Resolving variable decl i : Int
Resolving variable decl line : String = readLine(source)
Resolving variable decl id : Int
Resolving variable decl filename : String = String new(1024)
Resolving variable decl nObjects : Int
Resolving variable decl i : Int
Resolving variable decl id : Int
Resolving variable decl px : Double
Resolving variable decl py : Double
Resolving variable decl pz : Double
Resolving variable decl rx : Double
Resolving variable decl ry : Double
Resolving variable decl rz : Double
Resolving variable decl sx : Double
Resolving variable decl sy : Double
Resolving variable decl sz : Double
Resolving variable decl pos : Double3 = Double3 new(px, py, pz)
Resolving variable decl rot : Double3 = Double3 new(rx, ry, rz)
Resolving variable decl scl : Double3 = Double3 new(sx, sy, sz)
Resolving variable decl genCall86 : String
====== Resolving type decl ClassDecl WorldClass
Resolving variable decl this : World = World alloc() as World
Resolving variable decl mode : GLenum
Resolving variable decl object : GameObject
Resolving variable decl iter124 : LinkedListIterator<GameObject> = World.objects iterator()
object = iter124 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
glLoadName(GameObject.id) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
object render() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl object : GameObject
Resolving variable decl iter125 : LinkedListIterator<GameObject> = World.objects iterator()
object = iter125 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
glColor3ub(255, 0, 0) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
glColor3ub(255, 255, 255) (of type FunctionCall) wants to wholeAgain() because 'because of return type Void'
object render() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl cam : Camera
Resolving variable decl BUFSIZE : Int = 512
Resolving variable decl selectBuf : GLuint[BUFSIZE]
Resolving variable decl hits : GLint
Resolving variable decl viewport : GLint[4]
Resolving variable decl minz : Int = 2147483647
Resolving variable decl minid : Int = -1
Resolving variable decl i : Int
Resolving variable decl hits : GLint
Resolving variable decl names : GLuint*
Resolving variable decl jayjay : Int = 2147483647
Resolving variable decl i : Int
Resolving variable decl object : GameObject
Resolving variable decl filename : String
Resolving variable decl target : FileWriter = FileWriter new(filename)
Resolving variable decl mesh : StaticMesh
Resolving variable decl iter114 : Iterator<StaticMesh> = CFactory.meshes iterator()
Resolving variable decl object : GameObject
Resolving variable decl iter126 : LinkedListIterator<GameObject> = World.objects iterator()
object = iter126 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
target write(CProduct.id&, IntClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.x&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.y&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.z&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.x&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.y&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.z&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.x&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.y&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
target write(Double3.z&, DoubleClass.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type SizeT'
Resolving variable decl filename : String
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl fileMeshes : HashMap<String> = HashMap<String> new()
Resolving variable decl line : String = readLine(source)
Resolving variable decl nMeshes : Int = 0
Resolving variable decl i : Int
Resolving variable decl line : String = readLine(source)
Resolving variable decl id : Int
Resolving variable decl filename : String = String new(1024)
Resolving variable decl nObjects : Int
Resolving variable decl i : Int
Resolving variable decl id : Int
Resolving variable decl px : Double
Resolving variable decl py : Double
Resolving variable decl pz : Double
Resolving variable decl rx : Double
Resolving variable decl ry : Double
Resolving variable decl rz : Double
Resolving variable decl sx : Double
Resolving variable decl sy : Double
Resolving variable decl sz : Double
Resolving variable decl pos : Double3 = Double3 new(px, py, pz)
Resolving variable decl rot : Double3 = Double3 new(rx, ry, rz)
Resolving variable decl scl : Double3 = Double3 new(sx, sy, sz)
Resolving variable decl genCall86 : String
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
__OP_EQ_String_String__Bool(ftoken, "v") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
__OP_EQ_String_String__Bool(ftoken, "f") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
__OP_EQ_String_String__Bool(ftoken, "f") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
__OP_EQ_String_String__Bool(ftoken, "vt") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
__OP_EQ_String_String__Bool(ftoken, "vn") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
__OP_EQ_String_String__Bool(ftoken, "#") (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
memcpy(returnArg115, returnVal116&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 4, 11 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/ArrayList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl ArrayList
Resolving variable decl T : Class
Resolving variable decl data : T*
Resolving variable decl capacity : Int
Resolving variable decl size : Int = 0
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl bsize : Int = (ArrayList.size - index) * Class.size
Resolving variable decl index : Int
Resolving variable decl returnVal6 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = -1
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = ArrayList.size
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal8 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = this indexOf(element)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl old : T = gc_malloc(Class.size)
Resolving variable decl returnVal90 : T = gc_malloc(Class.size)
Resolving variable decl newSize : Int
Resolving variable decl tmpData : Pointer = gc_realloc(ArrayList.data, ArrayList.capacity * Class.size)
Resolving variable decl x : Int = 0
Resolving variable decl index : Int
__OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size()) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size())) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Index too big! ", index), " >= "), this size())) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl copy : ArrayList<T> = ArrayList<T> new(this size())
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl bsize : Int = (ArrayList.size - index) * Class.size
Resolving variable decl index : Int
Resolving variable decl returnVal6 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = -1
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = ArrayList.size
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal8 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = this indexOf(element)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl old : T = gc_malloc(Class.size)
Resolving variable decl returnVal90 : T = gc_malloc(Class.size)
Resolving variable decl newSize : Int
Resolving variable decl tmpData : Pointer = gc_realloc(ArrayList.data, ArrayList.capacity * Class.size)
Resolving variable decl x : Int = 0
Resolving variable decl index : Int
Resolving variable decl copy : ArrayList<T> = ArrayList<T> new(this size())
====== Resolving type decl ClassDecl ArrayListIterator
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal10 : T = gc_malloc(Class.size)
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal12 : T = gc_malloc(Class.size)
Resolving variable decl genCall91 : T = gc_malloc(Class.size)
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal10 : T = gc_malloc(Class.size)
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal12 : T = gc_malloc(Class.size)
Resolving variable decl genCall91 : T = gc_malloc(Class.size)
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
Resolving variable decl genCall92 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal94 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal94, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg93, returnVal94, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl data : T*
Resolving variable decl size : SizeT
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/List
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl List
Resolving variable decl T : Class
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl iter19 : Iterator<T> = list iterator()
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T = gc_malloc(Class.size)
Resolving variable decl genArg15 : T = gc_malloc(Class.size)
Resolving variable decl size : Int = this size()
Resolving variable decl element : T
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : Int = this indexOf(oldie)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T = gc_malloc(Class.size)
Resolving variable decl returnVal18 : T = gc_malloc(Class.size)
Resolving variable decl genCall95 : T = gc_malloc(Class.size)
Resolving variable decl returnVal97 : T = gc_malloc(Class.size)
Resolving variable decl i : Int = 0
Resolving variable decl j : Int = this size() - 1
Resolving variable decl genCall20 : T = gc_malloc(Class.size)
Resolving variable decl genArg21 : T = gc_malloc(Class.size)
Resolving variable decl genCall22 : T = gc_malloc(Class.size)
Resolving variable decl genArg23 : T = gc_malloc(Class.size)
Resolving variable decl arr : T* = gc_malloc(this size() * Class.size)
Resolving variable decl i : Int
Resolving variable decl str : String
Resolving variable decl result : Buffer = Buffer new()
Resolving variable decl first : Bool = true
Resolving variable decl item : String
Resolving variable decl iter98 : Iterator<T> = this iterator()
Resolving variable decl chr : Char
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl iter19 : Iterator<T> = list iterator()
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T = gc_malloc(Class.size)
Resolving variable decl genArg15 : T = gc_malloc(Class.size)
Resolving variable decl size : Int = this size()
Resolving variable decl element : T
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : Int = this indexOf(oldie)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T = gc_malloc(Class.size)
Resolving variable decl returnVal18 : T = gc_malloc(Class.size)
Resolving variable decl genCall95 : T = gc_malloc(Class.size)
Resolving variable decl returnVal97 : T = gc_malloc(Class.size)
Resolving variable decl i : Int = 0
Resolving variable decl j : Int = this size() - 1
Resolving variable decl genCall20 : T = gc_malloc(Class.size)
Resolving variable decl genArg21 : T = gc_malloc(Class.size)
Resolving variable decl genCall22 : T = gc_malloc(Class.size)
Resolving variable decl genArg23 : T = gc_malloc(Class.size)
Resolving variable decl arr : T* = gc_malloc(this size() * Class.size)
Resolving variable decl i : Int
Resolving variable decl str : String
Resolving variable decl result : Buffer = Buffer new()
Resolving variable decl first : Bool = true
Resolving variable decl item : String
Resolving variable decl iter98 : Iterator<T> = this iterator()
Resolving variable decl chr : Char
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
Resolving variable decl genCall99 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal101 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal101, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg100, returnVal101, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CInputTask
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CInputTask
Resolving variable decl keyCount : Int
Resolving variable decl dX : Int
Resolving variable decl dY : Int
Resolving variable decl event : Event
Resolving variable decl listeners : LinkedList<Listener>
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
Resolving variable decl listener : <unknown type>
CInputTask.listeners iterator() (of type FunctionCall) wants to wholeAgain() because 'because of return type LinkedListIterator<Listener>'
iter127 hasNext() (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
	$$$$ resolving returnType T for iter127 next()
iter127 next() (of type FunctionCall) wants to wholeAgain() because 'because of return type Listener'
for (listener in CInputTask.listeners) (of type Foreach) wants to wholeAgain() because 'Just turned into a while =)'
Resolving variable decl event : Event
Resolving variable decl listener : Listener
Resolving variable decl listener : Listener
CInputTask.listeners remove(listener) (of type FunctionCall) wants to wholeAgain() because 'because of return type Bool'
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
Resolving variable decl listener : Listener
Resolving variable decl iter127 : LinkedListIterator<Listener> = CInputTask.listeners iterator()
listener = iter127 next() (of type BinaryOp) wants to wholeAgain() because 'just replaced with fCall and set ourselves as returnArg'
listener handleEvent(event) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl event : Event
Resolving variable decl listener : Listener
Resolving variable decl listener : Listener
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/LinkedList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LinkedList
Resolving variable decl T : Class
Resolving variable decl size : Int = 0
Resolving variable decl first : Node<T>
Resolving variable decl last : Node<T>
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : Node<T> = this getNode(index - 1)
Resolving variable decl nextNode : Node<T> = Node<T>.next
Resolving variable decl node : Node<T> = Node<T> new(prevNode, nextNode, data)
this size() (of type FunctionCall) wants to wholeAgain() because 'because of return type Int'
Resolving variable decl node : Node<T> = Node<T> new(NullLiteral, LinkedList.first, data)
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl next : Node<T> = Node<T>.next
Resolving variable decl index : Int
Resolving variable decl returnVal107 : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl i : Int = 0
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl i : Int = 0
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.last
Resolving variable decl i : Int = LinkedList.size - 1
Resolving variable decl index : Int
Resolving variable decl toRemove : Node<T> = this getNode(index)
Resolving variable decl returnVal109 : T = gc_malloc(Class.size)
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < ") + LinkedList.size (of type BinaryOp) wants to wholeAgain() because 'Just replaced with an operator overloading'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) looping because not resolved!'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() looping because not resolved!'
removeAt: func (index : Int) (of type FunctionDecl) wants to wholeAgain() because 'last's type is null'
Resolving variable decl data : T
Resolving variable decl i : Int = this indexOf(data)
Resolving variable decl toRemove : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl returnVal118 : Pointer = NullLiteral
memcpy(returnArg117, returnVal118&, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl current : Node<T> = first
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : Node<T> = this getNode(index - 1)
Resolving variable decl nextNode : Node<T> = Node<T>.next
Resolving variable decl node : Node<T> = Node<T> new(prevNode, nextNode, data)
Resolving variable decl node : Node<T> = Node<T> new(NullLiteral, LinkedList.first, data)
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl next : Node<T> = Node<T>.next
Resolving variable decl index : Int
Resolving variable decl returnVal107 : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl i : Int = 0
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl i : Int = 0
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.last
Resolving variable decl i : Int = LinkedList.size - 1
Resolving variable decl index : Int
Resolving variable decl toRemove : Node<T> = this getNode(index)
Resolving variable decl returnVal109 : T = gc_malloc(Class.size)
__OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) (of type FunctionCall) wants to wholeAgain() because 'because of return type Exception'
Exception new(This, __OP_ADD_String_Int__String(__OP_ADD_String_String__String(__OP_ADD_String_Int__String("Check index: 0 <= ", index), " < "), LinkedList.size)) throw() (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl data : T
Resolving variable decl i : Int = this indexOf(data)
Resolving variable decl toRemove : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl returnVal118 : Pointer = NullLiteral
Resolving variable decl current : Node<T> = LinkedList.first
====== Resolving type decl ClassDecl Node
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl prev : Node<T>
Resolving variable decl next : Node<T>
Resolving variable decl data : T = gc_malloc(Class.size)
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
====== Resolving type decl ClassDecl LinkedListIterator
Resolving variable decl T : Class
Resolving variable decl current : Node<T>
Resolving variable decl list : LinkedList<T>
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = LinkedListIterator.current
Resolving variable decl returnVal26 : T = gc_malloc(Class.size)
Resolving variable decl returnVal28 : T = gc_malloc(Class.size)
Resolving variable decl old : Node<T> = LinkedListIterator.current
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = LinkedListIterator.current
Resolving variable decl returnVal26 : T = gc_malloc(Class.size)
Resolving variable decl returnVal28 : T = gc_malloc(Class.size)
Resolving variable decl old : Node<T> = LinkedListIterator.current
Resolving variable decl list : LinkedList<T>
Resolving variable decl index : Int
Resolving variable decl T : Class
Resolving variable decl genCall29 : T = gc_malloc(Class.size)
Resolving variable decl returnVal31 : T = gc_malloc(Class.size)
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CKernel
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CKernel
Resolving variable decl taskList : LinkedList<ITask>
Resolving variable decl pausedTaskList : LinkedList<ITask>
====== Resolving type decl ClassDecl CKernelClass
Resolving variable decl instance : CKernel = NullLiteral
Resolving variable decl this : CKernel = CKernel alloc() as CKernel
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : ITask
Resolving variable decl iter119 : LinkedListIterator<ITask> = CKernel.taskList iterator()
Resolving variable decl task : ITask
Resolving variable decl iter120 : LinkedListIterator<ITask> = CKernel.taskList iterator()
Resolving variable decl task : ITask
Resolving variable decl iter121 : LinkedListIterator<ITask> = CKernel.taskList iterator()
Resolving variable decl t : ITask
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : ITask
Resolving variable decl iter122 : LinkedListIterator<ITask> = CKernel.taskList iterator()
Resolving variable decl t : ITask
Resolving variable decl task : ITask
Resolving variable decl iter123 : LinkedListIterator<ITask> = CKernel.taskList iterator()
====== Resolving type decl ClassDecl CKernelClass
Resolving variable decl instance : CKernel = NullLiteral
Resolving variable decl this : CKernel = CKernel alloc() as CKernel
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : ITask
Resolving variable decl iter119 : LinkedListIterator<ITask> = CKernel.taskList iterator()
Resolving variable decl task : ITask
Resolving variable decl iter120 : LinkedListIterator<ITask> = CKernel.taskList iterator()
Resolving variable decl task : ITask
Resolving variable decl iter121 : LinkedListIterator<ITask> = CKernel.taskList iterator()
Resolving variable decl t : ITask
Resolving variable decl t : ITask
Resolving variable decl pos : Int = 0
Resolving variable decl task : ITask
Resolving variable decl iter122 : LinkedListIterator<ITask> = CKernel.taskList iterator()
Resolving variable decl t : ITask
Resolving variable decl task : ITask
Resolving variable decl iter123 : LinkedListIterator<ITask> = CKernel.taskList iterator()
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module CKernel finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module LevelEditor
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LevelEditor
Resolving variable decl NONE : Int = 0
Resolving variable decl GRAB : Int = 1
Resolving variable decl SCALE : Int = 2
Resolving variable decl ROTATE : Int = 3
Resolving variable decl ADDMODEL : Int = 4
Resolving variable decl currentModelName : Node<String>
Resolving variable decl currentModelType : CProduct
Resolving variable decl grabLock : Int3 = Int3 new(0, 0, 0)
Resolving variable decl rotLock : Int3 = Int3 new(0, 0, 0)
Resolving variable decl sclLock : Int3 = Int3 new(0, 0, 0)
Resolving variable decl camera : FFCamera
Resolving variable decl wire : Bool = false
Resolving variable decl world : World = World new()
Resolving variable decl mode : Bool = false
Resolving variable decl editMode : Int = LevelEditor.NONE
Resolving variable decl backupPos : Double3 = Double3 new(0, 0, 0)
====== Resolving type decl ClassDecl LevelEditorClass
Resolving variable decl this : LevelEditor = LevelEditor alloc() as LevelEditor
Resolving variable decl name : String
Resolving variable decl ambientLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl genArg32 : Float = 0.200000
Resolving variable decl genArg33 : Float = 0.200000
Resolving variable decl genArg34 : Float = 0.200000
Resolving variable decl genArg35 : Float = 1.000000
Resolving variable decl diffuseLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl specularLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl position : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl event : Event
Resolving variable decl event : Event
Resolving variable decl mouse : Double3 = this getMouseVector(Motion.x, Motion.y)
Resolving variable decl mouse : Double3
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.y - Double3.y) / (Double3.y - Double3.y)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl i : Int
Resolving variable decl i : Int
Resolving variable decl mousex : Int
Resolving variable decl mousey : Int
Resolving variable decl Bx : GLdouble
Resolving variable decl By : GLdouble
Resolving variable decl Bz : GLdouble
Resolving variable decl viewport : GLint[4]
Resolving variable decl mvmatrix : GLdouble[16]
Resolving variable decl projmatrix : GLdouble[16]
====== Resolving type decl ClassDecl LevelEditorClass
Resolving variable decl this : LevelEditor = LevelEditor alloc() as LevelEditor
Resolving variable decl name : String
Resolving variable decl ambientLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl genArg32 : Float = 0.200000
Resolving variable decl genArg33 : Float = 0.200000
Resolving variable decl genArg34 : Float = 0.200000
Resolving variable decl genArg35 : Float = 1.000000
Resolving variable decl diffuseLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl specularLight : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl position : ArrayList<GLfloat> = ArrayList<GLfloat> new()
Resolving variable decl event : Event
Resolving variable decl event : Event
Resolving variable decl mouse : Double3 = this getMouseVector(Motion.x, Motion.y)
Resolving variable decl mouse : Double3
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.y - Double3.y) / (Double3.y - Double3.y)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = t * (Double3.x - Double3.x) + Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.z - Double3.z) / (Double3.z - Double3.z)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = t * (Double3.y - Double3.y) + Double3.y
Resolving variable decl Mz : Double = Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl t : Double = (Double3.x - Double3.x) / (Double3.x - Double3.x)
Resolving variable decl Mx : Double = Double3.x
Resolving variable decl My : Double = Double3.y
Resolving variable decl Mz : Double = t * (Double3.z - Double3.z) + Double3.z
 >> Resolving [Mx, My, Mz]
Resolving variable decl event : Event
Resolving variable decl keysym : Keysym
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl pos : Double3
Resolving variable decl rot : Double3
Resolving variable decl scl : Double3
Resolving variable decl i : Int
Resolving variable decl i : Int
Resolving variable decl mousex : Int
Resolving variable decl mousey : Int
Resolving variable decl Bx : GLdouble
Resolving variable decl By : GLdouble
Resolving variable decl Bz : GLdouble
Resolving variable decl viewport : GLint[4]
Resolving variable decl mvmatrix : GLdouble[16]
Resolving variable decl projmatrix : GLdouble[16]
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module LevelEditor finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl PI : Float = 3.140000
====== Resolving type decl ClassDecl Double2
Resolving variable decl x : Double
Resolving variable decl y : Double
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double3
Resolving variable decl x : Double
Resolving variable decl y : Double
Resolving variable decl z : Double
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : Double = this length()
__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String(__OP_ADD_String_String__String(__OP_ADD_String_Double__String("(", Double3.x), "|"), Double3.y), "|"), Double3.z), ")") (of type FunctionCall) wants to wholeAgain() because 'because of return type String'
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : Double = this length()
====== Resolving type decl CoverDecl Float2
Resolving variable decl x : Float
Resolving variable decl y : Float
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl CoverDecl Float3
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl CoverDecl Float4
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl CoverDecl Octet3
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl CoverDecl Octet4
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl CoverDecl Int3
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl CoverDecl Int2
Resolving variable decl x : Int
Resolving variable decl y : Int
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl CoverDecl VFace
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl CoverDecl Face
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl CoverDecl FaceNoTex
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceNoTexClass
====== Resolving type decl ClassDecl FaceNoTexClass
Resolving variable decl v1 : Double3
Resolving variable decl n : Double
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl vals : Double*
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl d : Float
Resolving variable decl i3 : Int3
Resolving variable decl vals : Int*
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/HashMap
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl HashEntry
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl key : String
Resolving variable decl value : T = gc_malloc(Class.size)
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
====== Resolving type decl ClassDecl HashMap
Resolving variable decl T : Class
Resolving variable decl size : UInt
Resolving variable decl capacity : UInt
Resolving variable decl buckets : ArrayList<T>*
Resolving variable decl keys : ArrayList<String>
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl iter : Iterator<T> = HashMap.buckets[hash] iterator()
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl v1 : Int = HashMap.capacity / 0.700000
Resolving variable decl v2 : Int = HashMap.capacity * 2
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : T = gc_malloc(Class.size)
Resolving variable decl returnVal74 : Pointer = NullLiteral
Resolving variable decl key : String
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl i : UInt
Resolving variable decl cKey : String
Resolving variable decl _capacity : UInt
Resolving variable decl old_capacity : UInt = HashMap.capacity
Resolving variable decl old_buckets : ArrayList<T>* = gc_malloc(old_capacity * PointerClass.size) as ArrayList<T>*
Resolving variable decl i : UInt
Resolving variable decl i : UInt
Resolving variable decl entry : HashEntry<T>
Resolving variable decl bucket : UInt
Resolving variable decl iter : Iterator<T> = old_buckets[bucket] iterator()
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl iter : Iterator<T> = HashMap.buckets[hash] iterator()
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl v1 : Int = HashMap.capacity / 0.700000
Resolving variable decl v2 : Int = HashMap.capacity * 2
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : T = gc_malloc(Class.size)
Resolving variable decl returnVal74 : Pointer = NullLiteral
Resolving variable decl key : String
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl i : UInt
Resolving variable decl cKey : String
Resolving variable decl _capacity : UInt
Resolving variable decl old_capacity : UInt = HashMap.capacity
Resolving variable decl old_buckets : ArrayList<T>* = gc_malloc(old_capacity * PointerClass.size) as ArrayList<T>*
Resolving variable decl i : UInt
Resolving variable decl i : UInt
Resolving variable decl entry : HashEntry<T>
Resolving variable decl bucket : UInt
Resolving variable decl iter : Iterator<T> = old_buckets[bucket] iterator()
====== Resolving type decl ClassDecl HashMapValueIterator
Resolving variable decl T : Class
Resolving variable decl map : HashMap<T>
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
Resolving variable decl key : String
Resolving variable decl genCall75 : T = gc_malloc(Class.size)
Resolving variable decl returnVal77 : T = gc_malloc(Class.size)
Resolving variable decl key : String
Resolving variable decl genCall78 : T = gc_malloc(Class.size)
Resolving variable decl returnVal80 : T = gc_malloc(Class.size)
Resolving variable decl genCall110 : String
Resolving variable decl result : Bool = HashMapValueIterator.map remove((comma expr))
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
Resolving variable decl key : String
Resolving variable decl genCall75 : T = gc_malloc(Class.size)
Resolving variable decl returnVal77 : T = gc_malloc(Class.size)
Resolving variable decl key : String
Resolving variable decl genCall78 : T = gc_malloc(Class.size)
Resolving variable decl returnVal80 : T = gc_malloc(Class.size)
Resolving variable decl genCall110 : String
Resolving variable decl result : Bool = HashMapValueIterator.map remove((comma expr))
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl T : Class
Resolving variable decl genCall111 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
Resolving variable decl returnVal113 : T = gc_malloc(size)
gc_malloc(Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type Pointer'
memcpy(returnVal113, (comma expr), Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
memcpy(returnArg112, returnVal113, Class.size) (of type FunctionCall) wants to wholeAgain() because 'because of return type void'
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module World
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl World
Resolving variable decl objects : LinkedList<GameObject> = LinkedList<GameObject> new()
Resolving variable decl id : Int = 0
Resolving variable decl pickedID : Int = -1
Resolving variable decl picked : GameObject = NullLiteral
====== Resolving type decl ClassDecl WorldClass
Resolving variable decl this : World = World alloc() as World
Resolving variable decl mode : GLenum
Resolving variable decl object : GameObject
Resolving variable decl iter124 : LinkedListIterator<GameObject> = World.objects iterator()
Resolving variable decl object : GameObject
Resolving variable decl iter125 : LinkedListIterator<GameObject> = World.objects iterator()
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl cam : Camera
Resolving variable decl BUFSIZE : Int = 512
Resolving variable decl selectBuf : GLuint[BUFSIZE]
Resolving variable decl hits : GLint
Resolving variable decl viewport : GLint[4]
Resolving variable decl minz : Int = 2147483647
Resolving variable decl minid : Int = -1
Resolving variable decl i : Int
Resolving variable decl hits : GLint
Resolving variable decl names : GLuint*
Resolving variable decl jayjay : Int = 2147483647
Resolving variable decl i : Int
Resolving variable decl object : GameObject
Resolving variable decl filename : String
Resolving variable decl target : FileWriter = FileWriter new(filename)
Resolving variable decl mesh : StaticMesh
Resolving variable decl iter114 : Iterator<StaticMesh> = CFactory.meshes iterator()
Resolving variable decl object : GameObject
Resolving variable decl iter126 : LinkedListIterator<GameObject> = World.objects iterator()
Resolving variable decl filename : String
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl fileMeshes : HashMap<String> = HashMap<String> new()
Resolving variable decl line : String = readLine(source)
Resolving variable decl nMeshes : Int = 0
Resolving variable decl i : Int
Resolving variable decl line : String = readLine(source)
Resolving variable decl id : Int
Resolving variable decl filename : String = String new(1024)
Resolving variable decl nObjects : Int
Resolving variable decl i : Int
Resolving variable decl id : Int
Resolving variable decl px : Double
Resolving variable decl py : Double
Resolving variable decl pz : Double
Resolving variable decl rx : Double
Resolving variable decl ry : Double
Resolving variable decl rz : Double
Resolving variable decl sx : Double
Resolving variable decl sy : Double
Resolving variable decl sz : Double
Resolving variable decl pos : Double3 = Double3 new(px, py, pz)
Resolving variable decl rot : Double3 = Double3 new(rx, ry, rz)
Resolving variable decl scl : Double3 = Double3 new(sx, sy, sz)
Resolving variable decl genCall86 : String
====== Resolving type decl ClassDecl WorldClass
Resolving variable decl this : World = World alloc() as World
Resolving variable decl mode : GLenum
Resolving variable decl object : GameObject
Resolving variable decl iter124 : LinkedListIterator<GameObject> = World.objects iterator()
Resolving variable decl object : GameObject
Resolving variable decl iter125 : LinkedListIterator<GameObject> = World.objects iterator()
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl cam : Camera
Resolving variable decl BUFSIZE : Int = 512
Resolving variable decl selectBuf : GLuint[BUFSIZE]
Resolving variable decl hits : GLint
Resolving variable decl viewport : GLint[4]
Resolving variable decl minz : Int = 2147483647
Resolving variable decl minid : Int = -1
Resolving variable decl i : Int
Resolving variable decl hits : GLint
Resolving variable decl names : GLuint*
Resolving variable decl jayjay : Int = 2147483647
Resolving variable decl i : Int
Resolving variable decl object : GameObject
Resolving variable decl filename : String
Resolving variable decl target : FileWriter = FileWriter new(filename)
Resolving variable decl mesh : StaticMesh
Resolving variable decl iter114 : Iterator<StaticMesh> = CFactory.meshes iterator()
Resolving variable decl object : GameObject
Resolving variable decl iter126 : LinkedListIterator<GameObject> = World.objects iterator()
Resolving variable decl filename : String
Resolving variable decl source : FileReader = FileReader new(filename)
Resolving variable decl fileMeshes : HashMap<String> = HashMap<String> new()
Resolving variable decl line : String = readLine(source)
Resolving variable decl nMeshes : Int = 0
Resolving variable decl i : Int
Resolving variable decl line : String = readLine(source)
Resolving variable decl id : Int
Resolving variable decl filename : String = String new(1024)
Resolving variable decl nObjects : Int
Resolving variable decl i : Int
Resolving variable decl id : Int
Resolving variable decl px : Double
Resolving variable decl py : Double
Resolving variable decl pz : Double
Resolving variable decl rx : Double
Resolving variable decl ry : Double
Resolving variable decl rz : Double
Resolving variable decl sx : Double
Resolving variable decl sy : Double
Resolving variable decl sz : Double
Resolving variable decl pos : Double3 = Double3 new(px, py, pz)
Resolving variable decl rot : Double3 = Double3 new(rx, ry, rz)
Resolving variable decl scl : Double3 = Double3 new(sx, sy, sz)
Resolving variable decl genCall86 : String
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module World finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 5, 8 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/ArrayList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl ArrayList
Resolving variable decl T : Class
Resolving variable decl data : T*
Resolving variable decl capacity : Int
Resolving variable decl size : Int = 0
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl bsize : Int = (ArrayList.size - index) * Class.size
Resolving variable decl index : Int
Resolving variable decl returnVal6 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = -1
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = ArrayList.size
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal8 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = this indexOf(element)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl old : T = gc_malloc(Class.size)
Resolving variable decl returnVal90 : T = gc_malloc(Class.size)
Resolving variable decl newSize : Int
Resolving variable decl tmpData : Pointer = gc_realloc(ArrayList.data, ArrayList.capacity * Class.size)
Resolving variable decl x : Int = 0
Resolving variable decl index : Int
Resolving variable decl copy : ArrayList<T> = ArrayList<T> new(this size())
====== Resolving type decl ClassDecl ArrayListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl T : Class
Resolving variable decl this : ArrayList = ArrayList alloc() as ArrayList
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl dst : Octet*
Resolving variable decl src : Octet*
Resolving variable decl bsize : Int = (ArrayList.size - index) * Class.size
Resolving variable decl index : Int
Resolving variable decl returnVal6 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = -1
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = ArrayList.size
Resolving variable decl candidate : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal8 : T = gc_malloc(Class.size)
Resolving variable decl element : T
Resolving variable decl index : Int = this indexOf(element)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl old : T = gc_malloc(Class.size)
Resolving variable decl returnVal90 : T = gc_malloc(Class.size)
Resolving variable decl newSize : Int
Resolving variable decl tmpData : Pointer = gc_realloc(ArrayList.data, ArrayList.capacity * Class.size)
Resolving variable decl x : Int = 0
Resolving variable decl index : Int
Resolving variable decl copy : ArrayList<T> = ArrayList<T> new(this size())
====== Resolving type decl ClassDecl ArrayListIterator
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal10 : T = gc_malloc(Class.size)
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal12 : T = gc_malloc(Class.size)
Resolving variable decl genCall91 : T = gc_malloc(Class.size)
====== Resolving type decl ClassDecl ArrayListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : ArrayListIterator = ArrayListIterator alloc() as ArrayListIterator
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal10 : T = gc_malloc(Class.size)
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl returnVal12 : T = gc_malloc(Class.size)
Resolving variable decl genCall91 : T = gc_malloc(Class.size)
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
Resolving variable decl genCall92 : T = gc_malloc(Class.size)
Resolving variable decl returnVal94 : T = gc_malloc(Class.size)
Resolving variable decl list : ArrayList<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : ArrayList<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl data : T*
Resolving variable decl size : SizeT
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module structs/ArrayList finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/List
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl List
Resolving variable decl T : Class
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl iter19 : Iterator<T> = list iterator()
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T = gc_malloc(Class.size)
Resolving variable decl genArg15 : T = gc_malloc(Class.size)
Resolving variable decl size : Int = this size()
Resolving variable decl element : T
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : Int = this indexOf(oldie)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T = gc_malloc(Class.size)
Resolving variable decl returnVal18 : T = gc_malloc(Class.size)
Resolving variable decl genCall95 : T = gc_malloc(Class.size)
Resolving variable decl returnVal97 : T = gc_malloc(Class.size)
Resolving variable decl i : Int = 0
Resolving variable decl j : Int = this size() - 1
Resolving variable decl genCall20 : T = gc_malloc(Class.size)
Resolving variable decl genArg21 : T = gc_malloc(Class.size)
Resolving variable decl genCall22 : T = gc_malloc(Class.size)
Resolving variable decl genArg23 : T = gc_malloc(Class.size)
Resolving variable decl arr : T* = gc_malloc(this size() * Class.size)
Resolving variable decl i : Int
Resolving variable decl str : String
Resolving variable decl result : Buffer = Buffer new()
Resolving variable decl first : Bool = true
Resolving variable decl item : String
Resolving variable decl iter98 : Iterator<T> = this iterator()
Resolving variable decl chr : Char
====== Resolving type decl ClassDecl ListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : List = List alloc() as List
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl list : Iterable<T>
Resolving variable decl start : Int
Resolving variable decl list : Iterable<T>
Resolving variable decl element : T = gc_malloc(Class.size)
Resolving variable decl iter19 : Iterator<T> = list iterator()
Resolving variable decl index : Int = 0
Resolving variable decl iter : Iterator<T> = list iterator()
Resolving variable decl genCall14 : T = gc_malloc(Class.size)
Resolving variable decl genArg15 : T = gc_malloc(Class.size)
Resolving variable decl size : Int = this size()
Resolving variable decl element : T
Resolving variable decl oldie : T
Resolving variable decl kiddo : T
Resolving variable decl idx : Int = this indexOf(oldie)
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl index : Int
Resolving variable decl element : T
Resolving variable decl genCall16 : T = gc_malloc(Class.size)
Resolving variable decl returnVal18 : T = gc_malloc(Class.size)
Resolving variable decl genCall95 : T = gc_malloc(Class.size)
Resolving variable decl returnVal97 : T = gc_malloc(Class.size)
Resolving variable decl i : Int = 0
Resolving variable decl j : Int = this size() - 1
Resolving variable decl genCall20 : T = gc_malloc(Class.size)
Resolving variable decl genArg21 : T = gc_malloc(Class.size)
Resolving variable decl genCall22 : T = gc_malloc(Class.size)
Resolving variable decl genArg23 : T = gc_malloc(Class.size)
Resolving variable decl arr : T* = gc_malloc(this size() * Class.size)
Resolving variable decl i : Int
Resolving variable decl str : String
Resolving variable decl result : Buffer = Buffer new()
Resolving variable decl first : Bool = true
Resolving variable decl item : String
Resolving variable decl iter98 : Iterator<T> = this iterator()
Resolving variable decl chr : Char
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl T : Class
Resolving variable decl genCall99 : T = gc_malloc(Class.size)
Resolving variable decl returnVal101 : T = gc_malloc(Class.size)
Resolving variable decl list : List<T>
Resolving variable decl i : Int
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
Resolving variable decl list : List<T>
Resolving variable decl element : T
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module structs/List finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module CInputTask
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl CInputTask
Resolving variable decl keyCount : Int
Resolving variable decl dX : Int
Resolving variable decl dY : Int
Resolving variable decl event : Event
Resolving variable decl listeners : LinkedList<Listener>
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
Resolving variable decl listener : Listener
Resolving variable decl iter127 : LinkedListIterator<Listener> = CInputTask.listeners iterator()
Resolving variable decl event : Event
Resolving variable decl listener : Listener
Resolving variable decl listener : Listener
====== Resolving type decl ClassDecl CInputTaskClass
Resolving variable decl instance : CInputTask = NullLiteral
Resolving variable decl this : CInputTask = CInputTask alloc() as CInputTask
Resolving variable decl listener : Listener
Resolving variable decl iter127 : LinkedListIterator<Listener> = CInputTask.listeners iterator()
Resolving variable decl event : Event
Resolving variable decl listener : Listener
Resolving variable decl listener : Listener
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module CInputTask finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/LinkedList
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl LinkedList
Resolving variable decl T : Class
Resolving variable decl size : Int = 0
Resolving variable decl first : Node<T>
Resolving variable decl last : Node<T>
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : Node<T> = this getNode(index - 1)
Resolving variable decl nextNode : Node<T> = Node<T>.next
Resolving variable decl node : Node<T> = Node<T> new(prevNode, nextNode, data)
Resolving variable decl node : Node<T> = Node<T> new(NullLiteral, LinkedList.first, data)
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl next : Node<T> = Node<T>.next
Resolving variable decl index : Int
Resolving variable decl returnVal107 : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl i : Int = 0
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl i : Int = 0
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.last
Resolving variable decl i : Int = LinkedList.size - 1
Resolving variable decl index : Int
Resolving variable decl toRemove : Node<T> = this getNode(index)
Resolving variable decl returnVal109 : T = gc_malloc(Class.size)
Resolving variable decl data : T
Resolving variable decl i : Int = this indexOf(data)
Resolving variable decl toRemove : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl returnVal118 : Pointer = NullLiteral
Resolving variable decl current : Node<T> = LinkedList.first
====== Resolving type decl ClassDecl LinkedListClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedList = LinkedList alloc() as LinkedList
Resolving variable decl data : T
Resolving variable decl node : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl prevNode : Node<T> = this getNode(index - 1)
Resolving variable decl nextNode : Node<T> = Node<T>.next
Resolving variable decl node : Node<T> = Node<T> new(prevNode, nextNode, data)
Resolving variable decl node : Node<T> = Node<T> new(NullLiteral, LinkedList.first, data)
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl next : Node<T> = Node<T>.next
Resolving variable decl index : Int
Resolving variable decl returnVal107 : T = gc_malloc(Class.size)
Resolving variable decl index : Int
Resolving variable decl i : Int = 0
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.first
Resolving variable decl i : Int = 0
Resolving variable decl data : T
Resolving variable decl current : Node<T> = LinkedList.last
Resolving variable decl i : Int = LinkedList.size - 1
Resolving variable decl index : Int
Resolving variable decl toRemove : Node<T> = this getNode(index)
Resolving variable decl returnVal109 : T = gc_malloc(Class.size)
Resolving variable decl data : T
Resolving variable decl i : Int = this indexOf(data)
Resolving variable decl toRemove : Node<T>
Resolving variable decl index : Int
Resolving variable decl data : T
Resolving variable decl returnVal118 : Pointer = NullLiteral
Resolving variable decl current : Node<T> = LinkedList.first
====== Resolving type decl ClassDecl Node
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl prev : Node<T>
Resolving variable decl next : Node<T>
Resolving variable decl data : T = gc_malloc(Class.size)
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
====== Resolving type decl ClassDecl NodeClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
Resolving variable decl T : Class
Resolving variable decl this : Node = Node alloc() as Node
====== Resolving type decl ClassDecl LinkedListIterator
Resolving variable decl T : Class
Resolving variable decl current : Node<T>
Resolving variable decl list : LinkedList<T>
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = LinkedListIterator.current
Resolving variable decl returnVal26 : T = gc_malloc(Class.size)
Resolving variable decl returnVal28 : T = gc_malloc(Class.size)
Resolving variable decl old : Node<T> = LinkedListIterator.current
====== Resolving type decl ClassDecl LinkedListIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : LinkedListIterator = LinkedListIterator alloc() as LinkedListIterator
Resolving variable decl prev : Node<T> = LinkedListIterator.current
Resolving variable decl returnVal26 : T = gc_malloc(Class.size)
Resolving variable decl returnVal28 : T = gc_malloc(Class.size)
Resolving variable decl old : Node<T> = LinkedListIterator.current
Resolving variable decl list : LinkedList<T>
Resolving variable decl index : Int
Resolving variable decl T : Class
Resolving variable decl genCall29 : T = gc_malloc(Class.size)
Resolving variable decl returnVal31 : T = gc_malloc(Class.size)
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module structs/LinkedList finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/types
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl PI : Float = 3.140000
====== Resolving type decl ClassDecl Double2
Resolving variable decl x : Double
Resolving variable decl y : Double
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double2Class
Resolving variable decl this : Double2 = Double2 alloc() as Double2
====== Resolving type decl ClassDecl Double3
Resolving variable decl x : Double
Resolving variable decl y : Double
Resolving variable decl z : Double
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : Double = this length()
====== Resolving type decl ClassDecl Double3Class
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl this : Double3 = Double3 alloc() as Double3
Resolving variable decl v : Double3
Resolving variable decl l : Double = this length()
====== Resolving type decl CoverDecl Float2
Resolving variable decl x : Float
Resolving variable decl y : Float
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl ClassDecl Float2Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl f2 : Float2
====== Resolving type decl CoverDecl Float3
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl ClassDecl Float3Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl f3 : Float3
Resolving variable decl f : Float3
====== Resolving type decl CoverDecl Float4
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl ClassDecl Float4Class
Resolving variable decl x : Float
Resolving variable decl y : Float
Resolving variable decl z : Float
Resolving variable decl w : Float
Resolving variable decl f4 : Float4
====== Resolving type decl CoverDecl Octet3
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl ClassDecl Octet3Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl f3 : Octet3
====== Resolving type decl CoverDecl Octet4
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl ClassDecl Octet4Class
Resolving variable decl x : Octet
Resolving variable decl y : Octet
Resolving variable decl z : Octet
Resolving variable decl w : Octet
Resolving variable decl f4 : Octet4
====== Resolving type decl CoverDecl Int3
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl ClassDecl Int3Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl z : Int
Resolving variable decl f3 : Int3
====== Resolving type decl CoverDecl Int2
Resolving variable decl x : Int
Resolving variable decl y : Int
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl ClassDecl Int2Class
Resolving variable decl x : Int
Resolving variable decl y : Int
Resolving variable decl f2 : Int2
====== Resolving type decl CoverDecl VFace
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl ClassDecl VFaceClass
====== Resolving type decl CoverDecl Face
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl t1 : Int
Resolving variable decl t2 : Int
Resolving variable decl t3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl ClassDecl FaceClass
====== Resolving type decl CoverDecl FaceNoTex
Resolving variable decl v1 : Int
Resolving variable decl v2 : Int
Resolving variable decl v3 : Int
Resolving variable decl n1 : Int
Resolving variable decl n2 : Int
Resolving variable decl n3 : Int
====== Resolving type decl ClassDecl FaceNoTexClass
====== Resolving type decl ClassDecl FaceNoTexClass
Resolving variable decl v1 : Double3
Resolving variable decl n : Double
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl v2 : Double3
Resolving variable decl v1 : Double3
Resolving variable decl vals : Double*
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl b : Float3
Resolving variable decl a : Float3
Resolving variable decl d : Float
Resolving variable decl i3 : Int3
Resolving variable decl vals : Int*
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module utils/types finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module structs/HashMap
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl HashEntry
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl key : String
Resolving variable decl value : T = gc_malloc(Class.size)
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
====== Resolving type decl ClassDecl HashEntryClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashEntry = HashEntry alloc() as HashEntry
====== Resolving type decl ClassDecl HashMap
Resolving variable decl T : Class
Resolving variable decl size : UInt
Resolving variable decl capacity : UInt
Resolving variable decl buckets : ArrayList<T>*
Resolving variable decl keys : ArrayList<String>
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl iter : Iterator<T> = HashMap.buckets[hash] iterator()
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl v1 : Int = HashMap.capacity / 0.700000
Resolving variable decl v2 : Int = HashMap.capacity * 2
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : T = gc_malloc(Class.size)
Resolving variable decl returnVal74 : Pointer = NullLiteral
Resolving variable decl key : String
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl i : UInt
Resolving variable decl cKey : String
Resolving variable decl _capacity : UInt
Resolving variable decl old_capacity : UInt = HashMap.capacity
Resolving variable decl old_buckets : ArrayList<T>* = gc_malloc(old_capacity * PointerClass.size) as ArrayList<T>*
Resolving variable decl i : UInt
Resolving variable decl i : UInt
Resolving variable decl entry : HashEntry<T>
Resolving variable decl bucket : UInt
Resolving variable decl iter : Iterator<T> = old_buckets[bucket] iterator()
====== Resolving type decl ClassDecl HashMapClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl T : Class
Resolving variable decl this : HashMap = HashMap alloc() as HashMap
Resolving variable decl i : UInt
Resolving variable decl keyTagazok : T
Resolving variable decl seed : UInt
Resolving variable decl len : SizeT = Class.size
Resolving variable decl m : UInt = 1540483477
Resolving variable decl r : Int = 24
Resolving variable decl h : UInt = seed ^ len
Resolving variable decl data : Octet* = keyTagazok as Octet*
Resolving variable decl k : UInt = (data as UInt*)@
Resolving variable decl s : Char*
Resolving variable decl h : UInt = s@
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = NullLiteral
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl iter : Iterator<T> = HashMap.buckets[hash] iterator()
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl load : Float
Resolving variable decl hash : UInt
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl v1 : Int = HashMap.capacity / 0.700000
Resolving variable decl v2 : Int = HashMap.capacity * 2
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl returnVal73 : T = gc_malloc(Class.size)
Resolving variable decl returnVal74 : Pointer = NullLiteral
Resolving variable decl key : String
Resolving variable decl key : String
Resolving variable decl entry : HashEntry<T> = this getEntry(key)
Resolving variable decl hash : UInt = this ac_X31_hash(key) % HashMap.capacity
Resolving variable decl i : UInt
Resolving variable decl cKey : String
Resolving variable decl _capacity : UInt
Resolving variable decl old_capacity : UInt = HashMap.capacity
Resolving variable decl old_buckets : ArrayList<T>* = gc_malloc(old_capacity * PointerClass.size) as ArrayList<T>*
Resolving variable decl i : UInt
Resolving variable decl i : UInt
Resolving variable decl entry : HashEntry<T>
Resolving variable decl bucket : UInt
Resolving variable decl iter : Iterator<T> = old_buckets[bucket] iterator()
====== Resolving type decl ClassDecl HashMapValueIterator
Resolving variable decl T : Class
Resolving variable decl map : HashMap<T>
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
Resolving variable decl key : String
Resolving variable decl genCall75 : T = gc_malloc(Class.size)
Resolving variable decl returnVal77 : T = gc_malloc(Class.size)
Resolving variable decl key : String
Resolving variable decl genCall78 : T = gc_malloc(Class.size)
Resolving variable decl returnVal80 : T = gc_malloc(Class.size)
Resolving variable decl genCall110 : String
Resolving variable decl result : Bool = HashMapValueIterator.map remove((comma expr))
====== Resolving type decl ClassDecl HashMapValueIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : HashMapValueIterator = HashMapValueIterator alloc() as HashMapValueIterator
Resolving variable decl key : String
Resolving variable decl genCall75 : T = gc_malloc(Class.size)
Resolving variable decl returnVal77 : T = gc_malloc(Class.size)
Resolving variable decl key : String
Resolving variable decl genCall78 : T = gc_malloc(Class.size)
Resolving variable decl returnVal80 : T = gc_malloc(Class.size)
Resolving variable decl genCall110 : String
Resolving variable decl result : Bool = HashMapValueIterator.map remove((comma expr))
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl T : Class
Resolving variable decl genCall111 : T = gc_malloc(Class.size)
Resolving variable decl returnVal113 : T = gc_malloc(Class.size)
Resolving variable decl map : HashMap<T>
Resolving variable decl key : String
Resolving variable decl value : T
Resolving variable decl T : Class
[Module] response = OK (wholeAgain = false)
++++++++++++++++ Module structs/HashMap finished resolving.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 6, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 7, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 8, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 9, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 10, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 11, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 12, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 13, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 14, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 15, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 16, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Face.t3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n1 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n2 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.v3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toInt() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toInt() looping because not resolved!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator -(v1 : Double3, v2 : Double3) == -1 !!'
tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = tok nextToken() toInt() (who is null? true, false, false, false)'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
FaceNoTex.n3 = tok nextToken() toInt() - 1 (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float2.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.x = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.y = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'tok nextToken() toFloat() looping because not resolved!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'score of operator =(v1 : Double3, vals : Double*) == -1 !!'
Float3.z = tok nextToken() toFloat() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
Resolving variable decl new_faces : VFace* = gc_malloc(nFaces * VFaceClass.size)
Resolving variable decl new_normals : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl vertex : Int
Resolving variable decl normal : Float3 = Float3 new(0, 0, 0)
Resolving variable decl meanCount : Float = 0.000000
Resolving variable decl face : Int
Resolving variable decl face : Int
Resolving variable decl file : File = File new(toName)
Resolving variable decl dest : FileWriter = FileWriter new(file, "wb")
[Module] response = OK (wholeAgain = true)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module text/StringTokenizer
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
====== Resolving type decl ClassDecl StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl index : Int = 0
Resolving variable decl length : Int
Resolving variable decl maxSplits : Int
Resolving variable decl splits : Int
Resolving variable decl empties : Bool
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerClass
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : String
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : String
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, delim, -1) (of type FunctionCall) wants to wholeAgain() because 'this(input, delim, -1) looping because not resolved!'
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
Resolving variable decl input : String
Resolving variable decl delim : Char
Resolving variable decl maxSplits : Int
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
this(input, String new(delim), maxSplits) (of type FunctionCall) wants to wholeAgain() because 'this(input, String new(delim), maxSplits) looping because not resolved!'
Resolving variable decl this : StringTokenizer = StringTokenizer alloc() as StringTokenizer
input length() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
input length() (of type FunctionCall) wants to wholeAgain() because 'input length() looping because not resolved!'
StringTokenizer.length = input length() (of type BinaryOp) wants to wholeAgain() because 'right type is unresolved'
StringTokenizerIterator new(this) (of type FunctionCall) wants to wholeAgain() because 'Looping StringTokenizerIterator new(this) because of typeArgs
'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
Resolving variable decl oldIndex : Int = StringTokenizer.index
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex) looping because not resolved!'
return StringTokenizer.input substring(oldIndex) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) looping because not resolved!'
this hasNext() && !StringTokenizer.delim contains(StringTokenizer.input[StringTokenizer.index]) (of type BinaryOp) wants to wholeAgain() because 'Unresolved types, looping to determine legitness left = this hasNext() (who is null? false, false, true, false)'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type FunctionCall) wants to wholeAgain() because 'StringTokenizer.input substring(oldIndex, StringTokenizer.index) looping because not resolved!'
return StringTokenizer.input substring(oldIndex, StringTokenizer.index) (of type Return) wants to wholeAgain() because 'Need info about the expr type'
====== Resolving type decl ClassDecl StringTokenizerIterator
Resolving variable decl T : Class
Resolving variable decl st : StringTokenizer
Resolving variable decl index : Int = 0
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl ClassDecl StringTokenizerIteratorClass
Resolving variable decl T : Class
Resolving variable decl T : Class
Resolving variable decl this : StringTokenizerIterator = StringTokenizerIterator alloc() as StringTokenizerIterator
Resolving variable decl returnVal88 : String = StringTokenizerIterator.st nextToken()
Resolving variable decl returnVal116 : Pointer = NullLiteral
====== Resolving type decl CoverDecl String
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
====== Resolving type decl ClassDecl StringClass
Resolving variable decl s : String
Resolving variable decl maxSplits : Int
Resolving variable decl c : Char
Resolving variable decl maxSplits : Int
Resolving variable decl s : String
Resolving variable decl c : Char
Resolving variable decl s : String
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, s)
Resolving variable decl c : Char
Resolving variable decl empties : Bool
Resolving variable decl tok : StringTokenizer = StringTokenizer new(this, c)
[Module] response = OK (wholeAgain = true)

=======================================

Tinkerer, round 17, 2 left

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Resolving module utils/convert
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Resolving variable decl fromName : String
Resolving variable decl toName : String
Resolving variable decl nVertices : Int = 0
Resolving variable decl nVertexNormals : Int = 0
Resolving variable decl nFaces : Int = 0
Resolving variable decl nTexCoordinates : Int = 0
Resolving variable decl nLines : Int = 0
Resolving variable decl source : FileReader = FileReader new(fromName)
Resolving variable decl line : String = readLine(source)
Resolving variable decl ftoken : String = getFirstToken(line)
Resolving variable decl vertices : Float3* = gc_malloc(nVertices * Float3Class.size)
Resolving variable decl normals : Float3* = gc_malloc(nVertexNormals * Float3Class.size)
Resolving variable decl texCoords : Float2* = gc_malloc(nTexCoordinates * Float2Class.size)
Resolving variable decl faces : Face* = gc_malloc(nFaces * FaceClass.size)
Resolving variable decl notexfaces : FaceNoTex* = gc_malloc(nFaces * FaceNoTexClass.size)
Resolving variable decl currentLine : Int = 0
Resolving variable decl line : String = readLine(source)
Resolving variable decl tok : StringTokenizer = StringTokenizer new(line, " /")
Resolving variable decl ftoken : String = tok nextToken()
tok nextToken() toFloat() (of type FunctionCall) wants to wholeAgain() because 'need ref and refType'
name = toFloat, refScore = -1, ref = (nil)
utils/convert:65:44 [ERROR] No such function String.toFloat()
            vertices[nVertices] x = tok nextToken() toFloat()
                                                    ^^^^^^^  
[1m[31m[FAIL]
[0mmake: *** [all] Error 1
